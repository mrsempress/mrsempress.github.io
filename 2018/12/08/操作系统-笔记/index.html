<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">


  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="课堂笔记," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="操作系统笔记与考前整理">
<meta name="keywords" content="课堂笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统-笔记">
<meta property="og:url" content="http://mrsempress.top/2018/12/08/操作系统-笔记/index.html">
<meta property="og:site_name" content="Mrs_empress">
<meta property="og:description" content="操作系统笔记与考前整理">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/分层I:O.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/多处理器.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/操作系统架构.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz2.1.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz2.2.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/进程的状态.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/进程的状态2.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/线程.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/用户空间和内核级线程.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz3.1.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz3.2.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz3.3.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz3.5.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz3.4.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/各种调度算法的比较.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz4.1.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz4.2.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz5.1.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz5.2.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz5.3.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz5.4.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz5.5.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz6.1.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz6.2.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz6.3.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/练习题5.5.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/页面置换算法.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz7.1.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz7.2.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz8.1.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz8.2.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz8.3.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz8.4.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz8.5.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz8.6.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz8.7.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/练习题8.7.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/练习题8.7.2.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/练习题8.8.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/文件系统布局.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/i-node.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/目录项分解的好处.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/长文件名.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/Linux文件系统调用.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/%E6%88%90%E7%BB%84%E9%93%BE%E6%8E%A5%E6%B3%95.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/%E6%88%90%E7%BB%84%E9%93%BE%E6%8E%A5%E6%B3%952.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz9.1.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz9.6.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz9.2.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz9.3.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz9.4.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz9.5.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz9.7.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz9.8.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/10.练习1.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/10.3.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/10.练习2.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz10.1.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz10.2.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz10.3.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/练习题10.1.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/练习题10.2.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/I:O管理.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/中断控制器.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/DMA.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/分层I:O.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz11.1.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz11.2.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz11.3.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz11.4.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz11.5.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/分层I:O.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/资源轨迹图.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz12.1.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz12.2.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz12.3.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz12.5.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz12.6.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/quiz12.4.png">
<meta property="og:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/多处理器系统.png">
<meta property="og:updated_time" content="2019-04-09T02:28:51.198Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统-笔记">
<meta name="twitter:description" content="操作系统笔记与考前整理">
<meta name="twitter:image" content="http://mrsempress.top/2018/12/08/操作系统-笔记/分层I:O.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://mrsempress.top/2018/12/08/操作系统-笔记/"/>





  <title>操作系统-笔记 | Mrs_empress</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0b0957531a34243a173c768258ed03c4";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <a href="https://mrsempress.github.io/" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#fff; color:#151513; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mrs_empress</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Your bright sun</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-poem">
          <a href="/poem" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />
            
            poem
          </a>
        </li>
      
        
        <li class="menu-item menu-item-resume">
          <a href="http://mrsempress-certificate.oss-cn-beijing.aliyuncs.com/%E9%BB%84%E6%99%A8%E6%99%B0.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            resume
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mrsempress.top/2018/12/08/操作系统-笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mrs_empress">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mrs_empress">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">操作系统-笔记</h1>
        

        <div class="post-meta">
	  
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-08T22:31:33+08:00">
                2018-12-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/软件工程/" itemprop="url" rel="index">
                    <span itemprop="name">软件工程</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/软件工程/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/12/08/操作系统-笔记/" class="leancloud_visitors" data-flag-title="操作系统-笔记">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>操作系统笔记与考前整理</p>
<a id="more"></a>
<p> #: 未讲部分</p>
<h2 id="考试题型"><a href="#考试题型" class="headerlink" title="考试题型"></a>考试题型</h2><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul>
<li>进程<ul>
<li>状态转换</li>
<li>PCB进程控制块</li>
</ul>
</li>
<li>线程<ul>
<li>用户级线程</li>
<li>内核级线程</li>
</ul>
</li>
<li><p>进程间通信IPC</p>
<ul>
<li>竞争条件</li>
<li>临界区</li>
<li>7种方法<ul>
<li>Mutual Exclusion with Busy Waiting（忙等待的互斥）</li>
<li>Sleep and Wakeup（休眠与唤醒）</li>
<li>Semaphores（信号量）</li>
<li>Mutexes（互斥锁）</li>
<li>Monitors（管程）</li>
<li>Message Passing（消息传递）</li>
<li>Barriers（屏障）</li>
</ul>
</li>
</ul>
</li>
<li><p>调度算法</p>
<ul>
<li>First Come First Serve</li>
<li>Round robin</li>
<li>Shorted Job First (nonpreemptive &amp; preemptive )</li>
<li>Priority Scheduling (nonpreemptive &amp; preemptive )</li>
<li>Multiple Queues</li>
<li>指标：平均周转时间(the mean process turnaround time)</li>
</ul>
</li>
</ul>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul>
<li>地址空间<ul>
<li>地址空间是一个进程可用于寻址内存的一套地址集合，存放可执行的程序、程序的数据和程序的堆栈</li>
<li>address binding of instructions and data to memory addresses can happened at three different stages, compile time, load time and execution time<ul>
<li>指令和数据到内存地址的地址绑定可以发生在三个不同的阶段，编译时，加载时和执行时</li>
</ul>
</li>
<li>内存过载<ul>
<li>对换/交换<ul>
<li>把一个进程完整调入内存，使该进程运行一段时间，然后把它存回磁盘</li>
</ul>
</li>
<li>虚拟存储器</li>
</ul>
</li>
<li>空闲内存管理<ul>
<li>位图<ul>
<li>简单，但搜索耗时</li>
</ul>
</li>
<li>空闲链表</li>
<li>First-fit首次适配, next-fit下次适配, worst-fit最差适配, best-fit最佳适配</li>
</ul>
</li>
</ul>
</li>
<li>虚拟内存<ul>
<li>每个程序拥有自己的地址空间，这些空间被分割为许多块，每一块叫做一页或页面。每一页有连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才可运行程序。当程序引用到一部分在物理内存中的地址空间时，由OS负责将缺失的部分装入物理内存并重新执行失败的指令</li>
<li>虚拟地址空间单元为页面page；物理内存对应单元为页框page frame，两者大小相同；页表page tables记录两者的映射关系</li>
<li>若某页面没有被映射，则CPU陷入到操作系统，这个陷阱称为缺页中断。操作系统替换一个页框，并把刚才需要访问的页面换入该页框中，修改映射关系，重新启动引起陷阱的指令</li>
<li>虚拟地址和物理地址的映射</li>
<li>虚拟地址空间划分，计算页面大小</li>
<li>页存储</li>
<li>页表</li>
<li>页替换算法：缺页次数<ul>
<li>The Optimal Page Replacement Algorithms（最优页面置换算法）</li>
<li>The NRU(Not Recently Used) Page Replacement Algorithms（最近未使用页面置换算法）<ul>
<li>（<strong>访问位R，修改位M</strong>）</li>
</ul>
</li>
<li>The FIFO(First in First Out) Page Replacement Algorithms</li>
<li>The Second Chance Page Replacement Algorithms</li>
<li>The Clock Page Replacement Algorithms（时钟页面置换算法）</li>
<li>The LRU(Least Recently Used) Page Replacement Algorithms（最近最少使用页面置换算法）<ul>
<li>行置一，列置零</li>
</ul>
</li>
<li>The Working Set Page Replacement Algorithms（工作集页面置换算法）</li>
<li>The WSClock Page Replacement Algorithms（工作集时钟页面置换算法）</li>
</ul>
</li>
<li>段</li>
</ul>
</li>
</ul>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><ul>
<li>文件<ul>
<li>普通文件：二进制文件，ASCII文件</li>
<li>特殊文件：块特殊文件、字符特殊文件</li>
<li>文件属性</li>
</ul>
</li>
<li>目录<ul>
<li>Single-level, Two-level, Hierarchical directory systems</li>
<li>完全路径/相对路径</li>
<li>I-node</li>
</ul>
</li>
<li>文件系统<ul>
<li>MBR：磁盘的扇区0称为MBR（<strong>主引导记录</strong>），MBR的末尾包含分区表（分区表）</li>
<li>Implementing files<ul>
<li>顺序结构</li>
<li>链表结构（指针）</li>
<li>文件分配表FAT(File Allocation Table)【块中存放文件的下一个的地址】</li>
<li>UNIX/Linux 文件元数据metadata被存储在i-node中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h3><ul>
<li><p>I/O硬件原理</p>
<ul>
<li>块设备&amp;字符设备</li>
<li>DMA</li>
</ul>
</li>
<li><p>I/O软件原理</p>
<ul>
<li>目标<ul>
<li>Device independence（设备独立性）</li>
<li>Uniform naming（统一命名）</li>
<li>Error handling</li>
<li>Synchronous（同步） vs. asynchronous（异步） </li>
<li>transfers</li>
<li>Buffering</li>
<li>Sharable（共享） vs. dedicated（独占） devices</li>
</ul>
</li>
<li>三种执行方式<ul>
<li>Programmed I/O<ul>
<li>让<strong>CPU做全部的工作</strong>；CPU通过程序<strong>主动读取状态寄存器</strong>以了解接口情况，并<strong>完成相应的数据操作</strong></li>
</ul>
</li>
<li>Interrupt-driven I/O<ul>
<li>当程序常规运行时，若<strong>外部有优先级更高的事件</strong>出现，则通过<strong>中断请求通知CPU</strong>，<strong>CPU再读取状态寄存器</strong>确定事件的种类，<strong>执行不同的分支处理</strong></li>
</ul>
</li>
<li>I/O using DMA<ul>
<li>直接内存存取，即数据传送的具体过程<strong>直接由硬件（DMA控制器）在内存和I/O之间完成</strong>，<strong>CPU只在开始时将控制权暂时交予DMA</strong>，<strong>直到数据传输结束</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>I/O软件层次</p>
<p><img src="/2018/12/08/操作系统-笔记/分层I:O.png" alt=""></p>
</li>
<li><p>盘</p>
<ul>
<li>寻道时间，旋转延迟，实际数据传输时间</li>
<li>磁盘臂调度算法：（指标）磁盘臂移动总量或寻道时间（seek time）<ul>
<li>First Come First Serve(FCFS)</li>
<li>Shortest Seek First (SSF)</li>
<li>The elevator algorithm</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li><p>资源：可抢占的和不可抢占的</p>
</li>
<li><p>死锁</p>
<ul>
<li><p>死锁的概念</p>
</li>
<li><p>四个条件</p>
<ul>
<li>Mutual exclusion condition互斥使用<ul>
<li>假脱机技术spooling</li>
</ul>
</li>
<li>Hold and wait condition占有且等待<ul>
<li>资源静态分配（在开始的时候就请求全部资源）</li>
</ul>
</li>
<li>No preemption condition不可抢占<ul>
<li>抢占资源</li>
</ul>
</li>
<li>Circular wait condition循环等待<ul>
<li>资源有序分配</li>
</ul>
</li>
</ul>
</li>
<li><p>死锁避免</p>
<ul>
<li><p>安全状态</p>
</li>
<li><p>银行家算法</p>
<p>The banker’s algorithm considers each request as it occurs, and see if granting it leads to a safe state.<br>if it does, the request is granted;<br>otherwise, it is postponed until later.</p>
<ul>
<li>给出系统中的资源总数（Total Available or Exist）、最大资源需求（Maximum Needs）、已分配到的资源（Current Allocation），判断系统是否处于safe state<br>解题步骤<br>calculate the Need matrix<br>search a safe order</li>
<li>某个进程提出新的资源请求，是否应该满足该进程？<br>先满足该进程的请求<br>修改Need矩阵<br>search a safe order</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多处理器系统"><a href="#多处理器系统" class="headerlink" title="多处理器系统"></a>多处理器系统</h3><ul>
<li><p>三种类别</p>
<p><img src="/2018/12/08/操作系统-笔记/多处理器.png" alt=""></p>
<ul>
<li><p>shared-memory multiprocesso内存共享多处理机</p>
<ul>
<li><p>分类</p>
<ul>
<li><p>Separate OS每个CPU有自己的操作系统</p>
</li>
<li><p>Master-Slave 主从多处理机</p>
</li>
<li><p>Symmetric multiprocessor对称多处理机</p>
<p>并行系统包括对称多处理机和非对称多处理机asymmetric multiprocessor</p>
</li>
</ul>
</li>
<li><p>scheduling调度</p>
<ul>
<li>timesharing 分时&amp; space sharing 空间共享&amp; gang scheduling群调度</li>
</ul>
</li>
</ul>
</li>
<li><p>message-passing multicomputer消息传递多计算机</p>
<ul>
<li>interconnect technology</li>
</ul>
</li>
<li><p>wide-area distributed system广域分布式系统</p>
</li>
</ul>
</li>
</ul>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><ul>
<li>三个安全问题<ul>
<li>威胁threats<ul>
<li>Data confidentiality</li>
<li>Data integrity</li>
<li>System availability – denial of  service</li>
<li>privacy</li>
</ul>
</li>
<li>入侵者intruders</li>
<li>数据的意外遗失accidental data loss</li>
</ul>
</li>
<li>保护机制<ul>
<li>域【（对象，权利）对】</li>
<li>ACL访问控制列表（每个对象的）</li>
<li>权能字（每个进程的）</li>
</ul>
</li>
<li>验证Authentication</li>
<li>内部攻击</li>
<li>利用代码漏洞</li>
<li>恶意软件malware</li>
<li>防御</li>
</ul>
<h3 id="UNIX-amp-LINUX常用系统调用"><a href="#UNIX-amp-LINUX常用系统调用" class="headerlink" title="UNIX&amp;LINUX常用系统调用"></a>UNIX&amp;LINUX常用系统调用</h3><ul>
<li>fork &amp; exec: (2.1.2)<ul>
<li>fork: <strong>create two processes,</strong> the parent and the child, have the same memory image, the same environment strings and the same open files</li>
<li>exec: <strong>do not create a new process</strong>，启动另一个程序来执行，一个进程一旦调用exec类函数，它本身就”死亡”了</li>
</ul>
</li>
<li>ps: list the running processes(2.1.2)</li>
<li>cat: concatenates files (2.1.5)</li>
<li>grep: selects lines containing the given word(2.1.5)</li>
<li>chmod: to change the mode of a file(1.6.4)<br>在UNIX/Linux中，每个文件都有一个保护模式。该模式包括针对所有者、组和其他用户的<strong>读-写-执行位</strong><br>r = 4，w = 2，x = 1<br>要是一个文件对除了所有者之外的用户都是只读的，可以自行命令chmod (filename, 744)</li>
</ul>
<h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><h3 id="程序执行流程（Hello-world为例）"><a href="#程序执行流程（Hello-world为例）" class="headerlink" title="程序执行流程（Hello world为例）"></a>程序执行流程（Hello world为例）</h3><ol>
<li>在命令行键入相应的命令 ，<strong>启动程序执行</strong></li>
<li>操作系统<strong>接受用户请求</strong>之后，就会根据用户提供的文件名，到磁盘上找到这个程序的<strong>相关信息</strong>，找到信息之后，会去<strong>检查</strong>这个程序，<strong>是不是一个可执行文件</strong>，若不是，报错；</li>
<li>操作系统会根据程序首部信息，来确定代码和数据在这个可执行文件当中的位置，并<strong>计算</strong>出它<strong>相应的磁盘块地址</strong></li>
<li>为了执行这个helloworld程序，操作系统首先要<strong>创建一个新的进程</strong>，并将helloworld程序的可执行文件格式，<strong>映射到该进程结构</strong> 表示由该进程来执行这个helloworld程序，做完了这件事情，操作系统就把控制权，交给了调度程序</li>
<li>当调度程序选中了helloworld程序，当执行第一条指令的时候，<strong>发生缺页异常</strong>，<strong>硬件机制</strong>就会<strong>捕获出缺页异常</strong>，并且把控制权交给操作系统</li>
<li>操作系统管理了计算机系统中的内存，（以页式存储管理方案为例）内存就有很多的物理页面，操作系统的内存管理模块，就会<strong>分配</strong>一页空闲的<strong>物理内存</strong>，并且根据前面计算出的磁盘块地址，把helloworld程序的代码从磁盘读入内存。继续执行helloworld程序，有的时候程序很大，一页内存还不够，因此在这个执行过程中会多次地产生缺页异常。然后去到磁盘读入程序到内存，这个过程会有多次 </li>
<li>helloworld程序执行puts函数 那么puts函数的作用，是在标准的输出设备上显示字符串，那么这个标准输出设备，通常就是我们的显示器或者说屏幕，它实际上呢是一个系统调用 是由操作系统来完成这个功能 所以控制权又转回到操作系统。操作系统找到要将字符串送到哪一个显示设备，那么通常<strong>设备是由一个进程控制的</strong>，所以操作系统把要写的字符串实际上是送给了这个进程，那么控制设备的进程，会告诉设备的窗口系统，它要显示字符串，窗口系统确定这是一个合法的操作，然后将字符串转换为像素，把像素写入设备的存储映像区，视频硬件将像素，转换成显示器可以接收的一组控制信号或数据信号，显示器再去解释这个信号，激发液晶屏 </li>
</ol>
<h3 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h3><p>是一个<strong>系统软件</strong>，是一些程序模块的集合</p>
<p>计算机系统由<strong>硬件和软件（系统程序+应用程序）</strong>组成</p>
<p>操作系统是<strong>控制</strong>计算机<strong>整体操作</strong>的<strong>软件</strong></p>
<p>是介于用户和计算机硬件之间的程序；其目的是为了让用户方便执行程序，提高易用性，更高效地操作硬件</p>
<ul>
<li>以尽量<strong>有效、合理</strong>的方式<strong>组织和管理</strong>计算机的软硬件资源<ul>
<li>有效：系统效率、资源利用率</li>
<li>合理：软硬件资源的公平合理</li>
</ul>
</li>
<li>合理地组织计算机的工作流程，控制程序的执行，并向用户<strong>提供</strong>各种<strong>服务功能</strong></li>
<li>使用户能够灵活、<strong>方便</strong>地使用计算机，使整个计算机系统<strong>高效率运行</strong><ul>
<li>方便：用户界面与编程接口</li>
</ul>
</li>
</ul>
<p>系统接口或shell =用户和计算机之间的接口</p>
<ul>
<li>命令行界面（CLI）<br>Linux，UNIX，DOS，旧操作系统</li>
<li>图形用户界面（GUI）</li>
</ul>
<h3 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h3><p><strong>操作系统是资源的管理者，对硬件系统的扩展，为用户提供服务</strong></p>
<ul>
<li><p>操作系统是<strong>资源的管理者</strong>：</p>
<ul>
<li>硬件：CPU、内存、设备</li>
<li>软件：文件</li>
<li>五大基本功能：<ul>
<li>进程/线程管理（CPU管理）<ul>
<li>进程线程状态、控制、同步互斥、通信、调度</li>
</ul>
</li>
<li>存储管理<ul>
<li>分配/回收、地址转换、存储保护、内存扩充</li>
</ul>
</li>
<li>文件管理<ul>
<li>文件目录、文件操作、磁盘空间、文件存取控制</li>
</ul>
</li>
<li>设备管理<ul>
<li>设备驱动、分配回收、缓冲技术</li>
</ul>
</li>
<li>用户接口<ul>
<li>系统命令、编程接口</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>操作系统<strong>为用户提供服务</strong></p>
</li>
<li><p>操作系统是<strong>对硬件系统的扩展</strong></p>
</li>
</ul>
<h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3><p><strong>并发性、共享性、虚拟性、不确定性</strong></p>
<ul>
<li>并发<ul>
<li>并发的关键是你有处理多个任务的能力，<strong>不一定要同时。</strong></li>
<li>并发性是指若干程序在<strong>同一时间间隔内</strong>执行</li>
<li>与并行相似，并行多指不同程序同时在<strong>多个硬件部件</strong>上执行</li>
<li>并发环境：一段时间间隔内，单处理器上有两个或两个以上的程序<strong>同时处于开始运行但尚未结束的状态</strong>，<strong>并且次序不是事先确定的</strong></li>
</ul>
</li>
<li>共享</li>
<li>虚拟<ul>
<li>一个物理实体映射为若干个对应的逻辑实体——分时或分空间</li>
<li>可以提高资源利用率</li>
</ul>
</li>
<li>随机（对<strong>不可预测</strong>的次序发生的事件进行响应并处理</li>
</ul>
<h3 id="操作系统的架构"><a href="#操作系统的架构" class="headerlink" title="操作系统的架构"></a>操作系统的架构</h3><ul>
<li>用户态</li>
<li>内核态</li>
</ul>
<p><img src="/2018/12/08/操作系统-笔记/操作系统架构.png" alt=""></p>
<h3 id="操作系统的分类"><a href="#操作系统的分类" class="headerlink" title="操作系统的分类"></a>操作系统的分类</h3><ul>
<li>批处理操作系统<ul>
<li><strong>提高资源利用率，提高吞吐量</strong></li>
<li>单道批处理操作系统，一个一个完成</li>
<li>多道批处理操作系统</li>
<li>spooling技术，假脱机技术，用磁盘作缓冲，将输入、计算、输出分别组织成独立的任务流，在一台计算机上运行【现代打印机还用这个技术】不需要独占设备</li>
<li>SPOOLing技术是一种<strong>用磁盘空间换取时间</strong>的技术</li>
<li>作业的输入输出工作通常由SPOOLing系统完成</li>
<li>批处理系统常采用SPOOLing技术实现</li>
</ul>
</li>
<li>分时操作系统（<strong>交互式</strong>系统）<ul>
<li>操作系统以<strong>时间片</strong>为单位，轮流为每个终端用户服务，每次服务一个时间片</li>
<li>两者结合时，前台用分时，后台用批处理</li>
</ul>
</li>
<li>实时操作系统<ul>
<li><strong>及时</strong>响应外部事件的请求</li>
<li>对外部请求在<strong>严格时间范围内</strong>作出响应</li>
<li>高可靠性</li>
<li>硬实时系统/软实时系统</li>
</ul>
</li>
<li>个人计算机操作系统<ul>
<li>界面友好，方便使用</li>
</ul>
</li>
<li>网络操作系统</li>
<li>分布式操作系统<ul>
<li>分布式系统是指把<strong>多个处理机</strong>通过<strong>线路互联</strong>而构成的系统，此系统的<strong>处理和控制</strong>分布在各个处理机上</li>
<li>主要特点：<strong>分布性，自治性，模块性，并行性</strong></li>
<li>处理分布在不同计算机上</li>
<li>处理能力增加，速度变快等等</li>
<li>功能：进程迁移，分布式进程同步，任务分配，资源管理</li>
</ul>
</li>
<li>嵌入式操作系统<ul>
<li><strong>反应式或对处理时间</strong>有较严格要求的环境中</li>
<li>汽车电子系统</li>
</ul>
</li>
</ul>
<h2 id="运行环境和运行机制"><a href="#运行环境和运行机制" class="headerlink" title="运行环境和运行机制"></a>运行环境和运行机制</h2><h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><h4 id="CPU状态"><a href="#CPU状态" class="headerlink" title="CPU状态"></a>CPU状态</h4><p>中央处理器（CPU）</p>
<p>CPU由运算器、控制器、一系列的寄存器以及高速缓存构成</p>
<h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><h4 id="中断-异常"><a href="#中断-异常" class="headerlink" title="中断/异常"></a>中断/异常</h4><p>CPU暂停正在执行的程序，保留现场后自动转去执行相应事件的处理程序，处理完成后返回断点，继续执行被打断的程序</p>
<p><strong>中断：</strong>为了支持CPU和设备之间的并行操作（<strong>外部的</strong>打扰</p>
<ul>
<li>I/O中断(eg.ctrl+c)</li>
<li>时钟中断(eg.时间片用完了)</li>
<li>硬件故障</li>
</ul>
<p><strong>异常：</strong>表示CPU执行指令时<strong>本身</strong>出现的问题</p>
<p>分为三类：Trap陷入（有意识安排、故障Fault（可恢复的错误、终止Abort（不可恢复的错误</p>
<p>种类：</p>
<ul>
<li><p>系统调用：特殊的异常</p>
<p>操作系统的主要功能是为应用程序的运行创建良好的环境，为了达到这个目的，内核提供一系列具备预定功能的多内核函数，通过一组称为系统调用的接口呈现给用户。系统调用把应用程序的请求传给内核，调用相应的内核函数完成所需的处理，将处理结果返回给应用程序。如果没有系统调用和内核函数，用户将不能编写大型应用程序</p>
<ul>
<li>使CPU状态<strong>从用户态陷入内核态</strong></li>
<li>系统调用时调用程序位于用户态，被调用程序位于内核态</li>
<li>应用程序可以直接调用系统调用，但一般通过库函数/API接口进行系统调用（存在一些库函数/API接口不执行系统调用，而是完成一些特定的功能）；内核函数一部分可以用来系统调用，还有一大部分是隐藏的，没有给编程人员提供外部接口</li>
<li>有用于进程管理，文件管理，目录管理的系统调用</li>
</ul>
</li>
<li><p>页故障/页错误</p>
</li>
<li><p>保护性异常</p>
</li>
<li><p>断点指令</p>
</li>
<li><p>其他程序性异常</p>
</li>
</ul>
<p>硬件——响应</p>
<ol>
<li>捕获中断源发出的中断/异常请求</li>
<li>以一定的方式响应</li>
<li>将处理器控制权交给特定的处理程序</li>
</ol>
<p>软件——程序处理</p>
<ol>
<li>识别中断/异常类型并完成相应的处理</li>
</ol>
<p><strong>中断向量表</strong></p>
<p>存放<strong>中断处理程序入口地址</strong>和程序运行时所需的<strong>处理机状态字</strong></p>
<p><strong>中断流程：（以I/O中断为例）</strong></p>
<ol>
<li><p>给CPU<strong>发中断信号</strong></p>
</li>
<li><p>CPU处理完当前指令后<strong>检测到中断</strong>，判断中断来源并向相关设备发<strong>确认信号</strong></p>
</li>
<li><p>CPU开始为软件处理中断<strong>做准备</strong></p>
<ol>
<li>处理器状态被<strong>切换到内核态</strong></li>
<li>在系统栈中<strong>保存</strong>被中断程序的重要<strong>上下文环境</strong>，主要是程序计数器PC、程序状态字PSW</li>
</ol>
</li>
<li><p>CPU根据中断码<strong>查中断向量表</strong>，<strong>获得</strong>与该中断相关的<strong>处理程序的入口地址</strong>（这一段具体过程见注），并将<strong>PC设置成该地址</strong>，新的指令周期开始时，CPU<strong>控制转移</strong>到中断处理程序（硬件）</p>
</li>
<li><p>中断处理程序开始工作（软件）</p>
<ol>
<li>在系统栈中<strong>保存现场信息</strong></li>
<li>检查I/O设备的状态信息，操纵I/O设备或者在设备和内存之间传送数据等等</li>
</ol>
<p>若执行失败，会多次执行，看是否是偶然错误</p>
</li>
<li><p>中断处理结束，CPU<strong>检测到中断返回指令</strong>，从系统栈中<strong>恢复</strong>被中断程序的上下文环境，CPU状态恢复成原来的状态，PSW和PC恢复成中断前的值，CPU开始一个新的指令周期</p>
</li>
</ol>
<p><strong>注</strong> 中断向量号+IDTR <code>-&gt;</code>（在IDT）中查找中断描述符（得到段选择符和偏移量） <code>-&gt;</code>  段选择符 + GDTR <code>-&gt;</code> （在GDT）中查找段描述符，得到段基址 <code>-&gt;</code> 段基址+偏移量（在内存）中找到中断处理程序【其中R是register寄存器的缩写】</p>
<p><strong>补：</strong>R0特权级最高，R3用户级</p>
<h3 id="Quiz2-错题"><a href="#Quiz2-错题" class="headerlink" title="Quiz2 错题"></a>Quiz2 错题</h3><p>11题应该选择456</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz2.1.png" alt=""></p>
<p><img src="/2018/12/08/操作系统-笔记/quiz2.2.png" alt=""></p>
<ol>
<li>系统调用的功能是由内核函数实现的。正确。</li>
</ol>
<h2 id="进程-线程"><a href="#进程-线程" class="headerlink" title="进程/线程"></a>进程/线程</h2><p>进程的两个基本属性：</p>
<ul>
<li><strong>资源</strong>的拥有者：进程还是资源的拥有者</li>
<li><strong>CPU调度单位</strong>：线程继承了这一属性</li>
</ul>
<h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h3><p>允许多个程序<strong>同时</strong>进入内存并运行，目的是为了提高系统效率</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程具有并发性、动态性、独立性（<strong>资源分配的独立单元</strong>）、交互性、异步性</p>
<p>具有独立功能的<strong>程序</strong>关于某个<strong>数据集合</strong>上的<strong>一次运行</strong>活动，是系统进行资源分配和调度的独立单位</p>
<p><strong>包括程序计数器，寄存器和变量的当前值</strong></p>
<p>进程有<strong>数据段、程序段和PCB组成</strong></p>
<p><strong>注：</strong></p>
<ul>
<li>一个程序运行两次就是两个进程</li>
<li>系统资源以进程为单位分配，每个具有<strong>独立的地址空间</strong></li>
<li>查看系统正在运行的程序<code>PS</code></li>
</ul>
<h4 id="进程的管理"><a href="#进程的管理" class="headerlink" title="进程的管理"></a>进程的管理</h4><p><strong>PCB：进程控制块</strong>，是一个数据结构；通常被装载在RAM中</p>
<p>分为PROC结构和USER结构</p>
<p>包含有：</p>
<ul>
<li>进程描述信息<ul>
<li>进程标识符（process ID）唯一的，通常是一个整数</li>
<li>进程名，不唯一</li>
<li>用户标识符（user ID）</li>
<li>进程组关系</li>
</ul>
</li>
<li>进程控制信息<ul>
<li>当前状态</li>
<li>优先级</li>
<li>代码执行入口地址</li>
<li>程序的磁盘地址</li>
<li>运行统计信息（执行时间、页面调度）</li>
<li>进程间同步和通信</li>
<li>进程的队列指针</li>
<li>进程的消息队列指针</li>
</ul>
</li>
<li>所拥有的资源和使用情况<ul>
<li>虚拟地址空间的状况</li>
<li>打开文件列表</li>
</ul>
</li>
<li>CPU现场信息（当进程不运行的时候，操作系统需要保存）<ul>
<li>寄存器值</li>
<li>指向该进程页表的指针</li>
</ul>
</li>
</ul>
<p><strong>注：</strong></p>
<ul>
<li><p>进程与PCB一一对应</p>
</li>
<li><p>进程表：所有进程的PCB集合</p>
</li>
</ul>
<h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><p>三/五/七状态模型</p>
<ul>
<li>运行态：该时刻进程实际占用CPU<ul>
<li>运行态<code>-&gt;</code>就绪态：用完了时间片/高优先级进程进入就绪态</li>
<li>运行态<code>-&gt;</code>等待态：请求OS服务/资源访问尚不能进行/等待I/O结果/等待另一个进程提供信息/……</li>
</ul>
</li>
<li>就绪态：可运行，但因为其他进程正在运行而暂时停止<ul>
<li>就绪态<code>-&gt;</code>运行态：调度程序选择一个新的进程运行</li>
</ul>
</li>
<li>等待态/阻塞态/封锁态/睡眠态：除非某种外部事件发生，否则进程不能运行<ul>
<li>等待态<code>-&gt;</code>就绪态：所等待的事件发生了</li>
</ul>
</li>
<li>其他状态<ul>
<li>创建（资源有限，未同意执行该进程）</li>
<li>终止</li>
<li>挂起：调节负载，不占用内存空间（阻塞挂起/就绪挂起）</li>
</ul>
</li>
</ul>
<p><img src="/2018/12/08/操作系统-笔记/进程的状态.png" alt=""></p>
<p>1：是由于<strong>I/O请求</strong>引起</p>
<p>2：<strong>时间片</strong>用完引起</p>
<p>3：由于<strong>调度程序的调度</strong>引起</p>
<p>4：由于<strong>I/O完成</strong>引起</p>
<p><img src="/2018/12/08/操作系统-笔记/进程的状态2.png" alt=""></p>
<p><strong>进程的创建：</strong></p>
<ul>
<li>系统初始化</li>
<li>正在运行的程序执行了创建进程的系统调用</li>
<li>用户请求创建一个新进程</li>
<li>一个批处理作业的初始化</li>
</ul>
<p><strong>进程的终止：</strong></p>
<ul>
<li>正常退出（自愿的）</li>
<li>出错退出（自愿的）</li>
<li>严重错误（非自愿）</li>
<li>被其他进程杀死（非自愿）</li>
</ul>
<p><strong>进程队列</strong>：为<strong>每一类</strong>进程创建一个或多个队列，队列元素PCB</p>
<ul>
<li><p>单CPU下，运行队列中只有一个进程</p>
</li>
<li><p>就绪/等待队列可以有多个</p>
</li>
</ul>
<h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><p><strong>不允许中断（因此称为原语）</strong>，以系统调用作为接口给用户使用</p>
<ul>
<li>进程的创建<code>fork()</code>【通过复制进程，例如在创建子进程的时候】and<code>exec()</code>【用一段新的程序代码覆盖原来的空间，执行代码的转换】<ul>
<li>给新进程分配一个<strong>唯一标识</strong>以及<strong>进程控制块</strong></li>
<li>为进程分配<strong>地址空间</strong></li>
<li><strong>初始化</strong>进程控制块</li>
<li>设置相应的<strong>队列指针</strong></li>
<li>创建进程的事件<ul>
<li>系统初始化</li>
<li>执行创建进程的系统的调用</li>
<li>用户请求创建新进程</li>
<li>初始化一个批处理作业</li>
</ul>
</li>
</ul>
</li>
<li>进程的撤销<code>exit()</code><ul>
<li>收回进程所占有的资源</li>
<li>撤销该进程的PCB</li>
</ul>
</li>
<li>进程阻塞（由进程自己执行阻塞原语<code>wait()</code>）</li>
<li>进程的结束<ul>
<li>Normal exit (voluntary（自愿的）)</li>
<li>Error exit (voluntary)</li>
<li>Fatal error (involuntary（非自愿的）)</li>
<li>Killed by another process (involuntary)</li>
</ul>
</li>
</ul>
<p><code>fork()</code></p>
<p>进程执行是先父进程开始按照代码结构完整执行一遍，其余结点按照前序遍历进程树来从它生成的代码处，执行剩下的代码。(可以见文件夹中的<code>fork_.c</code>测试文件)</p>
<ol>
<li>为子进程<strong>分配</strong>一个空闲的<strong>进程描述符</strong>（proc结构）</li>
<li>分配给子进程<strong>唯一标识pid</strong></li>
<li>以<strong>一次一页</strong>的方式<strong>复制</strong>父进程<strong>地址空间</strong></li>
<li>从父进程处<strong>继承共享资源</strong>，如打开的文件和工作目录等</li>
<li>将子进程的状态设为就绪，<strong>插入</strong>到<strong>就绪队列</strong></li>
<li>对子进程返回标识符<strong>0</strong>，但是父进程的标识符还是没有改变</li>
<li>向父进程返回子进程的<strong>pid </strong></li>
</ol>
<h4 id="进程的分类"><a href="#进程的分类" class="headerlink" title="进程的分类"></a>进程的分类</h4><ul>
<li>系统进程</li>
<li>用户进程</li>
</ul>
<ul>
<li>前台进程</li>
<li>后台进程</li>
</ul>
<ul>
<li>CPU密集型进程</li>
<li>I/O密集型进程<ul>
<li>一般的调度程序，会先进行I/O密集型进程，占用短时CPU之后，就释放，开始进行I/O操作</li>
</ul>
</li>
</ul>
<ul>
<li>可抢占式<ul>
<li>当有比正在运行的进程<strong>优先级更高的进程</strong>就绪时，系统可强行剥夺正在运行进程的CPU，提供给具有更高优先级的进程使用</li>
</ul>
</li>
<li>不可抢占式<ul>
<li>某一进程被调度运行后，除非由于它<strong>自身的原因不能运行</strong>，否则一直运行下去</li>
</ul>
</li>
</ul>
<p>进程的层次结构，进程家族树，init为根</p>
<h4 id="进程和程序"><a href="#进程和程序" class="headerlink" title="进程和程序"></a>进程和程序</h4><p>进程是程序的一次执行</p>
<ul>
<li>进程更能准确刻画并发，而程序不能</li>
<li>程序是静态的，进程是<strong>动态</strong>的</li>
<li>进程是有<strong>生命周期</strong>的，有诞生有消亡，是短暂的；而程序是相对长久的</li>
<li>一个程序可对应多个进程</li>
<li>进程具有创建其他进程的功能</li>
</ul>
<p><strong>注：</strong></p>
<p>进程之间的地址空间是隔离的，他们的内存地址不是实际的物理地址，而是虚拟地址，给的是相对地址，所以我们用<code>&amp;</code>得到的不是实际的物理地址空间，所以两个进程的变量可能具有相同的地址</p>
<p><strong>进程映像</strong>（IMAGE）= 程序+数据+栈（用户栈、内核栈）+PCB</p>
<p>对进程执行活动全过程的静态描述</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>进程中的一个运行实体，是<strong>CPU的调度单位</strong>，又称为轻量级进程</p>
<p>线程：也叫<strong>轻量级的进程</strong>，它是一个基于进程的运行单位，它可以不占有资源，<strong>一个进程可以有一个线程或者多个线程（至少一个）</strong>，这些<strong>线程共享此进程的代码、数据和部分管理信息</strong>，但是<strong>每个线程都有它自己的PC、STACK、寄存器和其他</strong></p>
<p>进程和线程的区别：</p>
<ul>
<li><strong>地址空间和资源不同</strong>：<strong>进程间相互独立；同一进程的各个线程之间共享</strong></li>
<li><strong>通信不同：</strong>进程间可以使用<strong>IPC（Inter-Process Communication）通信</strong>，线程之间可以<strong>直接读写进程数据段来进行通信；</strong>但是需要进程同步和互斥手段的辅助，以保持数据的一致性</li>
<li><strong>调度和切换不同：</strong>线程的<strong>上下文切换</strong>比进程上下文的切换要快的多</li>
</ul>
<p>产生的原因：</p>
<ul>
<li><p><strong>应用的需要</strong>（web服务器性能会提高；对文档第一页的修改，后续的跟进工作</p>
<p>| 模型       | 特性                                       |<br>| ————— | ————————————————————— |<br>| 多线程     | 有并发、阻塞系统调用                       |<br>| 单线程进程 | 无并发、阻塞系统调用                       |<br>| 有限状态机 | 有并发、非阻塞系统调用、中断【但是很复杂】 |</p>
</li>
<li><p>开销的考虑（线程的开销小，<strong>创建和切换</strong>线程的开销小，同时线程之间<strong>通信</strong>不需要开销</p>
</li>
<li><p><strong>性能</strong>的考虑</p>
</li>
</ul>
<h4 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h4><ul>
<li>标识符ID</li>
<li>状态和状态转换</li>
<li>不运行时需要保存上下文环境</li>
<li>线程可以被独立调度，有自己的堆栈和栈指针</li>
<li><strong>共享所在进程的地址空间和其他资源</strong>（所以通信很方便</li>
<li>可以创建、撤销另一个线程</li>
<li>程序开始是以一个单线程进程方式运行的</li>
</ul>
<p>左边是所有线程共有的，后者为每个线程独有的</p>
<p><img src="/2018/12/08/操作系统-笔记/线程.png" alt=""></p>
<p>程序计数/寄存器/栈/状态</p>
<p>地址空间/全局变量/打开文件的清单/子进程/突出的警报/信号和信号处理/会计信息</p>
<h4 id="线程机制的实现"><a href="#线程机制的实现" class="headerlink" title="线程机制的实现"></a>线程机制的实现</h4><p><img src="/2018/12/08/操作系统-笔记/用户空间和内核级线程.png" alt=""></p>
<h5 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h5><ul>
<li><p>内核管理的还是进程，不知道线程的存在</p>
</li>
<li><p>线程切换不需要内核态特权</p>
</li>
<li>在用户空间建立线程库，提供一组管理线程的过程</li>
<li>运行时系统：线程表，完成线程的管理工作</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li><strong>线程切换快</strong>，有较好的伸缩性</li>
<li>调度算法是应用程序特定的，允许每个进程有自己<strong>定制的调度算法</strong></li>
<li>用户级线程<strong>可运行在任何操作系统上</strong>，甚至可以在不支持线程的操作系统上实现（只需要实现线程库</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>内核只将处理器分配给进程，同一进程中的两个线程不能同时运行于两个处理器上，<strong>即同一进程的两个线程不可以同时运行</strong></li>
<li>大多数系统调用是阻塞的，因此，由于内核阻塞进程，故进程中<strong>所有线程也被阻塞</strong>（解决方法：Jacketing/wrapper</li>
</ul>
<h5 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h5><ul>
<li><p>内核管理<strong>所有线程管理</strong>，并向应用程序提供API接口</p>
</li>
<li><p>内核维护<strong>进程和线程</strong>的上下文</p>
</li>
<li><p>线程的<strong>切换需要内核的支持</strong>（进行系统调用，通过对线程表的更新完成线程创建和撤销工作）</p>
</li>
<li><p>以<strong>线程为基础进</strong>行调度</p>
</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>对多处理器，内核可以<strong>同时调度同一进程的多个线程</strong></li>
<li><strong>阻塞在线程一级完成</strong></li>
</ul>
<p>缺点：</p>
<ul>
<li>在同一进程内的线程<strong>切换调用</strong>内核，<strong>开销大</strong>，导致<strong>速度下降</strong></li>
</ul>
<h5 id="用户级线程与内核级线程"><a href="#用户级线程与内核级线程" class="headerlink" title="用户级线程与内核级线程"></a>用户级线程与内核级线程</h5><p>用户级线程和内核级线程之间的差别在于<strong>性能</strong></p>
<ul>
<li>用户级线程的线程切换只需要少量的机器指令</li>
<li>内核级线程的线程切换需要完成的上下文切换，导致了若干数量级的延迟</li>
<li>使用内核级线程时，线程的阻塞不会将整个进程阻塞</li>
<li>从进程A的一个线程切换到进程B的一个线程，其代价高于运行进程A的第2个线程</li>
<li>用户级线程可以使用专为应用定制的线程调度程序</li>
</ul>
<h5 id="混合级线程"><a href="#混合级线程" class="headerlink" title="混合级线程"></a>混合级线程</h5><ul>
<li>线程创建在用户空间完成</li>
<li>多个用户级线程<strong>多路复用</strong>多个内核级线程</li>
<li>线程调度等在核心态完成</li>
<li>每个内核级线程有一个可以轮流使用的用户级线程集合</li>
</ul>
<h5 id="Pthread的线程操作"><a href="#Pthread的线程操作" class="headerlink" title="Pthread的线程操作"></a>Pthread的线程操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Pthread_create();</div><div class="line">Pthread_exit();</div><div class="line">Pthread_join();</div><div class="line">Pthread_yield(); <span class="comment">//自愿让出CPU</span></div><div class="line">Pthread_attr_init();</div><div class="line">Pthread_attr_destroy();</div></pre></td></tr></table></figure>
<h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><p><strong>条件：</strong></p>
<ul>
<li>线程正常终止 或 由于某种错误而终止</li>
<li>新线程创建 或 一个等待线程变成就绪</li>
<li>当一个线程从运行态进入阻塞态</li>
<li>当一个线程从运行态变为就绪态</li>
</ul>
<p><strong>其他：</strong></p>
<p>可再入程序（重入）可被多个进程同时调用的程序</p>
<h3 id="Quiz3错题"><a href="#Quiz3错题" class="headerlink" title="Quiz3错题"></a>Quiz3错题</h3><p>4 死循环的时候，互相依赖</p>
<p>5 还有撤销该进程的PCB</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz3.1.png" alt=""></p>
<ol>
<li>CPU切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态，所以可以中断</li>
</ol>
<p><img src="/2018/12/08/操作系统-笔记/quiz3.2.png" alt="quiz3.2"></p>
<ol>
<li>正确的是1234</li>
<li>进程运行时，其硬件状态保存在CPU的寄存器中；进程不运行时，这些寄存器的值保存到<strong>进程控制块PCB</strong>中</li>
</ol>
<p><img src="/2018/12/08/操作系统-笔记/quiz3.3.png" alt="quiz3.3"></p>
<ol>
<li>应该是阻塞原语</li>
</ol>
<p><img src="/2018/12/08/操作系统-笔记/quiz3.5.png" alt=""></p>
<ol>
<li>一个进程中的所有线程共享该进程的地址空间，但它们有各自独立的栈，而<strong>堆</strong>才为本进程中所有线程共享。</li>
</ol>
<p><img src="/2018/12/08/操作系统-笔记/quiz3.4.png" alt="quiz3.4"></p>
<h2 id="处理器调度"><a href="#处理器调度" class="headerlink" title="处理器调度"></a>处理器调度</h2><p>其任务是控制、协调进程对CPU的竞争</p>
<p>即按一定的调度算法从就绪队列中选择一个进程，把CPU的使用权（控制权）交给被选中的进程；如果没有就绪进程，系统会安排一个系统空闲进程</p>
<p>决策三个方面：</p>
<ul>
<li>What 选择下一个运行的进程</li>
<li>When 何时选择，调度时机</li>
<li>How 如何让选中的进程在CPU上运行，即进程的上下文切换</li>
</ul>
<p>CPU调度时机</p>
<p>内核对中断/异常/系统调用处理后<strong>返回到用户态后</strong></p>
<ul>
<li>进程正常<strong>终止</strong> 或 由于某种错误而终止</li>
<li>新进程<strong>创建</strong> 或 一个等待进程变成就绪</li>
<li>当一个进程从运行态进入<strong>阻塞</strong>态</li>
<li>当一个进程从运行态变为就绪态</li>
<li>当发生<strong>I/O中断</strong>时</li>
<li>当<strong>硬件时钟中断</strong>时</li>
</ul>
<p>进程切换：是指一个进程让出CPU，由另一个进程占用处理器的过程</p>
<ul>
<li>切换全局页目录以加载一个新的地址空间</li>
<li>切换内核栈和硬件上下文，其中硬件上下文包括了内核执行新进程需要的全部信息，如CPU相关寄存器</li>
</ul>
<p>切换过程包括了对原来运行进程各种状态的保存和对新进程各种状态的恢复</p>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>CPU硬件状态从一个进程换到另一个进程的过程</p>
<h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><ol>
<li>保存进程A的上下文环境（程序计数器、程序状态字、其他寄存器等）</li>
<li>用新状态和其他相关信息更新进程A的PCB</li>
<li>把进程A移至合适的队列（就绪、阻塞……）</li>
<li>把进程B的状态设置为运行态</li>
<li>从进程B的PCB中恢复上下文环境（程序计数器、程序状态字、其他寄存器等）</li>
</ol>
<h4 id="开销"><a href="#开销" class="headerlink" title="开销"></a>开销</h4><p>直接开销：内核完成切换所用的CPU时间（保存和恢复寄存器、切换地址空间）</p>
<p>间接开销（高速缓存Cache、缓冲区缓存Buffer Cache和TLB [Translation Lookup/lookaside Buffer]【转换检测缓冲区】失效）</p>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>当计算机是多程序设计时，只要两个或多个进程同时处于就绪状态，它就经常有多个进程同时竞争CPU<br>进行<strong>选择</strong>的操作系统部分称为<strong>调度程序（scheduler）</strong>，它使用的算法称为<strong>调度算法（scheduling algorithm）</strong></p>
<p>调度算法根据对时钟中断的处理，分为两种形式：</p>
<ul>
<li>非抢占式（nonpreemptive）调度算法：挑选一个进程，让该进程<strong>运行直至被阻塞</strong>，或者<strong>直到该进程自动释放CPU</strong></li>
<li>抢占式（preemptive）调度算法：挑选一个进程，并让该进程运行<strong>某个固定时段的最大值</strong>；如果在该时段结束时，进程仍然运行，它就被<strong>挂起</strong>，而调度程序挑选另一个进程运行</li>
</ul>
<p>考虑的方面：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>用户角度</th>
<th>系统角度</th>
</tr>
</thead>
<tbody>
<tr>
<td>性能</td>
<td>周转时间<br>响应时间<br>最后期限</td>
<td>吞吐量<br>CPU利用率</td>
</tr>
<tr>
<td>其他</td>
<td>可预测性<br>均衡性</td>
<td>公平性<br>强制优先级<br>平衡资源</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>CPU utilization（CPU利用率）：CPU利用率 = 1- p^n<ul>
<li>n个进程</li>
<li>每个等待I/O的时间与停留在内存中的时间之比为p      </li>
</ul>
</li>
<li>Throughput（吞吐率）：the number of jobs per hour that the system completes.</li>
<li>Average turnaround time（平均周转时间）：the statistically <strong>average time</strong> from the moment that a batch job is <strong>submitted</strong> until the moment it is <strong>completed</strong><ul>
<li>$T=\frac{1}{n}\displaystyle\sum^{n}_{i=1}(T_{oi}-T_{si})$</li>
<li>其中，$T_{oi}$完成时间，$T_{si}$提交时间</li>
</ul>
</li>
</ul>
<h4 id="衡量指标"><a href="#衡量指标" class="headerlink" title="衡量指标"></a>衡量指标</h4><p>吞吐量：每单位完成的进程数目</p>
<p>周转时间TT：每个进程从提出请求到运行完成的时间</p>
<p>响应时间RT：从提出请求到第一次回应的时间</p>
<p>CPU利用率：CPU做有效工作的时间比例</p>
<p>等待时间：每个进程在就绪队列等待的时间</p>
<h4 id="批处理系统的调度算法"><a href="#批处理系统的调度算法" class="headerlink" title="批处理系统的调度算法"></a>批处理系统的调度算法</h4><p>处理系统，通常会<strong>提交的进程多于可以立即执行的进程数</strong>，因此传入的进程被<strong>假脱机</strong>（到磁盘）</p>
<ul>
<li><strong>长期调度程序</strong>从此<strong>进程池</strong>中选择进程并将所选进程加载到<strong>内存</strong>中以供执行（<strong>作业调度</strong>）【哪个程序<strong>被系统选中</strong>并<strong>创建进程运行</strong>它】</li>
<li><strong>中期调度程序</strong>可以将这些过程重新引入内存（<strong>内存调度</strong>），此操作也称为<strong>交换（对换）</strong>，交换是改善过程组合或释放内存所必需的【决定是否将进程调入内存】</li>
<li><strong>短期调度程序</strong>选择从已经在<strong>内存</strong>中的进程中获取处理器的进程（<strong>CPU调度</strong>）【哪个进程获得<strong>处理器资源</strong>（通常所说的调度）】</li>
</ul>
<h5 id="先来先服务FCFS"><a href="#先来先服务FCFS" class="headerlink" title="先来先服务FCFS"></a>先来先服务FCFS</h5><p>Fist Come First Server</p>
<p>先进先出，按照进程就绪的先后顺序使用CPU</p>
<p>非抢占式</p>
<p><strong>特点：</strong></p>
<ul>
<li>公平</li>
<li>易于理解，实现简单</li>
<li>CPU利用率低</li>
<li>长时间后面的短进程需要等待较长的时间，用户的体验不好</li>
</ul>
<h5 id="最短作业优先-SJF"><a href="#最短作业优先-SJF" class="headerlink" title="最短作业优先 SJF"></a>最短作业优先 SJF</h5><p>Short Job First</p>
<p>具有最短完成时间的进程优先执行</p>
<p>非抢占式</p>
<p>缺点：</p>
<ul>
<li>必须<strong>预知</strong>作业的运行时间</li>
<li>可能造成先期到达的<strong>长作业过长的等待</strong></li>
</ul>
<h6 id="最短剩余时间优先-SRTN"><a href="#最短剩余时间优先-SRTN" class="headerlink" title="最短剩余时间优先 SRTN"></a>最短剩余时间优先 SRTN</h6><p>Shortest Remaining Time Next</p>
<p><strong>SJF抢占式版本，</strong>即当一个新就绪的进程比当前运行进程具有更短的完成时间时，系统抢占当前进程，选择新就绪的进程执行</p>
<p><strong>特点：</strong></p>
<ul>
<li><strong>最短的平均周转时间</strong>（在所有进程同时可运行时</li>
<li>必须<strong>预知</strong>作业的运行时间</li>
<li>不公平（当源源不断的短任务到来，可能使长的任务长时间得不到运行，产生<strong>“饥饿”</strong>现象）</li>
</ul>
<h5 id="最高响应比优先HRRN"><a href="#最高响应比优先HRRN" class="headerlink" title="#最高响应比优先HRRN"></a>#最高响应比优先HRRN</h5><p>Highest Response Ratio Next</p>
<p>是一个综合的算法，<strong>折衷处理</strong>（FCFS和SJF的折衷），既考虑了作业到达的时间，又考虑了作业的长短</p>
<p>调度时，首先计算每个进程的响应比R；之后总是选择R最高的进程执行</p>
<p>响应比R=周转时间/处理时间=（<strong>处理时间+等待时间</strong>）/处理时间=1+（等待时间/处理时间）</p>
<h4 id="交互式系统的调度算法"><a href="#交互式系统的调度算法" class="headerlink" title="交互式系统的调度算法"></a>交互式系统的调度算法</h4><p>强调响应时间公平、平衡</p>
<h5 id="时间片轮转调度RR"><a href="#时间片轮转调度RR" class="headerlink" title="时间片轮转调度RR"></a>时间片轮转调度RR</h5><p>Round Robin</p>
<p><strong>时间片</strong></p>
<p>一个时间段，分配给调度上CPU的进程，确定了允许该进程运行的时间长度</p>
<p>考虑：进程切换的开销，对响应时间的要求，就绪进程个数，CPU能力，进程的行为</p>
<p>时间片太长：降级为先来先服务算法，延长短进程的响应时间</p>
<p>时间片太短：进程切换浪费CPU时间</p>
<p>20-50毫秒是一个折中的好选择</p>
<p><strong>目标：</strong></p>
<p>为<strong>短任务</strong>改善平均响应时间</p>
<p><strong>解决问题的思路：</strong></p>
<ol>
<li>周期性切换</li>
<li>每个进程分配一个时间片</li>
<li>时钟中断-&gt;轮换</li>
</ol>
<p><strong>特点：</strong></p>
<ul>
<li>公平</li>
<li>有利于交互式计算，响应时间快</li>
<li>由于进程切换，时间片轮转算法要花费较高的开销</li>
<li>RR对不同大小的进程是有利的，<strong>但是对于相同大小的进程，比FCFS平均响应时间还要长</strong></li>
</ul>
<h6 id="虚拟轮转法-Virtual-RR"><a href="#虚拟轮转法-Virtual-RR" class="headerlink" title="#虚拟轮转法 Virtual RR"></a>#虚拟轮转法 Virtual RR</h6><p>由于<strong>RR对I/O型密集型进程不友好</strong></p>
<p>所以I/O进程单独设置队列，只有I/O型进程的队列为空时，才从就绪队列中用RR算法</p>
<h5 id="最高优先级调度HPF"><a href="#最高优先级调度HPF" class="headerlink" title="最高优先级调度HPF"></a>最高优先级调度HPF</h5><p>Highest Priority First</p>
<p><strong>优先级 and 优先数</strong></p>
<p>优先数反应了系统的优先级</p>
<p>静态优先级 and 动态优先级（在就绪队列等待时间过长，需要提高优先级）</p>
<p>就绪队列可以按优先级来分队列，从高优先级的队列中先取出进程来完成</p>
<p>系统进程优先级高于用户进程，<strong>前台进程优先级高于后台进程，</strong>操作系统更偏好I/O型进程</p>
<p><strong>特点：</strong></p>
<ul>
<li><p>时间简单</p>
</li>
<li><p>不公平</p>
</li>
</ul>
<p><strong>优先级反转问题</strong>：基于优先级的<strong>抢占式</strong></p>
<p>优先级翻转是当一个高优先级任务通过信号量机制访问共享资源时，<strong>该信号量已被一低优先级任务占有</strong>，因此造成高优先级任务被许多具有较低优先级任务阻塞，实时性难以得到保证。</p>
<p>是一个系统错误，高优先级进程停滞不前，导致系统性能降低</p>
<p>一个低优先级进程持有一个高优先级进程所需要的资源，使得高优先级进程等待低优先级进程运行</p>
<p><strong>解决方案：</strong></p>
<ul>
<li>设置优先级上限（进入临界区的进程优先级比未在临界区的进程的优先级要高</li>
<li>优先级继承（临时继承高优先级进程的优先级</li>
<li>使用中断禁止（进入临界区的进程不响应中断</li>
</ul>
<h5 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h5><p>Multiple feedback queue</p>
<p>综合调度算法，折衷算法</p>
<ul>
<li><p>设置<strong>多个</strong>就绪队列，第一级队列优先级最高</p>
</li>
<li><p>给<strong>不同就绪队列</strong>中的进程<strong>分配</strong>长度<strong>不同的时间片</strong>，第一级队列时间片最小，随着队列优先级别的降低，时间片增大</p>
</li>
<li><p><strong>各组队列</strong>按照<strong>时间片轮转方式</strong>进行调度</p>
</li>
<li>当一个新创建进程就绪后，进入第一级队列</li>
<li>进程用完时间片而放弃CPU，进入下一级就绪队列</li>
<li>由于阻塞而放弃CPU的进程进入相应的等待队列，一旦等待的时间发生，该进程回到原来一级的等待队列（队首/队尾、时间片剩余/重新计算）</li>
</ul>
<h5 id="短进程优先"><a href="#短进程优先" class="headerlink" title="短进程优先"></a>短进程优先</h5><p>Shortest process next</p>
<h5 id="保证调度"><a href="#保证调度" class="headerlink" title="保证调度"></a>保证调度</h5><p>Guaranteed scheduling</p>
<p>向用户做出有关性能的真实承诺，然后实现它们</p>
<h5 id="彩票调度"><a href="#彩票调度" class="headerlink" title="彩票调度"></a>彩票调度</h5><p>Lottery scheduling</p>
<p>为各种系统资源提供流程彩票，在安排时随机选择彩票，持有该票据的过程获得资源。</p>
<h5 id="公平分享调度"><a href="#公平分享调度" class="headerlink" title="公平分享调度"></a>公平分享调度</h5><p>Fair-share scheduling</p>
<p>每个用户都分配了一部分CPU</p>
<h4 id="实时系统调度"><a href="#实时系统调度" class="headerlink" title="实时系统调度"></a>实时系统调度</h4><p>m个periodic events（周期性事件），事件i发生在周期Pi内并且需要Ci秒<br>然后负载只能被处理在$\displaystyle\sum^m_{i=1}\frac{C_i}{P_i}\leq1$的条件下</p>
<h4 id="各调度算法的比较"><a href="#各调度算法的比较" class="headerlink" title="各调度算法的比较"></a>各调度算法的比较</h4><p><img src="/2018/12/08/操作系统-笔记/各种调度算法的比较.png" alt=""></p>
<h5 id="windows线程调度"><a href="#windows线程调度" class="headerlink" title="windows线程调度"></a><strong>windows线程调度</strong></h5><ul>
<li>调度单位是<strong>线程</strong>，采用基于<strong>动态优先级的</strong>、<strong>抢占式调度</strong>，结合<strong>时间配额</strong>的调整</li>
<li><strong>就绪线程</strong>按<strong>优先级</strong>进入相应的队列，系统总是选择<strong>优先级最高的就绪线程运行</strong></li>
<li><strong>同一优先级</strong>的各线程<strong>按时间片轮转</strong>进行调度</li>
<li><strong>多CPU系统中</strong>允许多个线程<strong>并行</strong>运行</li>
<li>引发线程调度的条件（除线程调度的条件外，加上以下两条：<ul>
<li>一个线程的优先级改变了</li>
<li>一个线程改变了它的亲和（Affinity）处理机集合<ul>
<li>亲和处理机集合：就是某线程所运行的处理机集合</li>
</ul>
</li>
</ul>
</li>
<li>32个线程优先级，分成三类<ul>
<li>系统线程 0<ul>
<li>用于对系统中空闲物理页面清零</li>
</ul>
</li>
<li>可变优先级 1-15<ul>
<li>可在一定范围内升高或降低</li>
<li>五种改变优先级的情况：<ul>
<li>I/O操作完成</li>
<li>信号量或事件等待结束</li>
<li>前台进程中的线程完成一个等待操作</li>
<li>由于窗口活动而唤醒窗口线程</li>
<li>线程处于就绪态超过了一定的时间还没有运行——<strong>“饥饿”</strong>现象</li>
</ul>
</li>
</ul>
</li>
<li>实时优先级 16-31<ul>
<li>不可以改变优先级</li>
<li>被抢占后，又恢复的时候，放在就绪队列队首</li>
</ul>
</li>
</ul>
</li>
<li>时间配额：配额单位的整数（如果用完了自己的时间配额，若没有其他相同优先级的进程，则重新分配时间配额，一般为5毫秒（比时间片的时间小很多）</li>
</ul>
<h6 id="UNIX两级调度算法"><a href="#UNIX两级调度算法" class="headerlink" title="UNIX两级调度算法"></a>UNIX两级调度算法</h6><ul>
<li>高级调度算法：在内存和磁盘之间移动进程以保证所有的进程都有机会进入内存运行</li>
<li>低级调度算法：从内存中的一组进程选取某个进程运行<ul>
<li>多级队列：每一个队列与不重叠的优先级关联</li>
<li>每个进程的优先级按照下列公式每秒一次地被重新计算：<pre><code>    优先级 = CPU_usage + nice + base
</code></pre>nice默认值为0，变化范围-20～20</li>
</ul>
</li>
</ul>
<h4 id="多处理器调度算法"><a href="#多处理器调度算法" class="headerlink" title="多处理器调度算法"></a>多处理器调度算法</h4><p>不仅需要决定哪一个进程，还需要决定在哪一个CPU上执行</p>
<p>要考虑进程在多个CPU之间迁移时的开销（尽可能使进程总是在同一个CPU上执行</p>
<p>考虑负载均衡问题</p>
<h3 id="Quiz4-模糊题"><a href="#Quiz4-模糊题" class="headerlink" title="Quiz4 模糊题"></a>Quiz4 模糊题</h3><p><img src="/2018/12/08/操作系统-笔记/quiz4.1.png" alt=""></p>
<p><img src="/2018/12/08/操作系统-笔记/quiz4.2.png" alt=""></p>
<h3 id="PPT练习题"><a href="#PPT练习题" class="headerlink" title="PPT练习题"></a>PPT练习题</h3><ol>
<li><p>Three batch jobs A through C, arrive at a computer center at 0, 2, 3 second. They have estimated running time of 3, 5, and 4 seconds. Their priorities are 3, 2and 1, respectively, with 1 being the highest priority. For each of the following scheduling algorithms, determine the mean process turnaround time. Ignore process switching overhead.<br>(a) Round robin (quantum=1s)</p>
<p>(b) Priority scheduling (Nonpreemptive)</p>
<p>(c) Priority scheduling (Preemptive)</p>
<p>(d) FCFS</p>
<p>(e) Shortest job first (Preemptive).</p>
<p>分析：a.   A 0-1 1-2 4-5     所以5</p>
<p>​        B 2-3 5-6 7-8 9-10 11-12 所以10    C 3-4 6-7 8-9 10-11 所以8</p>
<p>平均轮转时间(5+8+10)/3=23/3</p>
<p>b.    A 0-3 所以3 B 7-12 所以10 C 3-7 所以4</p>
<p>平均轮转时间(3+10+4)/3=17/3</p>
<p>c.    A 0-2  11-12 所以12 B 2-3 7-11 所以9 C 3-7 所以4</p>
<p>平均轮转时间(12+9+4)/3=25/3</p>
<p>d.  A 0-3 所以3 B 3-8 所以6 C 8-12 所以9</p>
<p>平均轮转时间(3+6+9)/3=6</p>
<p>e. A 0-3 所以3 B 7-12 所以10 C 3-7 所以4</p>
<p>平均轮转时间(3+10+4)/3=17/3</p>
</li>
<li><p>Four batch jobs A through D, arrive at a computer center at 0, 2, 3, 4 second. They have estimated running time of  3, 5, 4, and 1 seconds. Their priorities are 3, 2, 1, and 4, respectively, with 1 being the highest priority. For each of the following scheduling algorithms, determine the mean process turnaround time. Ignore process switching overhead.<br>(a) Round robin (quantum=1s)<br>(b) Priority scheduling (Preemptive)<br>(c) Priority scheduling (Nonpreemptive)<br>(d) FCFS<br>(e) Shortest job first (Preemptive)<br>(f) Shortest job first (Nonpreemptive)</p>
<p>分析：</p>
<p>a.     A 0-2 5-6 所以6        B 2-3 6-7 8-9    10-11 12-13所以11</p>
<p>​    C 3-4 7-8 9-10 11-12所以9    D 4-5 所以1</p>
<p>​    平均周转时间：(6+11+9+1)/4=27/4</p>
<p>b. A 0-2 11-12 所以12        B 2-3 7-11所以9</p>
<p>​    C 3-7 所以4    D 12-13 所以9</p>
<p>​    平均周转时间：(12+9+4+9)/4=34/4</p>
<p>c. A 0-3 所以3        B 7-12 所以10</p>
<p>​    C 3-7 所以4    D 12-13 所以9</p>
<p>​    平均周转时间：(3+10+4+9)/4=26/4</p>
<p>d. A 0-3 所以3        B 3-8 所以6</p>
<p>​    C 8-12 所以9    D 12-13 所以9</p>
<p>​    平均周转时间：(3+6+9+9)/4=27/4</p>
<p>e. A  0-3 所以3        B 8-13 所以11</p>
<p>​    C 3-4 5-8所以5    D  4-5 所以1</p>
<p>​    平均周转时间：(3+11+5+1)/4=5</p>
<p>f. A 0-3 所以3        B 8-13 所以11</p>
<p>​    C 3-7所以4    D 7-8所以4</p>
<p>​    平均周转时间：(3+11+4+4)/4=22/4</p>
</li>
<li><p>Five batch jobs A through E, arrive at a computer center at almost the same time. They have estimated running times of 10, 6, 2, 4 and 8 minutes. Their priorities are 3, 5, 2, 1 and 4, respectively, with 5 being the highest priority. For each of following scheduling algorithms, determine the mean process turn-around time. Ignore process switching overhead.  (a) Round robin; (b)Priority scheduling; (c)First-come, first-served(run in order 10, 6, 2, 4, 8); (d)Shortest job first<br><strong>For (a) assume that the system is multiprogrammed, and that each job gets its fair share of the CPU.</strong> For (b) through (d) assume that only one job at a time runs, until it finishes. All jobs are completely CPU bound.</p>
<p>a.</p>
<p>5个作业共享CPU，每个作业各获得1/5的CPU时间：C结束需要10分钟。（ TC = 10）<br>4个作业共享CPU，每个作业各获得1/4的CPU时间：D结束需要8分钟。（ TD = 10 + 8 = 18）<br>3个作业共享CPU，每个作业各获得1/3的CPU时间：B结束需要6分钟。（ TB = 18 + 6 = 24）<br>2个作业共享CPU，每个作业各获得1/2的CPU时间：E结束需要4分钟。（ TE  = 24 + 4 = 28）<br>A独占CPU运行2分钟，A结束：（ TA = 28 + 2 = 30）<br>平均周转时间T = 22</p>
<p>b. B 0-6 E 6-14 A 14-24 C 24-26 D 26-30 所以平均周转时间是（6+14+24+26+30）/5=20</p>
<p>c. A 0-10 B 10-16 C 16-18 D 18-22 E 22-30 所以平均周转时间是（10+16+18+22+30）/5=96/5=19.2</p>
<p>d. C 0-2 D 2-6 B 6-12 E 12-20 A 20-30 所以平均周转时间是（2+6+12+20+30）/5=14</p>
</li>
<li><p>Five processes A, B, C, D and E arrived in this order at the same time with the following CPU burst and priority values. A smaller value means a higher priority.<br>Fill the entries of the following table with waiting time and mean process turnaround time for each indicated scheduling policy and each process. Ignore context switching overhead.</p>
<p>|       | <strong>CPU Burst</strong> | <strong>Priority</strong> |<br>| ——- | ——————- | —————— |<br>| <strong>A</strong> | <strong>3</strong>         | <strong>3</strong>        |<br>| <strong>B</strong> | <strong>7</strong>         | <strong>5</strong>        |<br>| <strong>C</strong> | <strong>5</strong>         | <strong>1</strong>        |<br>| <strong>D</strong> | <strong>2</strong>         | <strong>4</strong>        |<br>| <strong>E</strong> | <strong>6</strong>         | <strong>2</strong>        |</p>
<p><em>等待时间=完成时间-任务需要时间</em></p>
<p>| <strong>Scheduling Policy</strong>                |        Waiting        |                                       |                                    |                  |                Time                 | <strong>Mean Process turnaround time</strong> |<br>| —————————————————— | :—————————-: | :—————————————————-: | :————————————————: | :———————: | :————————————————-: | ———————————————— |<br>|                                      |           A           |                   B                   |                 C                  |        D         |                  E                  |                                  |<br>| <strong>First-Come-First-Served</strong>          |           0           |                   3                   |                 10                 |        15        |                 17                  | (3+10+15+17+23)/5=68/5           |<br>| <strong>Non-Preemptive Shorted-Job First</strong> |           2           |                  16                   |                 5                  |        0         |                 10                  | (2+5+10+16+23)/5=56/5            |<br>| <strong>Priority</strong>                         |          11           |                  16                   |                 0                  |        14        |                  5                  | (5+11+14+16+23)/5=69/5           |<br>| <strong>Round-Robin(time quantum = 2)</strong>    | 0-2 10-11<br>11-3=8 | 2-4 11-13 17-19   22-23 <br>23-7=16 | 4-6       13-15 19-20<br>20-5=15 | 6-8 <br>8-2= 6 | 8-10       15-17 20-22<br>22-6=16 | (11+23+20+8+22)/5=84/5           |</p>
</li>
</ol>
<h2 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h2><h3 id="进程的并发执行"><a href="#进程的并发执行" class="headerlink" title="进程的并发执行"></a>进程的并发执行</h3><p><strong>从进程的特征来看：</strong></p>
<ul>
<li><p>并发</p>
<ul>
<li>进程的执行是间断性的</li>
<li>进程的相对执行速度不可预测</li>
</ul>
</li>
<li><p>共享</p>
<ul>
<li>进程/线程之间的制约性</li>
</ul>
</li>
<li>不确定性<ul>
<li>进程执行的结果与其执行的相对速度有关，是不确定的</li>
</ul>
</li>
</ul>
<h3 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h3><p><strong>竞争条件（Race condition）：</strong>两个或多个进程读写某些共享数据，而<strong>最后的结果取决于进程的精确时序</strong></p>
<p><strong>进程定义：</strong>由于各进程要求使用<strong>共享资源</strong>（变量、文件等），而这些资源需要<strong>排他性</strong>使用，各进程之间竞争使用这些资源</p>
<p><strong>临界资源：</strong> 系统中某些资源一次<strong>只允许一个进程</strong>使用，称这样的资源为<strong>临界资源或互斥资源或共享变量</strong></p>
<p><strong>临界区（互斥区）：</strong> 各个进程中对某个临界资源（共享变量）实施操作的程序片段</p>
<ul>
<li>使用原则<ul>
<li>没有进程在临界区时，想进入临界区的进程可进入</li>
<li>不允许两个进程同时处于其临界区中</li>
<li>不应对CPU的速度和数量做任何假设</li>
<li>临界区外运行的进程不得阻塞其他进程进入临界区</li>
<li>不得使进程无限期等待进入临界区</li>
</ul>
</li>
</ul>
<p>由于临界区的存在，在基于抢占式的优先级调度中，可能会出现<strong>优先级反转的问题</strong>（在最高优先级调度HPF中，有提到过）</p>
<p><strong>有7种方法：忙等待的互斥、休眠与唤醒、semaphores信号量、mutexes互斥锁、monitors管程、消息传递、屏障</strong></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="软件方案"><a href="#软件方案" class="headerlink" title="软件方案"></a>软件方案</h5><p>进入临界区之前需要一系列判断，增加开销；需要较高的编程技巧</p>
<p><strong>设置临界区空闲标志——锁变量</strong></p>
<p>false：无进程在临界区（初值为false）；true：有进程在临界区</p>
<p>缺点：因为进程的相对执行速度是不确定的，所以我们需要对lock()操作进行原子化，否则还是会导致进程之间覆盖数据的情况，即出现<strong>两个进程同时进入临界区的情形</strong></p>
<p>进入临界区的进程没有来得及置锁变量时，另一个进程开始运行，进入临界区；等到第一个进程再次被调度时，也进入临界区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// P，Q进程相同</span></div><div class="line"><span class="comment">// lock(); 为原子操作</span></div><div class="line"><span class="keyword">while</span>(<span class="built_in">free</span>) ;</div><div class="line"><span class="built_in">free</span>=<span class="literal">true</span>;</div><div class="line"></div><div class="line"><span class="comment">// 临界区</span></div><div class="line"></div><div class="line"><span class="comment">// unlock();</span></div><div class="line"><span class="built_in">free</span>=<span class="literal">false</span>;</div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure>
<p><strong>谁进临界区的标志turn</strong></p>
<p>true: P进程进入临界区；false：Q进程进临界区；初始值任意</p>
<p>缺点：Q进程想要执行，必须等待P进程执行完之后才可以进行，这样违反了<strong>“临界区外运行的进程不得阻塞其他进程进入临界区”</strong>；且对于多个进程的时候，turn的设置复杂</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// P进程</span></div><div class="line"><span class="keyword">while</span>(<span class="keyword">not</span> turn) ;</div><div class="line"></div><div class="line"><span class="comment">// 临界区</span></div><div class="line"></div><div class="line">turn=<span class="literal">false</span>;</div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Q进程</span></div><div class="line"><span class="keyword">while</span>(turn) ;</div><div class="line"></div><div class="line"><span class="comment">// 临界区</span></div><div class="line"></div><div class="line">turn=<span class="literal">true</span>;</div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure>
<p><strong>设置两个标志 pturn,qturn</strong></p>
<p>初始值为false</p>
<p>P进入临界区的条件pturn&amp;not qturn </p>
<p>Q进入临界区的条件not turn&amp;qturn</p>
<p>缺点：会导致两个进程都想进入临界区的时候，都进不去，最后时间片用完，但是临界区却空闲着；当有多个进程的时候，标志过多，while语句复杂</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// P进程</span></div><div class="line">pturn=<span class="literal">true</span>;</div><div class="line"><span class="keyword">while</span>(qturn) ;</div><div class="line"></div><div class="line"><span class="comment">// 临界区</span></div><div class="line"></div><div class="line">pturn=<span class="literal">false</span>;</div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Q进程</span></div><div class="line">qturn=<span class="literal">true</span>;</div><div class="line"><span class="keyword">while</span>(pturn) ;</div><div class="line"></div><div class="line"><span class="comment">// 临界区</span></div><div class="line"></div><div class="line">qturn=<span class="literal">true</span>;</div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure>
<h6 id="Dekker"><a href="#Dekker" class="headerlink" title="Dekker"></a>Dekker</h6><p>第一个用软件方法解决了进程互斥的问题</p>
<p>在算法三的基础上加上turn的变量，这样在两个进程都谦让的情况下，决定哪个进程优先进入临界区</p>
<p>缺点：在让出CPU的时候，还要保持循环，不断判断，进入<strong>忙等待</strong>状态，一直在CPU上等到时间片用完为止</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// P进程</span></div><div class="line">pturn=<span class="literal">true</span>;</div><div class="line"><span class="keyword">while</span>(qturn)&#123;</div><div class="line">    <span class="keyword">if</span>(turn == <span class="number">2</span>)&#123;<span class="comment">//如果两者都想要进入临界区的时候，判断哪个具有优先性</span></div><div class="line">        pturn=<span class="literal">false</span>;<span class="comment">//如果Q进程具有优先性，那么P进程就让出</span></div><div class="line">        <span class="keyword">while</span>(turn == <span class="number">2</span>);</div><div class="line">        pturn=<span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 临界区</span></div><div class="line">turn=<span class="number">2</span>;</div><div class="line">pturn=<span class="literal">false</span>;</div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Q进程</span></div><div class="line">qturn=<span class="literal">true</span>;</div><div class="line"><span class="keyword">while</span>(pturn)&#123;</div><div class="line">    <span class="keyword">if</span>(turn == <span class="number">1</span>)&#123;</div><div class="line">        qturn=<span class="literal">false</span>;</div><div class="line">        <span class="keyword">while</span>(turn == <span class="number">1</span>);</div><div class="line">        qturn=<span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 临界区</span></div><div class="line">turn=<span class="number">1</span>;</div><div class="line">qturn=<span class="literal">false</span>;</div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure>
<h6 id="Peterson"><a href="#Peterson" class="headerlink" title="Peterson"></a>Peterson</h6><p>解决了互斥访问的问题，而且<strong>克服了强制轮流法</strong>的缺点，可以完全正常地工作</p>
<p>主要思想：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 进程i</span></div><div class="line"><span class="comment">// ...</span></div><div class="line">enter_region(i);</div><div class="line"><span class="comment">// 临界区</span></div><div class="line">leave_region(i);<span class="comment">// 离开临界区之后，唤醒其他进程</span></div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure>
<p>具体实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2 	<span class="comment">//进程个数</span></span></div><div class="line"><span class="keyword">int</span> turn;		<span class="comment">//轮到谁</span></div><div class="line"><span class="keyword">int</span> interested[N];	<span class="comment">//兴趣数组，初始值均为FALSE</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">enter_region</span><span class="params">(<span class="keyword">int</span> process)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> other;	<span class="comment">//另外一个进程的进程号</span></div><div class="line">    other=<span class="number">1</span>-process;</div><div class="line">    interested[process]=TRUE;	<span class="comment">//表明本进程想要进入临界区</span></div><div class="line">    turn=process;	<span class="comment">//设置标志位</span></div><div class="line">    <span class="keyword">while</span>(turn==process&amp;&amp;interested[other]==TRUE); <span class="comment">//turn只有一个，后赋值给turn的进入临界区；对于前赋值给turn的，while条件为false，退出函数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">leave_region</span><span class="params">(<span class="keyword">int</span> process)</span></span>&#123;</div><div class="line">    interested[process]=FALSE:</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="硬件方案"><a href="#硬件方案" class="headerlink" title="硬件方案"></a>硬件方案</h5><h6 id="屏蔽中断"><a href="#屏蔽中断" class="headerlink" title="屏蔽中断"></a>屏蔽中断</h6><p>“开关中断”指令</p>
<p>在进入临界区<strong>之前</strong>，执行<strong>“关中断”</strong>操作；在离开临界区<strong>之后</strong>，执行<strong>“开中断”</strong>操作</p>
<p>特点：</p>
<ul>
<li>简单，高效</li>
<li>代价高，限制CPU并发能力（临界区大小）</li>
<li>不适用于多处理器，（只可以关一个CPU的，不可以控制所有的CPU都关上，这个进程可以用其他的CPU来抢占资源</li>
<li>适用于<strong>操作系统本身</strong>，<strong>不适于用户进程</strong>（用户程序不可以直接控制中断标志的</li>
</ul>
<h6 id="TSL指令"><a href="#TSL指令" class="headerlink" title="TSL指令"></a>TSL指令</h6><p>“测试并加锁”指令 Test and set lock</p>
<p>在CPU对内存<strong>总线上进行加锁</strong>，但是这样的方法也是会忙等待；但是<strong>对多处理器有效</strong>（因为对于同一个进程，会在一个CPU上循环，所以不会出现这个进程到其他CPU上进入临界区</p>
<ul>
<li>将一个内存字LOCK读到寄存器RX中，然后在该内存地址上存一个非零值</li>
<li>读数和写数操作保证是不可分割的。</li>
<li>执行TSL指令的CPU将锁住内存总线，以禁止其他CPU在本指令结束之前访问内存</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">enter_region:</div><div class="line">	TSL REGISTER, LOCK		| 复制锁到寄存器，并将锁置1</div><div class="line">	CMP REGISTER, #0		| 判断寄存器内容是否是零</div><div class="line">	JNE enter_region		| 若不是零，跳转到enter_region，说明已经上锁了，则需要反复测试</div><div class="line">	RET						| 若是零，则返回调用者，进入临界区</div><div class="line">	</div><div class="line">leave_region:</div><div class="line">	MOVE LOCK, #0			| 在锁中置0</div><div class="line">	RET						| 返回调用者</div></pre></td></tr></table></figure>
<p><strong>互斥</strong>仅适用于管理对某些<strong>共享资源</strong>或<strong>代码段</strong>的互斥<br><strong>互斥锁</strong>是一个变量，可以处于以下两种状态之一：<strong>解锁或锁定</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">mutex_lock:</div><div class="line">	TSL REGISTER, MUTEX		| 复制互斥锁到寄存器，并将互斥锁置1</div><div class="line">	CMP REGISTER, #0		| 判断寄存器内容是否是零</div><div class="line">	JZE ok					| 若是零，互斥锁未被上锁，所以返回ok</div><div class="line">	CALL thread_yeild		| 互斥锁上锁了，调度其他的线程，不进行忙等待</div><div class="line">	JMP mutex_lock			| 再次尝试</div><div class="line">	RET						| 若是零，则返回调用者，进入临界区</div><div class="line">	</div><div class="line">mutex_unlock:</div><div class="line">	MOVE MUTEX, #0			| 在锁中置0</div><div class="line">	RET						| 返回调用者</div></pre></td></tr></table></figure>
<h6 id="XCHG指令"><a href="#XCHG指令" class="headerlink" title="XCHG指令"></a>XCHG指令</h6><p>s p</p>
<p>也是通过加锁的方式（基本类似），但是是对锁和寄存器的内容进行交换操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">enter_region:</div><div class="line">	MOVE REGISTER, #1		| 给寄存器中置1</div><div class="line">	XCHG REGISTER, LOCK		| 交换寄存器与锁变量的内容</div><div class="line">	CMP REGISTER, #0		| 判断寄存器内容是否是零</div><div class="line">	JNE enter_region		| 若不是零，跳转到enter_region，说明已经上锁了，则需要反复测试</div><div class="line">	RET						| 若是零，则返回调用者，进入临界区</div><div class="line">	</div><div class="line">leave_region:</div><div class="line">	MOVE LOCK, #0			| 在锁中置0</div><div class="line">	RET						| 返回调用者</div></pre></td></tr></table></figure>
<h4 id="忙等待busy-waiting"><a href="#忙等待busy-waiting" class="headerlink" title="忙等待busy waiting"></a>忙等待busy waiting</h4><p>进程在得到临界区访问权之前，持续测试而不做其他事情</p>
<p>在单处理器上，应该拒绝这种方案；<strong>在多处理器上，</strong>因为切换的开销更大（临界区的时间比较短），所以可以允许忙等待的存在，同时把忙等待称作为<strong>自旋锁 Spin lock</strong></p>
<h4 id="阻塞Block"><a href="#阻塞Block" class="headerlink" title="阻塞Block"></a>阻塞Block</h4><p>在不允许他们进入关键区域时，禁止他们因为忙等待而浪费CPU时间；存在两个操作：<br>睡眠sleep：导致进程暂停，直到另一个进程唤醒它<br>唤醒wakeup：唤醒过程</p>
<h3 id="进程同步synchronization"><a href="#进程同步synchronization" class="headerlink" title="进程同步synchronization"></a>进程同步synchronization</h3><p>指系统中多个进程中发生的事件存在<strong>某种时序关系</strong>，需要相互合作，共同完成一项任务（多个进程之间的<strong>协作关系</strong>）</p>
<p>具体来说，一个进程运行到某一点时，要求另一伙伴进程为它提供消息，在未获得消息之前，该进程进入阻塞态，获得消息后被唤醒进入就绪态</p>
<h3 id="信号量及PV操作"><a href="#信号量及PV操作" class="headerlink" title="信号量及PV操作"></a>信号量及PV操作</h3><p>信号量（semaphore s）：一个特殊变量，用于进程间传递信息的一个整数值</p>
<p>由Dijkstra提出的<strong>同步互斥</strong>工具（可以完成同步，也可以完成互斥的功能）</p>
<p><strong>可实施的操作：</strong></p>
<ul>
<li>初始化</li>
<li>P操作（原语操作）：down<ul>
<li>检查信号量的值是否大于0</li>
<li>若<strong>大于0</strong>，则将其值减1，并继续</li>
<li>若<strong>等于0</strong>，则进程将休眠，而此时down操作并未结束</li>
<li>上述操作均作为单一的、不可分割的<strong>原子操作</strong>完成</li>
</ul>
</li>
<li>V操作（原语操作）：up<ul>
<li>对信号量的值增1</li>
<li>如果<strong>一个或多个进程</strong>在该信号量上<strong>休眠</strong>，无法完成一个先前的down操作，则由系<strong>统选择其中一个</strong>并允许该进程<strong>完成它的down操作</strong></li>
</ul>
</li>
</ul>
<p><strong>二元信号量（binary semaphore）：</strong>也称互斥(mutex)信号量，用于实现进程间的互斥，初值为1，保证同时<strong>只有一个进程</strong>可以<strong>进入临界区</strong></p>
<p><strong>计数信号量：</strong>也称同步信号量，用于实现进程间的同步，<strong>初值为0或某个正整数n</strong>，仅允许拥有它的进程对其实施P操作</p>
<p>计数信号量可以有多个值，而mutex只有两个值；</p>
<p>计数信号量一般在内核态下实现，而mutex一般在用户态下实现；</p>
<p>计数信号量数量远小于mutex的数量</p>
<p>两种实现方式：</p>
<ol>
<li>semaphore的取值必须大于或等于0；0表示当前已没有空闲资源，而正数表示当前空闲资源的数量</li>
<li>semaphore的取值<strong>可正可负</strong>，负数的绝对值表示<strong>正在等待进入临界区的进程个数</strong>（目前采用这种比较多）</li>
</ol>
<p>不管哪种，当信号量的值大于0时，表示<strong>当前可用资源的数量</strong></p>
<p><em>信号量的值仅能由P、V操作来改变</em></p>
<p><strong>定义：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span>&#123;</span></div><div class="line">    <span class="keyword">int</span> count;</div><div class="line">    queueType <span class="built_in">queue</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>P操作：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">P(s)&#123;</div><div class="line">    s.count--;</div><div class="line">    <span class="keyword">if</span>(s.count&lt;<span class="number">0</span>)&#123;</div><div class="line">        <span class="comment">// 该进程状态置为阻塞状态</span></div><div class="line">        <span class="comment">// 将该进程插入相应的等待队列s.queue末尾</span></div><div class="line">        <span class="comment">// 重新调度</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>V操作：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">V(s)&#123;</div><div class="line">    s.count++;</div><div class="line">    <span class="keyword">if</span>(s.count&lt;=<span class="number">0</span>)&#123;</div><div class="line">        <span class="comment">// 唤醒相应等待队列s.queue中等待的一个进程</span></div><div class="line">        <span class="comment">// 改变其状态为就绪态，并将其插入就绪队列</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>解决步骤：</strong></p>
<ul>
<li>分析并发进程的关键活动，划定临界区</li>
<li>设置信号量mutex，<strong>初值为1</strong></li>
<li>在临界区前实施P(mutex)</li>
<li>在临界区之后实施V(mutex)</li>
</ul>
<h4 id="生产者-消费者问题（有界缓冲区问题）"><a href="#生产者-消费者问题（有界缓冲区问题）" class="headerlink" title="生产者/消费者问题（有界缓冲区问题）"></a>生产者/消费者问题（有界缓冲区问题）</h4><p>比如：在spooling技术的打印中，输入进程和调度程序也是一个生产者/消费者问题</p>
<p>有问题但是一般的思考过程：（原因：<strong>对count的访问未加限制</strong>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></div><div class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> item;</div><div class="line">    <span class="keyword">while</span>(TRUE)&#123;</div><div class="line">        item=produce_item();</div><div class="line">        <span class="keyword">if</span>(count==N) sleep();</div><div class="line">        insert_item(item);</div><div class="line">        count=count+<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(count==<span class="number">1</span>)</div><div class="line">            wakeup(consumer);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> item;</div><div class="line">    <span class="keyword">while</span>(TRUE)&#123;</div><div class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>) sleep();<span class="comment">//这里有问题，如果判断完count==0，被进程切换了，这时候生产者继续生产，然后继续切换回消费者，消费者sleep，生产者发现它的生产量到达N了，也去sleep，那么两个进程将永远休眠下去，这就产生了错误</span></div><div class="line">        item=remove_item();</div><div class="line">        count=count<span class="number">-1</span>;</div><div class="line">        <span class="keyword">if</span>(count==N<span class="number">-1</span>)</div><div class="line">            wakeup(producer);</div><div class="line">        consume_item(item);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>解决方案：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100	<span class="comment">//缓冲区的个数</span></span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;	<span class="comment">//信号量是一种特殊的整型数据</span></div><div class="line">semaphore mutex=<span class="number">1</span>;		<span class="comment">//互斥信号量：控制对临界区的访问</span></div><div class="line">semaphore empty=N;		<span class="comment">//空缓冲区个数</span></div><div class="line">semaphore full=<span class="number">0</span>;		<span class="comment">///满缓冲区个数</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> item;</div><div class="line">    <span class="keyword">while</span>(TRUE)&#123;</div><div class="line">        item=produce_item();<span class="comment">// 可以不在临界区做的事情，就不要去临界区，减少时间的消耗；即把产品生产完后，再放入仓库，而不是在仓库里生产</span></div><div class="line">        <span class="comment">// 两个P操作不可以换顺序，比如consumer，先将临界区锁上后，发现仓库里没有产品了，于是停下来去等待生产者生产；但是生产者发现临界区被锁上了，就会等待临界区重新被打开；于是两者陷入了死锁的状态</span></div><div class="line">        P(&amp;empty);	<span class="comment">// 原来是 if(count==N) sleep();</span></div><div class="line">        P(&amp;mutex);	<span class="comment">// 不可以又生产又消费的，所以用互斥信号量进行保护</span></div><div class="line">        insert_item(item);</div><div class="line">        <span class="comment">// 两个V操作可以换顺序，不会出错，但是这样进程占用临界区的时间就变长了，其他进程就要等待多一点的时间了；所以不建议更换</span></div><div class="line">        V(&amp;mutex);</div><div class="line">        V(&amp;full);</div><div class="line">        <span class="comment">/* </span></div><div class="line"><span class="comment">        原来是</span></div><div class="line"><span class="comment">        count=count+1;</span></div><div class="line"><span class="comment">        if(count==1)</span></div><div class="line"><span class="comment">            wakeup(consumer);</span></div><div class="line"><span class="comment">        */</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> item;</div><div class="line">    <span class="keyword">while</span>(TRUE)&#123;</div><div class="line">        P(&amp;full); 	<span class="comment">// 原来是 if(count==0) sleep();</span></div><div class="line">        P(&amp;mutex);</div><div class="line">        item=remove_item();</div><div class="line">        V(&amp;mutex);</div><div class="line">        V(&amp;empty);</div><div class="line">        <span class="comment">/* </span></div><div class="line"><span class="comment">        原来是</span></div><div class="line"><span class="comment">        count=count-1;</span></div><div class="line"><span class="comment">        if(count==N-1)</span></div><div class="line"><span class="comment">            wakeup(producer);</span></div><div class="line"><span class="comment">        */</span></div><div class="line">        consume_item(item);<span class="comment">// 可以不在临界区做的事情，就不要去临界区，减少时间的消耗；即把产品从仓库取出来之后，就在外面吃，而不是在仓库里偷吃</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者/写者问题"></a>读者/写者问题</h4><p>条件：</p>
<ul>
<li>允许多个读者同时执行读操作</li>
<li>不允许多个写者同时操作</li>
<li>不允许读者、写者同时操作</li>
</ul>
<h5 id="读者优先"><a href="#读者优先" class="headerlink" title="读者优先"></a>读者优先</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">    <span class="keyword">while</span>(TRUE)&#123;</div><div class="line">        <span class="comment">// 多个读者可以同时操作，所以需要对rc变量进行保护</span></div><div class="line">        P(mutex);</div><div class="line">        rc=rc+<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(rc==<span class="number">1</span>) P(w);</div><div class="line">        V(mutex);</div><div class="line">        </div><div class="line">        <span class="comment">// 读操作</span></div><div class="line">        </div><div class="line">        P(mutex);</div><div class="line">        rc=rc<span class="number">-1</span>;</div><div class="line">        <span class="keyword">if</span>(rc==<span class="number">0</span>) V(w);</div><div class="line">		V(mutex);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">    <span class="keyword">while</span>(TRUE)&#123;</div><div class="line">        <span class="comment">// 写操作时，不允许读操作了，所以需要对w变量进行保护，同时P操作的时候，如果发现有读者在读，即w=0的时候，则不可以写了</span></div><div class="line">        P(w);</div><div class="line">        </div><div class="line">        <span class="comment">// 写操作</span></div><div class="line">        </div><div class="line">        V(w);</div><div class="line">		</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>（在存在信号量之后）引入管程的原因：信号量机制的不足：<strong>程序编写困难、易出错</strong></p>
<p>定义：</p>
<p>管程是一个由<strong>过程，变量和数据结构</strong>等组合的一个集合，它们组成一个特殊的<strong>模块或软件包</strong>。<strong>进程</strong>可在任何需要的时候<strong>调用管程中的过程</strong>，但它们<strong>不能在管程之外声明的过程中直接访问管程内的数据结构</strong>。<strong>任一时刻管程中只能有一个活跃进程</strong></p>
<ul>
<li>一种<strong>高级同步机制</strong></li>
<li>是一个特殊的<strong>模块</strong>（是过程，变量，数据结构的集合）</li>
<li>有一个名字</li>
<li>由关于共享资源的<strong>数据结构</strong>及在其上操作的一组过程组成</li>
</ul>
<h4 id="管程与进程的区别"><a href="#管程与进程的区别" class="headerlink" title="管程与进程的区别"></a>管程与进程的区别</h4><ul>
<li>进程定义的是<strong>私有数据结构PC</strong>B，管程定义的是<strong>公共数据结构；</strong></li>
<li>进程是由<strong>顺序程序执行有关操作</strong>，而管程主要是进行<strong>同步操作和初始化操作；</strong></li>
<li>设置进程的目的，在于实现系统的<strong>并发性</strong>，而管程的设置，则是<strong>解决共享资源的互斥使用问题；</strong></li>
<li>管程为<strong>被动工作方式</strong>，进程则为<strong>主动工作方式；</strong></li>
<li>进程之间能<strong>并发执行</strong>，而<strong>管程则不能与其调用者并发；</strong></li>
<li>进程具有<strong>动态性，</strong>而管程则是操作系统中的一个<strong>资源管理模块，供进程调用</strong></li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>易读性差</strong><ul>
<li>要了解对于一组共享变量及信号量的操作是否正确，则必须通读整个系统或者并发程序</li>
</ul>
</li>
<li>不利于<strong>修改和维护</strong><ul>
<li>程序的局部性很差，所以任一组变量或一段代码的修改都可能影响全局</li>
</ul>
</li>
<li><strong>正确性</strong>难以保证<ul>
<li>操作系统或并发程序通常很大，要保证这样一个复杂的系统没有逻辑错误是很难的</li>
</ul>
</li>
</ul>
<p>其他：进程无法直接访问monitor，只能通过通过<strong>调用</strong>管程中的<strong>过程</strong>来<strong>间接地访问</strong>管程中的数据结构；<strong>在任何时刻，</strong>管程中<strong>只能有一个</strong>进程处于活动状态</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">monitor example(管程的名称)</div><div class="line">	（管程的数据结构）</div><div class="line">	integer i;</div><div class="line">	condition c;</div><div class="line">	（对数据结构进行操作的一组过程）</div><div class="line">	<span class="function"><span class="keyword">procedure</span> <span class="title">producer</span><span class="params">()</span>;</span></div><div class="line">	...</div><div class="line">	<span class="keyword">end</span>;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span><span class="params">()</span>;</span></div><div class="line">	...</div><div class="line">	<span class="keyword">end</span>;</div></pre></td></tr></table></figure>
<p><strong>解决两大问题：</strong></p>
<ul>
<li><strong>互斥</strong><ul>
<li>管程是<strong>互斥</strong>进入的——为了保证管程中数据结构的数据完整性</li>
<li>管程的互斥性是由<strong>编译器</strong>负责保证的</li>
</ul>
</li>
<li>同步<ul>
<li>管程中设置<strong>条件变量及等待/唤醒操作</strong>以解决同步问题</li>
<li>可以让一个进程或线程在条件变量上等待（此时，<strong>应先释放管程的使用权</strong>），也可以通过发送信号将等待在条件变量上的进程或线程唤醒</li>
<li>可能会出现Q进程唤醒了之前睡着的P进程，但是这样就出现了两个活跃进程的问题<ul>
<li>方案一：规定唤醒操作为管程中最后一个可执行的操作，唤醒后进程就终止了</li>
<li>方案二：P等待Q执行</li>
<li>方案三：Q等待P继续执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="HOARE管程"><a href="#HOARE管程" class="headerlink" title="HOARE管程"></a>HOARE管程</h4><p>当一个进程<strong>试图进入</strong>一个<strong>已被占用</strong>的管程时，进入<strong>管程的入口处</strong>设置的进程等待队列，此队列又称作<strong>入口等待队列</strong></p>
<p>解决同步问题的时候，采用了<strong>方案三</strong>，一个管程内部允许存在多个等待进程，将它们放在管程内的进程等待队列，此队列又称作<strong>紧急等待队列</strong>，紧急等待队列的优先级高于<strong>入口等待队列</strong>的优先级</p>
<h5 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h5><p>在管程内部说明和使用的一种特殊类型的变量</p>
<p><code>var c:condition;</code></p>
<p>对于条件变量，可以执行<code>wait</code>和<code>signal</code>操作</p>
<p><strong>wait(c)</strong></p>
<p>如果紧急等待队列非空，则唤醒第一个等待者；否则释放管程的互斥权，执行此操作的进程进入<strong>c链末尾</strong></p>
<p><strong>signal(c)</strong></p>
<p>如果c链为空，则相当于空操作，执行此操作的进程继续执行；否则唤醒第一个等待者，执行此操作的进程进入<strong>紧急等待队列</strong>的末尾</p>
<p><strong>缺点：</strong></p>
<ul>
<li>两次额外的进程切换</li>
</ul>
<h4 id="MESA管程"><a href="#MESA管程" class="headerlink" title="MESA管程"></a>MESA管程</h4><p>解决了HOARE管程的缺点，通过把signal换成了notify的方法</p>
<p>notify：当一个正在管程中的进程执行<code>notify(x)</code>时，它使得x条件队列<strong>得到通知</strong>，<strong>发信号的进程继续执行</strong></p>
<p>使得到通知的进程，在<strong>将来合适的时候</strong>且当处理器可用时恢复执行；但是这样不能保证在它之前没有其他进程进入管程，因而这个进程必须<strong>重新检查条件</strong>，用while循环取代if语句，这样会导致对条件变量至少多一次<strong>额外的检测</strong>（但不再有额外的进程切换），并且对等待进程在notify之后<strong>何时运行没有任何限制</strong></p>
<p>可以对notify改进：</p>
<ul>
<li>给每个条件原语关联一个<strong>监视计时器</strong>，不论是否被通知，一个等待时间超时的进程将会被设为就绪态</li>
<li>当该进程被调度执行时，会再次检查相关条件，如果条件满足则继续执行</li>
<li>引入broadcast：使所有在该条件上等待的进程都被释放进入就绪队列</li>
</ul>
<p><strong>相对于HOARE管程来说：</strong>出错率更小</p>
<h4 id="管程的实现和应用"><a href="#管程的实现和应用" class="headerlink" title="管程的实现和应用"></a>管程的实现和应用</h4><p>实现的途径：</p>
<ul>
<li>直接构造：效率高</li>
<li>间接构造：用某种已经实现的同步机制（信号量，P、V操作）去构造</li>
</ul>
<p>应用：</p>
<h5 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者/消费者问题"></a>生产者/消费者问题</h5><p>HOARE管程：</p>
<p><code>signal</code>只能作为管程过程的最后一条语句</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">monitor ProducerConsumer</div><div class="line">	condition full, empty;</div><div class="line">	integer count;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(item:integer)</span>;</span></div><div class="line">	<span class="keyword">begin</span></div><div class="line">		<span class="keyword">if</span> count == N <span class="keyword">then</span> wait(full);</div><div class="line">		insert_item(item); count++;</div><div class="line">		<span class="keyword">if</span> count == <span class="number">1</span> <span class="keyword">then</span> signal(empty);</div><div class="line">	<span class="keyword">end</span>;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">remove</span>:</span>integer;</div><div class="line">	<span class="keyword">begin</span></div><div class="line">		<span class="keyword">if</span> count == <span class="number">0</span> <span class="keyword">then</span> wait(empty);</div><div class="line">		remove = remove_item(item); count--;</div><div class="line">		<span class="keyword">if</span> count == N-<span class="number">1</span> <span class="keyword">then</span> signal(full);</div><div class="line">	<span class="keyword">end</span>;</div><div class="line">	</div><div class="line">	count:=0; /* 设置管程内数据的初始值 */</div><div class="line"><span class="keyword">end</span> monitor;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">producer</span>;</span></div><div class="line"><span class="keyword">begin</span></div><div class="line">	<span class="keyword">while</span> true <span class="keyword">do</span></div><div class="line">	<span class="keyword">begin</span></div><div class="line">		item = produce_item();</div><div class="line">		ProducerConsumer.insert(item);</div><div class="line">	<span class="keyword">end</span></div><div class="line"><span class="keyword">end</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span>;</span></div><div class="line"><span class="keyword">begin</span></div><div class="line">	<span class="keyword">while</span> true <span class="keyword">do</span></div><div class="line">	<span class="keyword">begin</span></div><div class="line">		ProducerConsumer.remove(item);</div><div class="line">		consume_item(item);</div><div class="line">	<span class="keyword">end</span></div><div class="line"><span class="keyword">end</span>;</div></pre></td></tr></table></figure>
<p>MESA管程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;</div><div class="line">    <span class="keyword">while</span>(count == N) cwait(notfull);</div><div class="line">    buffer[nextin] = x;</div><div class="line">    nextin = (nextin + <span class="number">1</span>) % N;</div><div class="line">    count++;</div><div class="line">    cnotify(notempty);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">take</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;</div><div class="line">    <span class="keyword">while</span>(count == <span class="number">0</span>) cwait(notempty);</div><div class="line">    x = buffer[nextout];</div><div class="line">    nextout = (nextout + <span class="number">1</span>) % N;</div><div class="line">    count--;</div><div class="line">    cnotify(notfull);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="进程与管程"><a href="#进程与管程" class="headerlink" title="进程与管程"></a>进程与管程</h4><p>进程<strong>只能</strong>通过<strong>调用</strong>管程中的<strong>过程</strong>来<strong>间接地访问</strong>管程中的数据结构</p>
<ul>
<li>进程定义的是<strong>私有数据结构PCB</strong>，管程定义的是<strong>公共数据结构</strong></li>
<li>进程是由<strong>顺序</strong>程序执行有关操作，而管程主要是进行<strong>同步</strong>操作和<strong>初始化</strong>操作</li>
<li>设置进程的目的，在于实现系统的<strong>并发性</strong>，而管程的设置，则是解决<strong>共享资源的互斥使用问题</strong></li>
<li>管程为<strong>被动工作方式，</strong>进程则为<strong>主动工作方式</strong></li>
<li>进程之间能<strong>并发执行</strong>，而管程则不能与其调用者并发</li>
<li>进程具有<strong>动态性</strong>，而管程则是操作系统中的一个<strong>资源管理模块</strong>，<strong>供进程调用</strong></li>
</ul>
<h3 id="Pthread的同步机制"><a href="#Pthread的同步机制" class="headerlink" title="Pthread的同步机制"></a>Pthread的同步机制</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 互斥量，保护临界区</span></div><div class="line">Pthread_mutex_init();</div><div class="line">Pthread_mutex_destory();</div><div class="line">Pthread_mutex_lock();</div><div class="line">Pthread_mutex_trylock();</div><div class="line">Pthread_mutex_unlock();</div><div class="line"></div><div class="line"><span class="comment">// 条件变量，解决同步</span></div><div class="line">Pthread_cond_init();</div><div class="line">Pthread_cond_destory();</div><div class="line">Pthread_cond_wait();</div><div class="line">Pthread_cond_signal();</div><div class="line">Pthread_cond_broadcast();</div></pre></td></tr></table></figure>
<h4 id="生产者-消费者问题-1"><a href="#生产者-消费者问题-1" class="headerlink" title="生产者/消费者问题"></a>生产者/消费者问题</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1e9		<span class="comment">//how many numbers to produce</span></span></div><div class="line"><span class="keyword">pthread_mutex_t</span> the_mutex;</div><div class="line"><span class="keyword">pthread_cond_t</span> condc,condp;</div><div class="line"><span class="keyword">int</span> buffer = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=MAX; i++)&#123;</div><div class="line">        pthread_mutex_lock(&amp;the_mutex);</div><div class="line">        <span class="keyword">while</span>(buffer!=<span class="number">0</span>)</div><div class="line">            pthread_cond_wait(&amp;condp,&amp;the_mutex); <span class="comment">//条件不成立的时候，把互斥锁打开，然后进入等待状态；当收到一个解除等待的信号（pthread_cond_signal或者pthread_cond_broad_cast）之后，pthread_cond_wait进行上锁操作</span></div><div class="line">        buffer = i;</div><div class="line">        pthread_cond_signal(&amp;condc);</div><div class="line">        pthread_mutex_unlock(&amp;the_mutex);</div><div class="line">    &#125;</div><div class="line">    pthread_exit(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=MAX; i++)&#123;</div><div class="line">        pthread_mutex_lock(&amp;the_mutex);</div><div class="line">        <span class="keyword">while</span>(buffer==<span class="number">0</span>)</div><div class="line">            pthread_cond_wait(&amp;condc,&amp;the_mutex);</div><div class="line">        buffer = <span class="number">0</span>;</div><div class="line">        pthread_cond_signal(&amp;condp);</div><div class="line">        pthread_mutex_unlock(&amp;the_mutex);</div><div class="line">    &#125;</div><div class="line">    pthread_exit(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a>通信机制</h3><p>产生的原因：信号量及管程只能传递很简单的信息，<strong>不能传递大量的信息</strong>；管程<strong>不适用多处理器</strong>情况</p>
<p>进程通信机制：</p>
<ul>
<li>消息传递：<strong>send&amp;receive原语</strong><ul>
<li><code>send(destination, &amp;message)</code></li>
<li><code>receive(source, &amp;message)</code></li>
</ul>
</li>
<li>适用于：分布式系统、基于共享内存的多处理机系统、单处理机系统</li>
<li>可以解决进程间的同步问题、互斥问题、通信问题</li>
<li>设计的问题：确认消息，身份验证，性能</li>
</ul>
<p>进程间的数据交换，是以<strong>格式化</strong>的消息（也称为报文）为单位的。程序员直接利用操作系统提供的一组通信命令（原语），实现大量数据的传递，通信过程对用户是透明的。<br>消息传递系统的通信方式分成两类：</p>
<ol>
<li>直接通信方式：发送进程利用OS所提供的发送命令，直接把消息发送给目标进程</li>
<li>间接通信方式：进程之间的通信，通过中间实体（也称为信箱）来<strong>暂存发送进程发送给目标进程的消息</strong>，接收进程则从该实体中<strong>读取</strong>发送给自己的消息</li>
</ol>
<p>基本通信方式：</p>
<ul>
<li>消息传递<ul>
<li>buffer消息缓冲区：消息头（消息类型，接受进程ID，发送进程ID，消息长度，控制信息）消息体</li>
<li>发送send原语（需要申请消息缓冲区），陷入内核；复制消息；接收进程的PCB中消息队列指针，消息入队；receive原语，陷入内核，复制消息</li>
</ul>
</li>
<li>共享内存<ul>
<li>需要解决建立共享物理内存的地址映射问题和共享内存的读者/写者问题</li>
</ul>
</li>
<li>管道<ul>
<li>利用缓冲传输介质——内存或文件连接两个相互通信的进程</li>
<li>字符流的方式来写入读出，它是没有格式的</li>
<li>先进先出顺序</li>
<li>管道通信机制必须提供协调能力：互斥、同步、判断对方进程是否存在</li>
</ul>
</li>
<li>套接字</li>
<li>远程过程调用</li>
</ul>
<h4 id="Linux的进程通信机制"><a href="#Linux的进程通信机制" class="headerlink" title="Linux的进程通信机制"></a>Linux的进程通信机制</h4><p>用户进程：管道、消息队列、共享内存、信号量、信号、套接字……</p>
<p>内核同步机制：</p>
<ul>
<li>原子操作<ul>
<li>操作不可分割，在执行完之前不会被其他任务或事件中断</li>
<li>常用于实现资源的计数</li>
<li>atomic_t类型</li>
</ul>
</li>
<li>自旋锁</li>
<li>读写锁</li>
<li>信号量</li>
<li>屏障（栅栏、关卡）<ul>
<li>一种同步机制</li>
<li>用于对一组线程进行协调</li>
<li>一组线程协同完成一项任务，需要<strong>所有</strong>线程都到达一个汇合点后再<strong>一起向前推进</strong></li>
<li>常用于矩阵运算</li>
</ul>
</li>
<li>……</li>
</ul>
<p><strong>注：</strong>验证代码的正确性：<strong>以不同的次序运行各进程，</strong>是否能保证问题的圆满解决，切忌按固定顺序执行各进程</p>
<h3 id="Quiz-5-错题和模糊题"><a href="#Quiz-5-错题和模糊题" class="headerlink" title="Quiz 5 错题和模糊题"></a>Quiz 5 错题和模糊题</h3><p>1 临界区执行相同的一段代码 </p>
<p><img src="/2018/12/08/操作系统-笔记/quiz5.1.png" alt=""></p>
<p>5 麻将应该是没有互斥的部分</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz5.2.png" alt=""></p>
<p>7 应该选择第3个，可以想像到进程在申请资源，所以是等待队列到就绪队列</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz5.3.png" alt=""></p>
<p>9 等待队列中有k个进程，而不是同时有k个进程来申请资源</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz5.4.png" alt=""></p>
<p>10 错误，是中断不适合多处理器（见前文的解析）</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz5.5.png" alt=""></p>
<h3 id="Quiz-6-错题和模糊题"><a href="#Quiz-6-错题和模糊题" class="headerlink" title="Quiz 6 错题和模糊题"></a>Quiz 6 错题和模糊题</h3><p><img src="/2018/12/08/操作系统-笔记/quiz6.1.png" alt=""></p>
<p><img src="/2018/12/08/操作系统-笔记/quiz6.2.png" alt=""></p>
<p>应该选择错误，唤醒之前的那个管程，然后等待唤醒之前的管程P执行完后，再执行后面的管程Q</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz6.3.png" alt=""></p>
<h3 id="PPT练习题-1"><a href="#PPT练习题-1" class="headerlink" title="PPT练习题"></a>PPT练习题</h3><ol>
<li><p>n processes shared one segment, if allow m(m&lt;n) processes enter the mutual segment simultaneously（同时）, then the value range of semaphore is <strong>__</strong>  .</p>
<p>-(n-m)~m</p>
</li>
<li><p>In the process management, if the initial value of semaphore S is 2 and the current value is -1, then there are ____ processes waiting for this resource.<br>1</p>
</li>
<li><p>设一民航航班售票系统有n个售票处。每个售票处通过终端访问系统中的公用数据区，假定公共数据区中的某些单元xk(k = 1, 2, …)分别存放某月某日某次航班的现存票数。设P1，P2，…，Pn表示各售票处的处理进程，R1，R2，…，Rn表示各进程执行时所用的工作单元，试给出各个进程的程序代码</p>
<p>一个信号量s，保证每次访问公共数据区的只有一个进程，初值为1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">semaphore      s = 1;</div><div class="line"></div><div class="line">/* 进程Pi (i = 1, 2, …)的代码 */</div><div class="line">按旅客订票要求找到xk;</div><div class="line">P(s);			/*  进程Pi进入临界区 */</div><div class="line">Ri = xk;</div><div class="line">if (Ri &gt;= 1) &#123;</div><div class="line">     Ri = Ri - 1;</div><div class="line">     xk = Ri ;</div><div class="line">     V(s);			 /*  进程Pi离开临界区 */</div><div class="line">     输出一张票;</div><div class="line">&#125;</div><div class="line">else   &#123;</div><div class="line">     V(s);			 /*  进程Pi离开进入临界区 */</div><div class="line">      输出“票已售完”;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>桌上有一只盘子，每次只能放入一个水果。爸爸专向盘中放苹果，妈妈专向盘中放桔子。一个女儿专门等着吃盘中的苹果，一个儿子专门等着吃盘中的桔子，试用P、V操作写出他们能同步的程序</p>
<p>生产者与消费者问题的变形：2个生产者（爸爸、妈妈）、2个消费者（女儿、儿子）共享一个只能存放一个数据的区域（盘子）<br>创建4个进程，分别对应爸爸、妈妈、女儿、儿子<br>信号量：<br>互斥信号量：empty = 1（能否向盘子中放水果）<br>同步信号量：SA = 0（最大苹果数）、SO = 0（最大桔子数）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/* 爸爸进程 */</div><div class="line"></div><div class="line">P(empty);</div><div class="line">放入一个苹果;</div><div class="line">V(SA);</div><div class="line">…</div><div class="line"></div><div class="line">/* 女儿进程 */</div><div class="line"></div><div class="line">P(SA);</div><div class="line">取出苹果;</div><div class="line">V(empty);</div><div class="line">…</div></pre></td></tr></table></figure>
</li>
<li><p>A store has two consigners (发货员), one checker. when customer want to pick up the goods, if one of the consigner is idle, the customer is allowed to get into the store and take the goods. when customer leaves, the checker examines whether customer gets the right goods. To coordinate（协调） their works using PV operations, two semaphore S1 and S2 are used. The initial value of S1 is 2, and the initial value of S2 is 1. the operation in ‘a’ shown in the following figure should be (1); the operation in ‘b’, ‘c’ and ‘d’ should be (2) .<br> (1) A. P(S1)            B. P(S2)    </p>
<pre><code>   C. V(S1)            D. V(S2)
</code></pre><p>  (2) A. P(S2)、V(S2) and V(S1)</p>
<pre><code>    B. P(S1)、V(S1) and V(S2)
    C. V(S1)、P(S2) and V(S2)
    D. V(S2)、P(S1) and V(S1)
</code></pre><p><img src="/2018/12/08/操作系统-笔记/练习题5.5.png" alt=""></p>
<p>A C</p>
</li>
<li><p>有一阅览室，读者进入时必须先在一张登记表上进行登记。该表为每一座位列出一个表目，包括座号、姓名。读者离开时要撤销登记信息。阅览室有100个座位，试问：</p>
<pre><code>(1) 为描述读者的动作，应编写几个程序，应该设置几个进程？进程和程序之间的对应关系如何？
(2) 试用P、V操作描述这些进程间的同步算法
</code></pre><p>分析：读者动作：登记、读书、撤销</p>
<p>座位总数100</p>
<p>登记/撤销都需要在登记表修改信息，一次只能由一个读者对登记表进行访问（登记表是临界资源，必须互斥访问）</p>
<p>1个程序，1个读者1个进程，进程是程序的一次执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span>  semaphore;</div><div class="line">semaphore  mutex = <span class="number">1</span>;  empty = <span class="number">100</span>;</div><div class="line"><span class="function">Process <span class="title">reader</span><span class="params">()</span> </span>&#123;</div><div class="line">      到达阅览室；</div><div class="line">      <span class="keyword">register</span>();</div><div class="line">      进入阅览室；</div><div class="line">      unregister();</div><div class="line">      离开阅览室;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">register</span>() &#123;                 </div><div class="line">      P(empty);</div><div class="line">      P(mutex);</div><div class="line">      登记；</div><div class="line">       V(mutex);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">unregister() &#123;               </div><div class="line">      P(mutex);</div><div class="line">      撤销登记;</div><div class="line">      V(empty);</div><div class="line">      V(mutex);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>设有3个并发进程R、M、P，它们共享一个缓冲区。R负责从输入设备读信息，每读出一个记录后，就把它存放在缓区中；M在缓冲区中加工读入的记录；P把加工后的记录打印输出。读入的记录经加工输出后，缓冲区又可存放下一个记录。试写出它们能正确执行的程序</p>
<p>分析：R、M、P的同步，缓冲区每次只能放一个记录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">semaphore  s1 = <span class="number">1</span>,  <span class="comment">/* 缓冲区存放的最大记录数 */</span></div><div class="line">           s2 = <span class="number">0</span>, <span class="comment">/* 缓冲区中待加工的记录数 */</span> </div><div class="line">           s3 = <span class="number">0</span>; <span class="comment">/* 缓冲区中待打印的记录数 */</span></div><div class="line"><span class="function">Process <span class="title">R</span><span class="params">()</span> </span>&#123;</div><div class="line">   读入一个记录；</div><div class="line">   P(s1);</div><div class="line">   将记录放入缓冲区；</div><div class="line">   V(s2);</div><div class="line">&#125;</div><div class="line"><span class="function">Process <span class="title">M</span><span class="params">()</span> </span>&#123;</div><div class="line">   P(s2);</div><div class="line">   加工记录；</div><div class="line">   V(s3);</div><div class="line">&#125;</div><div class="line"><span class="function">Process <span class="title">P</span><span class="params">()</span> </span>&#123;</div><div class="line">   P(s3);</div><div class="line">   打印记录；</div><div class="line">   V(s1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>有三个进程A、B和C协作解决文件打印问题：A将文件记录从磁盘读入主存的缓冲区buffer1，每执行一次读一个记录；B将缓冲区buffer1的内容复制到缓冲区buffer2，每执行一次复制一个记录；C打印缓冲区buffer2的内容，每执行一次打印一个记录。缓冲区的大小和一个记录大小一样。请用P、V操作来保证文件的正确打印</p>
<p>分析：B既是生产者也是消费者</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">semaphore  mutex1 = mutex2 = <span class="number">1</span>;</div><div class="line">           empty1 = empty2 = <span class="number">1</span>;</div><div class="line">           full1 = full2 = <span class="number">0</span>;</div><div class="line"><span class="function">Process <span class="title">A</span><span class="params">()</span> </span>&#123;</div><div class="line">   从磁盘读入一个记录；</div><div class="line">   P(empty1);</div><div class="line">   P(mutex1);</div><div class="line">   将记录放入缓冲区buffer1；</div><div class="line">   V(full1);</div><div class="line">   V(mutex1);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Process <span class="title">B</span><span class="params">()</span> </span>&#123;</div><div class="line">   P(full1);</div><div class="line">   P(mutext1)</div><div class="line">   从buffer1中取一条记录；</div><div class="line">   V(empty1);</div><div class="line">   V(mutex1);</div><div class="line">   P(empty2);</div><div class="line">   P(mutex2);</div><div class="line">   将记录拷入buffer2;</div><div class="line">   V(full2);</div><div class="line">   V(mutex2);</div><div class="line">&#125;</div><div class="line"><span class="function">Process <span class="title">C</span><span class="params">()</span> </span>&#123;</div><div class="line">   P(full2);</div><div class="line">   P(mutext2)</div><div class="line">   从buffer2中取一条记录；</div><div class="line">   V(empty2);</div><div class="line">   V(mutex2);</div><div class="line">   打印记录</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>这里说明一下，首先对于生产者，是先占位P(empty)，然后通过P(mutex)V(mutex)，对V(full)进行操作来生产；对于消费者，它检查的是full，所以先P(empty)没有影响，还可以减少mutex的临界区的时间，而且对于加入的操作必须是原子性的，所以这样是ok的【可以对full和mutex的V操作进行交换】；同样的，对于消费者，先占位P(full)，然后通过mutex对empty进行操作</em></p>
</li>
</ol>
<h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><p>预备知识：</p>
<ul>
<li>程序中装载到内存才可以运行：通常，程序以可执行文件格式保存在磁盘上</li>
<li>每个进程有自己的地址空间</li>
<li>一个进程执行时不能访问另一个进程的地址空间</li>
<li>进程中的地址不是最终的物理地址</li>
<li>在进程运行前无法计算出物理地址：因为不能确定进程被加载到内存什么地方</li>
</ul>
<p><strong>进程地址空间</strong></p>
<ul>
<li>内核地址空间</li>
<li>用户地址空间<ul>
<li>栈</li>
<li>堆</li>
<li>数据段</li>
<li>代码段</li>
</ul>
</li>
</ul>
<h3 id="地址重定位"><a href="#地址重定位" class="headerlink" title="地址重定位"></a>地址重定位</h3><p>又称地址转换、地址映射、地址翻译；将用户程序中的逻辑地址转换为运行时可由机器直接寻址的物理地址</p>
<p><strong>逻辑地址：</strong>相对地址，虚拟地址；目标代码通常采用相对地址的形式，其首地址为0，其余地址都相对于首地址而编址；不能用逻辑地址在内存中读取信息</p>
<p><strong>物理地址：</strong>绝对地址，实地址；内存中存储单元的地址，可直接寻址</p>
<ul>
<li><p><strong>静态重定位：</strong>当用户程序<strong>加载到内存时</strong>，一次性实现逻辑地址到物理地址的转换</p>
<ul>
<li>一般由软件完成</li>
</ul>
</li>
<li><p><strong>动态重定位：</strong>在进程<strong>执行过程中</strong>进行地址变换，即逐条指令执行时完成地址转换</p>
<ul>
<li>需要硬件部件支持</li>
<li>CPU将逻辑地址送入到MMU（内存管理单元），MMU完成地址转换工作，得到物理地址</li>
</ul>
</li>
</ul>
<h3 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h3><p>空闲内存管理</p>
<ul>
<li>等长划分<ul>
<li>位图</li>
</ul>
</li>
<li>不等长划分<ul>
<li>空闲区表</li>
<li>已分配区表</li>
<li>空闲区链表</li>
</ul>
</li>
</ul>
<h4 id="内存分配算法"><a href="#内存分配算法" class="headerlink" title="内存分配算法"></a>内存分配算法</h4><p>将空闲块分配之后，又分成新的空闲块和已使用部分</p>
<ul>
<li>首次适配 first fit<ul>
<li>在空闲区表中找到<strong>第一块满足进程要求</strong>的空闲区</li>
</ul>
</li>
<li>下次适配 next fit<ul>
<li>从上次找到的空闲区处<strong>接着查找</strong></li>
</ul>
</li>
<li>最佳适配 best fit<ul>
<li>查找整个空闲区表，找到能够满足进程要求的<strong>最小</strong>空闲区</li>
<li>需要搜索整个链表</li>
<li>并且对于空闲块的合并较为复杂</li>
</ul>
</li>
<li>最差适配 worst fit<ul>
<li>总是分配满足进程要求的<strong>最大</strong>空闲区</li>
<li>需要搜索整个链表</li>
</ul>
</li>
<li>快速适配 quick fit<ul>
<li>为一些所需的更常见尺寸维护单独的列表</li>
</ul>
</li>
</ul>
<h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><p>一种内存分配方案</p>
<p>主要思想：将内存按2的幂进行划分，组成若干空闲块链表；查找该链表找到能满足进程需求的最佳匹配块</p>
<p>算法：</p>
<ol>
<li>首先将整个可用空间看作一块： $2^U$</li>
<li>假设进程申请的空间大小为s，如果满足$2^{U-1}&lt;s\leq2^U$，则分配整个块；否则，<strong>将块划分为两个大小相等的伙伴</strong>，大小为$2^{U-1}$</li>
<li>一直划分下去直到产生大于或等于s的最小块</li>
</ol>
<h4 id="内存回收问题"><a href="#内存回收问题" class="headerlink" title="内存回收问题"></a>内存回收问题</h4><p>当某一块归还后，前后空闲空间合并，修改内存空闲区表</p>
<h4 id="内存管理方案"><a href="#内存管理方案" class="headerlink" title="内存管理方案"></a>内存管理方案</h4><ul>
<li>一个进程进入内存中连续的一块区域<ul>
<li>单一连续区<ul>
<li>一段时间内只有一个进程在内存</li>
<li>简单，内存利用率低</li>
</ul>
</li>
<li>固定分区<ul>
<li>把内存空间分割成若干区域，称为分区；每个分区的大小可以相同也可以不同</li>
<li>分区大小固定不变</li>
<li>每个分区装一个且只能装一个进程</li>
<li>在运行时进程大小会增长<ul>
<li>该进程与一个空闲区相邻：把该空闲区分配给它</li>
<li>与该进程相邻的是另一个进程：把该进程移到内存的另一个足够大的分区，把其他进程交换出去</li>
<li>若进程不能在内存上增长，并且磁盘上的交换区也已经满了：进程只有等待或被杀死</li>
</ul>
</li>
</ul>
</li>
<li>可变分区<ul>
<li><strong>根据进程的需要</strong>，把内存空闲空间分割出一个分区，分配给该进程；剩余部分分成为新的空闲区</li>
<li>产生外碎片（进程之间的空闲区），导致内存利用率下降</li>
</ul>
</li>
</ul>
</li>
<li><p>一个进程进入内存中若干不连续的区域</p>
<ul>
<li><p>页式（现代大多数计算机支持</p>
<ul>
<li><p><strong>用户进程地址空间</strong>被划分为<strong>大小相等</strong>的部分，称为页或页面，从0开始编号</p>
</li>
<li><p><strong>内存空间</strong>按同样大小划分为<strong>大小相等</strong>的区域，称为页框，从0开始编号；也称为物理页面，页帧，内存块</p>
</li>
<li><p>内存分配规则</p>
<ul>
<li>以页为单位进行分配，并按进程需要的页数来分配</li>
<li>逻辑上相邻的页，物理上不一定相邻</li>
</ul>
</li>
<li><p>逻辑地址：<strong>页号+页内地址（偏移）</strong></p>
</li>
<li><p>每个程序都有自己的地址空间，它被分成页；<em>每个页面都是连续的地址范围</em>；这些页面映射到物理内存，但并非所有页面都必须在物理内存中才能运行程序；分页允许程序分配不连续的内存块</p>
</li>
<li><p>将虚拟地址映射为物理地址的一般过程为：（类似于计组的直接映射方式）</p>
<ul>
<li>把虚拟地址划分为两部分：页面号+页内偏移</li>
<li>以页面号为索引查找页表，找到该页面对应的页帧号</li>
<li>用页帧号替换虚拟地址中的页面号，得到物理地址</li>
<li>若给定一个虚拟地址空间中的地址为A，页面的大小为L，则页号P和页内偏移量offset可按下式求得： <ul>
<li>$P=INT[\frac{A}{L}]\ offset=A\ mod\ L$</li>
</ul>
</li>
</ul>
<p>页和页帧通常具有相同的大小</p>
</li>
<li><p><strong>页表</strong>：记录进程的逻辑地址到物理地址的映射关系</p>
<ul>
<li>每一行叫做<strong>页表项</strong>，页表项记录了逻辑页号与页框号的对应关系</li>
<li>每个进程<strong>一个页表</strong>，存放在<strong>内存</strong></li>
<li>在进程上CPU的时候，页表的起始地址存放CPU中的一个控制寄存器，叫做<strong>页表基址寄存器</strong>（pagetablebaseregister,<strong>PTBR</strong>）</li>
<li>在进程未上CPU的时候，页表的起始地址存放在<strong>进程控制块</strong>中</li>
<li>地址转换（硬件支持）：CPU取到逻辑地址，<strong>自动划分</strong>为页号和页内地址；用<strong>页号查页表</strong>，得到<strong>页框号</strong>，再与页内偏移拼接成物理地址</li>
</ul>
</li>
<li><p>会产生内碎片</p>
</li>
</ul>
</li>
<li>段式<ul>
<li><strong>用户进程地址空间</strong>按程序<strong>自身的逻辑关系</strong>划分为若干程序段，每个程序段都有一个段名</li>
<li>内存空间被动态划分为若干<strong>长度不相同</strong>的区域，称为物理段，<strong>每个物理段由起始地址和长度确定</strong></li>
<li>内存分配原则<ul>
<li>以段为单位进行分配</li>
<li><strong>每段</strong>在内存中占据<strong>连续空间</strong></li>
<li>但<strong>段之间</strong>可以<strong>不相邻</strong></li>
</ul>
</li>
<li>逻辑地址：<strong>段号+段内地址</strong>（不是自动划分的，必须显示给出）</li>
<li>段表：记录段逻辑地址到物理地址的映射关系<ul>
<li>每项记录了段号、段首地址和段长度的关系</li>
<li>每个进程<strong>一个段表</strong>，存放在<strong>内存</strong></li>
<li>在进程上CPU的时候，段表起始地址放在段表基址寄存器</li>
<li>在进程未上CPU的时候，页表的起始地址存放在<strong>进程控制块</strong>中</li>
<li>地址转换（硬件支持）：CPU取到逻辑地址；用段号查段表，<strong>得到该段所在的起始地址</strong>，与段内偏移计算出物理地址</li>
</ul>
</li>
<li>每个段由线性地址序列组成</li>
<li>不同的段可以并且通常具有不同的长度</li>
<li>不同的段可以独立地增长或缩小，而不会相互影响</li>
<li>逻辑实体</li>
</ul>
</li>
<li>段页式<ul>
<li><strong>用户进程地址空间</strong>：先按段划分，每一段再按页面划分</li>
<li>内存空间划分<strong>同页式存储管理方案</strong></li>
<li>内存分配原则：<strong>同页为单位进行分配</strong></li>
<li>逻辑地址：<strong>段号+段内地址（页号+页内地址）</strong>【段内地址<strong>自动划分</strong>为页号+页内地址）</li>
<li>段表：记录了每一段的页表始址和页表的长度；<strong>每一段有一张页表</strong></li>
<li>页表：记录了逻辑页号与页框号的对应关系；<strong>一个进程有多个页表</strong>（一个进程分在不同段）</li>
<li>段页式存储管理的基本思想：用<strong>分段方法</strong>来分配和管理<strong>虚拟存储器</strong>（逻辑存储空间），即对虚拟空间采用段式划分，把虚拟地址空间划分为若干段；按照<strong>内存分页</strong>的大小，把每一段划分成若干相等的页（管理物理存储空间）</li>
<li>段页式存储管理结合了分段和分页的优点：<ul>
<li>统一的页面大小、在只使用段的一部分时不用把整个段全部调入内存（分页的优点）</li>
<li>易于编程、模块化、保护和共享（分段的优点）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>碎片：</strong></p>
<ul>
<li>很小的、不易利用的空闲区</li>
<li>导致内存利用率下降</li>
<li>解决方案：<strong>紧缩compaction</strong>技术<ul>
<li>在内存移动程序，将所有小的空闲区合并为较大的空闲区</li>
<li>需要考虑：系统开销，移动时机</li>
</ul>
</li>
</ul>
<h4 id="内存“扩充”技术"><a href="#内存“扩充”技术" class="headerlink" title="内存“扩充”技术"></a>内存“扩充”技术</h4><p>解决在较小的内存空间运行较大的进程</p>
<h5 id="内存紧缩技术（例如：可变分区）"><a href="#内存紧缩技术（例如：可变分区）" class="headerlink" title="内存紧缩技术（例如：可变分区）"></a>内存紧缩技术（例如：可变分区）</h5><p>将空闲区向下，就大概是上面都是占用的，下面都是空闲的，但是会耗费大量的CPU时间</p>
<h5 id="覆盖技术-overlaying"><a href="#覆盖技术-overlaying" class="headerlink" title="覆盖技术 overlaying"></a>覆盖技术 overlaying</h5><p>主要用于早期的操作系统</p>
<ul>
<li>按照其自身的逻辑结构，将<strong>不会同时执行</strong>的程序段共享同一块内存区域；要求程序各模块之间有明确的调用结构</li>
<li>程序员<strong>声明</strong>覆盖结构，操作系统完成自动覆盖</li>
<li>缺点：把程序分割成多个片断的工作必须由程序员来完成。</li>
<li>对用户不透明，增加了用户负担</li>
</ul>
<h5 id="交-对换技术-swapping"><a href="#交-对换技术-swapping" class="headerlink" title="交/对换技术 swapping"></a>交/对换技术 swapping</h5><ul>
<li>内存空间紧张时，系统将内存中某些进程<strong>暂时移到外存</strong>，把外存中某些进程换进内存，占据前者所占用的区域（<strong>进程在内存与磁盘之间的动态调度</strong>）</li>
<li>交换的内容：运行时创建或修改的内容（堆和栈）【对于代码块这些没有改变的，磁盘上已经有了，不需要再保存到磁盘上了】</li>
<li><strong>交换分区</strong>：一般系统会<strong>指定</strong>一块特殊的磁盘区域作为交换区，包括连续的磁道，操作系统可以使用<strong>底层的磁盘读写操作</strong>对其<strong>高效</strong>访问</li>
<li>何时换出：不用就换出（很少再用）；内存空间不够或有不够的危险时换出；与调度器结合使用</li>
<li>不应换出处于等待I/O状态的进程</li>
</ul>
<h5 id="虚拟存储技术-virtual-memory"><a href="#虚拟存储技术-virtual-memory" class="headerlink" title="虚拟存储技术 virtual memory"></a>虚拟存储技术 virtual memory</h5><p>当进程运行时，先将<strong>一部分装入内存</strong>，<strong>另一部分暂留在磁盘</strong>，当要执行的指令或访问的数据不在内存时，由<strong>操作系统自动完成</strong>将它们从磁盘调入内存的工作</p>
<h6 id="虚拟内存："><a href="#虚拟内存：" class="headerlink" title="虚拟内存："></a>虚拟内存：</h6><ul>
<li>内存与磁盘的有机结合（从而得到了一个很大的“内存”，构建在存储体系之上，由操作系统协调各存储器的使用）</li>
<li>虚存提供了一个比物理内存空间大的多的地址空间</li>
<li>大小收到计算机的寻址机制和磁盘当中可用空间这两方面的限制</li>
</ul>
<h6 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h6><p>分配给进程的虚拟内存</p>
<h6 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h6><p>在虚拟内存中指令或数据的位置，该位置可以被访问</p>
<h6 id="地址保护（存储保护）"><a href="#地址保护（存储保护）" class="headerlink" title="地址保护（存储保护）"></a>地址保护（存储保护）</h6><ul>
<li>确保每个进程有<strong>独立</strong>的地址空间</li>
<li>确保进程访问合法的<strong>地址范围</strong>（防止地址越界）</li>
<li>确保进程的<strong>操作</strong>是合法的（防止访问越权）</li>
</ul>
<h5 id="虚拟页式存储管理系统（PAGING）"><a href="#虚拟页式存储管理系统（PAGING）" class="headerlink" title="虚拟页式存储管理系统（PAGING）"></a><strong>虚拟页式存储管理系统（PAGING）</strong></h5><p>虚拟页式存储管理系统=虚拟存储技术+页式存储管理方案</p>
<p>以CPU时间和磁盘的空间换取昂贵内存空间（是操作系统中的资源转换技术）</p>
<h6 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h6><ul>
<li>进程开始运行之前，<strong>不是装入全部页面</strong>，而是<strong>装入一个或零个页面</strong></li>
<li>根据进程运行的需要，<strong>动态装入</strong>其他页面</li>
<li>当内存空间已满，而又需要装入新的页面时，则根据某种算法<strong>置换内存</strong>中的某个<strong>页面</strong>，以便装入新的页面</li>
</ul>
<h6 id="两种方式"><a href="#两种方式" class="headerlink" title="两种方式"></a>两种方式</h6><ul>
<li>请求调页（主要的）</li>
<li>预先调页（预测//缺页异常调入的时候，顺带调入相关的一些页）</li>
</ul>
<h6 id="页表及页表项"><a href="#页表及页表项" class="headerlink" title="页表及页表项"></a>页表及页表项</h6><p>页表由页表项组成（页表项一般由硬件设计）</p>
<p>每个进程一张页表</p>
<p>包括：</p>
<ul>
<li>页框号（内存块号、物理页号、页帧号）</li>
<li>有效位（驻留位、中断位）P：表示该页是在内存还是磁盘【页框号是否有效</li>
<li>访问位A：<strong>引用位</strong></li>
<li>修改位D(dirty)：（修改的话，还要写回磁盘），硬件来支持的</li>
<li>保护位：读/可读写 R/W，访问权限（用户组什么的）</li>
<li>缓存禁用位：此功能对于映射到设备寄存器而非内存的页面非常重要</li>
<li>……</li>
</ul>
<p><em>若某个页面不在内存时，用于保存该页面的磁盘地址不是页表的一部分</em></p>
<blockquote>
<p>32位虚拟地址空间（假设页面大小为4K；页表项大小为4字节，则：</p>
<p>一个进程地址空间有2^32/(4*2^10)=2^20页</p>
<p>其页表需要占2^20*4/(4K)=2^10=1024页</p>
</blockquote>
<p>存在的问题：</p>
<ul>
<li>从虚拟地址到物理地址的映射必须快速</li>
<li>解决方案1：把整个页表放在内存中，因执行过程中多次访问页表，导致效率较低；但实际中采用这种方案，基于大多数程序倾向于对少量页面进行大量引用的情况</li>
<li>解决方案2：使用一组快速硬件寄存器组成的单个页表，虚拟页面号作为索引，每个虚拟页面一个表项。<br>在一个进程启动时，操作系统把位于主存中的进程的页表装入寄存器，在进程运行期间不必因为页表而访问内存，造价昂贵，尤其是页表很大时</li>
<li>如果虚拟地址空间很大，则页表也会很大</li>
</ul>
<p>页表页在内存中若<strong>不连续存放</strong>，则需要引入页表页的地址索引表：<strong>页目录</strong></p>
<ul>
<li>二级页表结构<ul>
<li>页目录-&gt;页表-&gt;页框号-&gt;物理地址</li>
<li>虚拟地址 <code>页目录偏移 页表偏移 页内偏移</code></li>
<li>二级页表可以表示4G的虚拟地址空间（32位计算机）</li>
</ul>
</li>
<li>多级页表结构<ul>
<li>访问多次内存，n级n次，CPU的指令处理速度与内存指令的访问速度差异大，导致CPU的速度得不到充分利用</li>
</ul>
</li>
</ul>
<p><strong>反转（倒排）页表</strong></p>
<p>很多进程没有对应的物理地址，用地址转换的页表<strong>占用内存太大</strong>，所以从物理地址空间出发，页表项记录进程i的某虚拟地址（虚页号）与页框号的映射关系；所以<strong>整个系统一张页表</strong></p>
<p>反转页表大小与实际内存成固定比例，<strong>与进程数无关</strong>；</p>
<p>存在的问题：</p>
<ul>
<li><strong>虚拟地址转换成物理地址的时候</strong>，则要查找整个页表（消耗过大）；<ul>
<li>解决方法：运用hash列表，通过拉链解决hash中的冲突问题虚拟地址到物理地址的转换变得困难得多。</li>
</ul>
</li>
<li>对每一次内存引用，都要搜索倒排页表</li>
</ul>
<h6 id="快表TLB-Translation-Look-aside-Buffers"><a href="#快表TLB-Translation-Look-aside-Buffers" class="headerlink" title="快表TLB(Translation Look-aside Buffers)"></a>快表TLB(Translation Look-aside Buffers)</h6><p><strong>转换检测缓冲区或者相联存储器（associative memory按内容并行查找）或者快表</strong></p>
<p>TLB即translation look-aside Buffers转换检测缓冲区，是一个小型的硬件设备，<strong>将虚拟地址直接映射到物理地址</strong>，不必再访问页表。它通常<strong>存在MMU中</strong>，包含<strong>少量的表项</strong>，每个表项<strong>记录了一个页面的相关信息</strong>，包括虚拟页号、页面的修改位、保护码（读/写/执行权限）和该页所对应的物理页框。它是一个<strong>内存管理单元</strong>用于改进<strong>虚拟地址到物理地址转换速度的缓存</strong>，它的管理和失效处理由MMU硬件实现</p>
<p><strong>为了解决多级页表需要访问多次内存的情况</strong>，根据<strong>程序访问的局部性原理而引入快表</strong></p>
<p>快表：在CPU中引入的高速缓存（cache），可以匹配CPU的处理速度和内存的访问速度，一种随机存取型存储器</p>
<p>快表的空间是<strong>有限的</strong>（并且由于成本大，空间小），它通常位于MMU内部，一般保存正在运行进程的页表的子集（部分页表项），条目很少</p>
<p>过程：先找TLB，找到TLB hit；否则TLB miss，接着查找页表，如果页面还没有读入内存，产生异常page fault，进入操作系统，需要从磁盘中调入，再……从TLB中淘汰一个表项，然后用新找到的页表表项替换它</p>
<p>上述<strong>TLB管理和处理TLB失效</strong>都完全是由<strong>MMU硬件</strong>来实现的，但是现代的许多RISC机器，几乎完全采用软<strong>件页面管理</strong></p>
<p>切换进程后，TLB会被清空</p>
<h6 id="页错误Page-Fault"><a href="#页错误Page-Fault" class="headerlink" title="页错误Page Fault"></a>页错误Page Fault</h6><p>又称 页面错误、页故障、<strong>页面失效</strong>，是地址转换过程中<strong>硬件产生的异常</strong></p>
<p>具体原因：</p>
<ul>
<li>所访问的虚拟页面没有调入物理内存——缺页异常<ul>
<li>在地址映射过程中，<strong>硬件检查页表时</strong>发现所要访问的页面不在内存，则产生该异常</li>
<li><strong>操作系统执行缺页异常处理程序</strong>：获得磁盘地址，启动磁盘，将该页调入内存<ul>
<li>如果内存中有空闲页框，则<strong>分配</strong>一个页框，将新调入页装入，并<strong>修改</strong>页表中相应页表项的<strong>有效位及相应的页框号</strong></li>
<li>若内存中没有空闲页框，则要<strong>置换</strong>内存中某一页框；若该页框内容<strong>被修改过</strong>，则要将其<strong>写回磁盘</strong></li>
</ul>
</li>
</ul>
</li>
<li>页面访问违反权限（读/写、用户/内核）</li>
<li>错误的访问地址</li>
<li>……</li>
</ul>
<p>处理：</p>
<ol>
<li>硬件陷入内核，<strong>在堆栈中保存程序计数器</strong></li>
<li>启动一个汇编代码例程，<strong>保存通用寄存器和其他易失的信息</strong>，以免被操作系统破坏</li>
<li>当操作系统发现一个页面失效时，试图查找<strong>需要哪个虚拟页面</strong></li>
<li>操作系统检查<strong>发生页面失效的虚拟地址是否有效</strong>，并检查<strong>存取与保护是否一致</strong></li>
<li>如果选择的是<strong>“脏”页帧</strong>，安排将该页面<strong>写回磁盘</strong></li>
<li>一旦页帧“干净”后，操作系统查找所需页面在磁盘上的地址，<strong>通过磁盘操作将其装入</strong></li>
<li>当磁盘<strong>中断发生</strong>，表明该页面已经装入时，页表也已更新以反映它的位置，页帧也标记为通常的状态</li>
<li><strong>恢复</strong>发生页面失效指令以前的<strong>状态</strong>，<strong>程序计数器</strong>重新指向这条指令</li>
<li><strong>调度页面失效进程</strong>，操作系统返回调用它的汇编语言例程</li>
<li>该例程<strong>恢复寄存器和其他状态信息</strong>，回到用户空间继续执行</li>
</ol>
<h6 id="驻留集"><a href="#驻留集" class="headerlink" title="驻留集"></a>驻留集</h6><p>操作系统分配给进程的页框数</p>
<ul>
<li>固定分配策略（进程创建时确定，根据进程类型或者程序员需要来设定）</li>
<li>可变分配策略（根据缺页率评估进程局部性表现+系统开销）</li>
</ul>
<h6 id="置换问题"><a href="#置换问题" class="headerlink" title="置换问题"></a>置换问题</h6><p>置换范围：</p>
<ul>
<li>局部置换策略（仅在产生本次缺页的进程的驻留集中选择）<ul>
<li>可以有效地为每个进程分配固定的内存片段</li>
</ul>
</li>
<li>全局置换策略（将内存中所有未锁定的页框都作为置换的候选）<ul>
<li>在可运行的进程之间动态的分配页框，因此分配给各个进程的页框数是随时间变化的</li>
</ul>
</li>
</ul>
<p><strong>置换策略：</strong>（基于过去的行为来预测将来的行为）</p>
<p>【置换策略设计得越精致、越复杂，实现的软硬件开销就越大】</p>
<p><strong>页框锁定</strong>：避免产生由交换过程带来的不确定的延迟</p>
<p>例如：操作系统核心代码、关键数据结构、I/O缓冲区</p>
<p><strong>清除策略：</strong>从进程的驻留集中收回页框</p>
<p>因为，虚拟页式系统工作的<strong>最佳状态</strong>：发生缺页异常时，系统中有大量的空闲页框</p>
<p>所以，在系统中<strong>保存一定数目的空闲页框供给</strong>比使用所有内存并在需要时搜索一个页框有更好的性能</p>
<p><strong>分页守护进程：</strong>多数时间睡眠，可定期唤醒以检查内存的状态</p>
<p>如果空闲页框过少，分页守护进程通过预定的页面置换算法选择页面换出内存；如果页面装入内存后被修改过，则将它们写回磁盘分页守护进程可保证所有的空闲页框是“干净”的。</p>
<p><strong>页缓冲技术</strong></p>
<p>当进程未结束，需要使用一个已置换出的页框时，如果页框还没有被新的内容覆盖，将它从空闲页框集合中移出即可恢复该页面</p>
<p>不丢弃置换出的页，将它们放入两个表之一（根据是否修改）；被修改的页定期写回磁盘（一批一批的写，而不是一次只写一个，减少了I/O操作的数量，从而减少了磁盘访问时间）</p>
<p>被置换的页仍然保留在内存中，一旦进程又要访问该页，可以迅速将它加入该进程的驻留集合（代价很小）</p>
<h4 id="影响缺页次数的因素"><a href="#影响缺页次数的因素" class="headerlink" title="影响缺页次数的因素"></a>影响缺页次数的因素</h4><ul>
<li>页面置换算法</li>
<li>页面本身的大小<ul>
<li>小页面大小<ul>
<li>优点<ul>
<li>内部碎片少（内部碎片）</li>
<li>更适合各种数据结构，代码部分</li>
<li>内存中少没用的程序</li>
</ul>
</li>
<li>坏处<ul>
<li>程序需要很多页面，更大的页面表</li>
</ul>
</li>
</ul>
</li>
<li>内部碎片</li>
<li>页表长度</li>
<li>辅存的物理特性</li>
<li>最优页面大小$P=\sqrt{2se}$，其中s是进程的平均规模，e是页表项的长度</li>
<li>开销overhead<ul>
<li>$overhead=\frac{s*e}{p}+{\frac p 2}$</li>
<li>s : average process size in bytes进程平均大小为s个字节</li>
<li>p : page size in bytes页面大小为p个字节</li>
<li>e : page entry每个页表项需要e个字节</li>
<li>前面一项是页表的开销，后面是内部碎片的开销</li>
</ul>
</li>
</ul>
</li>
<li>程序的编制方法<ul>
<li>例如按行按列分配的时候，按列分配，每次这一行都要重新缺页</li>
</ul>
</li>
<li>分配给进程的页框数量</li>
</ul>
<p><strong>颠簸（Thrashing，抖动）</strong>：虚存中，页面在内存与磁盘之间频繁调度，<strong>使得调度页面所需的时间比进程实际运行的时间还多</strong>，这样导致系统效率急剧下降，这种现象称为颠簸或抖动</p>
<h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><p>There are four times when the OS has paging-related work to do:</p>
<ul>
<li>Process creation time进程创建</li>
<li>Process execution time进程执行</li>
<li>Page fault页错误</li>
<li>Process termination time进程终止</li>
</ul>
<h5 id="OPT最佳页面置换算法"><a href="#OPT最佳页面置换算法" class="headerlink" title="OPT最佳页面置换算法"></a>OPT最佳页面置换算法</h5><p>置换以后不再需要的或最远的将来才会用到的页面</p>
<p>不可实现的，但是可以作为一种标准来衡量其他算法的性能</p>
<h5 id="FIFO先进先出算法"><a href="#FIFO先进先出算法" class="headerlink" title="FIFO先进先出算法"></a>FIFO先进先出算法</h5><p>选择在内存中驻留时间最长的页并置换它</p>
<p>实现：页面链表法</p>
<p>缺点：内存中驻留时间最长的页可能经常使用</p>
<h6 id="BELADY现象"><a href="#BELADY现象" class="headerlink" title="BELADY现象"></a>BELADY现象</h6><p>FIFO页面置换算法会产生异常现象（Belady现象），即：<strong>当分配给进程的物理页面数增加时，缺页次数反而增加</strong></p>
<h5 id="SCR-Second-Chance第二次机会算法"><a href="#SCR-Second-Chance第二次机会算法" class="headerlink" title="SCR-Second Chance第二次机会算法"></a>SCR-Second Chance第二次机会算法</h5><p>按照先进先出算法选择某一页面，检查其访问位R，如果为0，则置换该页；如果为1，则给第二次机会，并将访问位置0</p>
<p>摘链，挂链都需要开销</p>
<h6 id="CLOCK时钟算法实现"><a href="#CLOCK时钟算法实现" class="headerlink" title="CLOCK时钟算法实现"></a>CLOCK时钟算法实现</h6><p>通过移动指针来选择下一个页面</p>
<h5 id="NRU-Not-Recently-Used最近未使用算法"><a href="#NRU-Not-Recently-Used最近未使用算法" class="headerlink" title="NRU-Not Recently Used最近未使用算法"></a>NRU-Not Recently Used最近未使用算法</h5><p>选择在<strong>最近一段时间内未使用</strong>过的一页并置换</p>
<p>实现：设置页表表项的两位（<strong>访问位R，修改位M</strong>）</p>
<p>R位被定期清零（复位），初始均为0；</p>
<p>第一类：无访问，无修改</p>
<p><strong>第二类：无访问，有修改</strong></p>
<p><strong>第三类：有访问，无修改</strong></p>
<p>第四类：有访问，有修改</p>
<p>随机从编号最小的非空类中选择一页置换</p>
<h6 id="CLOCK时钟算法实现-1"><a href="#CLOCK时钟算法实现-1" class="headerlink" title="CLOCK时钟算法实现"></a>CLOCK时钟算法实现</h6><p>通过移动指针来选择下一个页面</p>
<h5 id="LRU-Least-Recently-Used最近最少使用算法"><a href="#LRU-Least-Recently-Used最近最少使用算法" class="headerlink" title="LRU-Least Recently Used最近最少使用算法"></a>LRU-Least Recently Used最近最少使用算法</h5><p>选择最后一次访问时间距离当前时间最长的一页并置换</p>
<p>即置换<strong>未使用时间最长</strong>的一页</p>
<p><strong>性能接近OPT</strong></p>
<p>实现：时间戳或维护一个访问页的栈——开销大</p>
<p>​    先行置1，再列置0，最后置换的时候看哪一行最小</p>
<h6 id="NFU-Not-Frequently-Used最不经常使用算法"><a href="#NFU-Not-Frequently-Used最不经常使用算法" class="headerlink" title="NFU-Not Frequently Used最不经常使用算法"></a>NFU-Not Frequently Used最不经常使用算法</h6><p>选择访问次数最小的页面置换</p>
<p>LRU的一种软件解决方案</p>
<p>实现：</p>
<ul>
<li>软件计数器，一页一个，初值为0</li>
<li><strong>每次时钟中断时，计数器加R</strong></li>
<li>发生缺页中断时，<strong>选择计数器值最小的一页置换</strong></li>
</ul>
<h6 id="AGING老化算法"><a href="#AGING老化算法" class="headerlink" title="AGING老化算法"></a>AGING老化算法</h6><p>改进LRU</p>
<p>计数器在加R前<strong>先右移一位</strong>，R位<strong>加到</strong>计数器的<strong>最左端</strong></p>
<p>选择，最小的一个置换出去</p>
<h5 id="工作集算法"><a href="#工作集算法" class="headerlink" title="工作集算法"></a>工作集算法</h5><p>开销大，但是很多操作系统采用了这种算法</p>
<p>根据<strong>程序的局部性原理</strong>，一般情况下，进程在一段时间内总是集中访问一些页面，这些也页面称为<strong>活跃页面</strong>，如果分配给一个进程的物理页面数太小了，使该进程所需的活跃页面不能全部装入内存，则该进程在运行过程中将频繁发生中断</p>
<p><strong>程序的局部性原理：</strong></p>
<p>程序在一段时间内访问相对小的一段地址空间；虚拟内存基于程序的局部性原理而设计的；程序的局部性原理是指程序在执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域</p>
<p><strong>工作集：</strong>一个进程当前正在使用的页框集合</p>
<p>工作集$W(t,\Delta)=$该进程在过去的$\Delta$个虚拟时间单位中访问到的页面的集合</p>
<p>内容取决于三个因素：</p>
<ul>
<li>访页序列特性</li>
<li>时刻t</li>
<li>工作集窗口长度（$\Delta$），窗口越大，工作集就越大</li>
</ul>
<p><strong>基本思路：</strong>找出一个不在工作集中的页面并置换它</p>
<ul>
<li>每个页表项中有一个字段：记录该页面最后一次被访问的时间</li>
<li>设置一个时间值T</li>
<li>判断：根据一个页面的访问时间是否落在“当前时间-T”之前或之中决定其在工作集之外还是之内</li>
</ul>
<p><strong>实现：</strong>扫描所有页表项，执行操作</p>
<ol>
<li><p>如果一个页面的R位是1，则将该页面的最后一次访问时间设为当前时间，将R位清零</p>
</li>
<li><p>如果一个页面的R位是0，则检查该页面的访问时间是否在“当前时间-T”之前</p>
<p>(1) 如果是，则该页面为被置换的页面</p>
<p>(2) 如果不是，记录当前所有被扫描过页面的最后访问时间里面的最小值。扫描下一个页面并重复1、2</p>
</li>
</ol>
<p><img src="/2018/12/08/操作系统-笔记/页面置换算法.png" alt=""></p>
<p>fairly crude approximates相当粗略的近似</p>
<h4 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h4><p>基本思想：进程通过一个系统调用（比如：linux中mmap）将一个文件（或部分）<strong>映射</strong>到其虚拟地址空间的一部分，访问这个文件<strong>就像访问内存中的一个大数组</strong>，而不是对文件进行读写</p>
<p>在多数实现中，在映射共享的页面时不会实际读入页面的内容，而是<strong>在访问页面时</strong>，页面才会被每次一页的读入，磁盘文件则被当作后备存储</p>
<p>当进程<strong>退出</strong>或显式地<strong>解除文件映射</strong>时，<strong>所有被修改页面会写回文件</strong></p>
<h4 id="写时复制技术"><a href="#写时复制技术" class="headerlink" title="写时复制技术"></a>写时复制技术</h4><p>比如：linux中，在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，<strong>两者的虚拟空间不同，但其对应的物理空间是同一个</strong>。</p>
<p>当父子进程中有<strong>更改相应段的行为发生时</strong>，<strong>再为</strong>子进程相应的段<strong>分配物理空间</strong>，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。    </p>
<h3 id="quiz-7-错题和模糊题"><a href="#quiz-7-错题和模糊题" class="headerlink" title="quiz 7 错题和模糊题"></a>quiz 7 错题和模糊题</h3><p>选择4 </p>
<p><img src="/2018/12/08/操作系统-笔记/quiz7.1.png" alt=""></p>
<p>选择1 2 4 5</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz7.2.png" alt=""></p>
<h3 id="quiz-8-错题和模糊题"><a href="#quiz-8-错题和模糊题" class="headerlink" title="quiz 8 错题和模糊题"></a>quiz 8 错题和模糊题</h3><p>正确</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz8.1.png" alt=""></p>
<p>应选择1</p>
<p>页面大小= 4KB = 2^12B ，则页内偏移=12位</p>
<p>一页可存放页表项个数 = 4KB / 4B = 1024 = 2^10</p>
<p>采用三级页表，则虚页号 = (2^10)<em> (2^10)</em> (2^10)  = 2^30</p>
<p>虚拟地址 = (2^30) * (2^12) = 2^42</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz8.2.png" alt=""></p>
<p>应选择4</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz8.3.png" alt=""></p>
<p>应选择3</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz8.4.png" alt=""></p>
<ol>
<li>正确 14. 应选择1 2 3 5</li>
</ol>
<p><img src="/2018/12/08/操作系统-笔记/quiz8.5.png" alt=""></p>
<p>应如图选择</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz8.6.png" alt=""></p>
<p><img src="/2018/12/08/操作系统-笔记/quiz8.7.png" alt=""></p>
<h3 id="PPT练习题-2"><a href="#PPT练习题-2" class="headerlink" title="PPT练习题"></a>PPT练习题</h3><ol>
<li><p>Consider the following page-request string in Demand Paging system:<br>1,2,3,4,5,3,4,1,6,7,8,7,6,3,2,1,2,3,6<br>  How many page faults would occur for the following replacement algorithms, assuming four frames? Remember that all frames are initially empty, so your first unique pages will all cost one fault each.<br> (1) LRU replacement<br> (2) Optimal replacement</p>
<p>分析：12，10</p>
</li>
<li><p>设某进程的执行过程中有以下的页面号引用串（页面走向）：4, 3, 2, 1, 4, 3, 5, 4, 3, 2, 1, 5</p>
<pre><code>  （1）当为进程分配3个页帧时，分别给出采用OPT（最优页面置换）、FIFO、LRU算法时的页面置换过程。
  （2）当为进程分配4个页帧时，分别给出采用FIFO、LRU算法时的页面置换过程
</code></pre><p>分析：7、9、10、10、8</p>
</li>
<li><p>如果某进程使用5个虚拟页面（编号从0到4），页面访问次序为012301401234。采用FIFO页面置换算法，在分配4个页帧和3个页帧时，分别会产生多少次页面失效。假设初始时页帧是空的</p>
<p>分析：10，9</p>
</li>
<li><p>Consider a swapping system in which memory consists of the following hole size in memory order: 10KB, 4KB, 20KB, 18KB, 7KB, 9KB, 12KB, and 15KB. Which hole is taken for successive segment requests of 12KB, 10KB, 9KB for first fit? Now repeat for best fit, worst fit and next fit</p>
<p>分析：20，10，18；12，10，9；20，18，15；20，18，9</p>
</li>
<li><p>对于下面的每个十进制虚拟地址，分别使用4KB和8KB的页面计算机虚拟页号和偏移量：20000, 32768, 60000</p>
<p>分析：</p>
<p>|          |   4    |   KB   |   8    | KB     |<br>| ———— | :——: | :——: | :——: | ——— |<br>| 虚拟地址 | 页面号 | 偏移量 | 页面号 | 偏移量 |<br>| 20000    |   4    |  3616  |   2    | 3616   |<br>| 32768    |   8    |   0    |   4    | 0      |<br>| 60000    |   14   |  2656  |   7    | 2656   |</p>
</li>
<li><p>一个32位地址的计算机使用两级页表。虚拟地址被分成9位的顶级页表域、11位的二级页表域和一个偏移量，页面大小是多少？在地址空间中一共有多少个页面？</p>
<p>分析：32-9-11=12位，所以页面大小4KB；2^9*2^11=2^20个页面</p>
</li>
<li><p>一个计算机有4个页帧，装入时间、上次访问时间和每个页面的R位和M位如下表所示（时间以时钟滴答为单位）</p>
<p><img src="/2018/12/08/操作系统-笔记/练习题8.7.png" alt=""></p>
<p>(1) NRU算法将置换哪个页面？<br>(2) FIFO算法将置换哪个页面？<br>(3) LRU算法将置换哪个页面？<br>(4) 第二次机会算法将置换哪个页面？</p>
<p>2；3；1；2</p>
<p><img src="/2018/12/08/操作系统-笔记/练习题8.7.2.png" alt=""></p>
</li>
<li><p><img src="/2018/12/08/操作系统-笔记/练习题8.8.png" alt=""></p>
<p>首先计算20：页面号0，偏移量20；4100：页面号1，偏移量4；8300：页面号2，偏移量108</p>
<p>根据映射，知道0对应2，所以物理地址是8k+20=8212；1对应1，所以物理地址是4k+4=4100；2对应6，所以物理地址是24k+108=24684</p>
</li>
</ol>
<h2 id="文件系统-1"><a href="#文件系统-1" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件是对磁盘的抽象（进程是对CPU的抽象，地址空间是对内存的抽象）</p>
<p><strong>文件：</strong> 一组带标识的（标识即为文件名）、在逻辑上有完整意义的信息项的序列</p>
<p><strong>信息项：</strong>构成文件内容的基本单位（单个字节或多个字节），各信息项之间具有顺序关系</p>
<p><strong>分类：</strong></p>
<ul>
<li>普通文件<ul>
<li>用户建立的</li>
<li>包含了用户的信息，一般为ASCII或二进制文件</li>
</ul>
</li>
<li>目录文件<ul>
<li>操作系统建立的</li>
<li>为了管理文件系统的系统文件</li>
</ul>
</li>
<li>特殊文件（设备文件）<ul>
<li>字符设备文件：<strong>和输入输出有关</strong>，用于模仿串行I/O设备，例如终端，打印机，网卡等</li>
<li>块设备文件：磁盘（若干个字节来进行检索和传输）</li>
</ul>
</li>
<li>管道文件</li>
<li>套接字</li>
</ul>
<p><strong>文件逻辑结构：</strong></p>
<p>从用户角度看文件，由用户的访问方式确定</p>
<ul>
<li>流式文件<ul>
<li>构成文件的基本单位是字符</li>
<li>文件是有逻辑意义、无结构的一串字符的集合</li>
<li>只可以一个一个读，一个一个写</li>
</ul>
</li>
<li>记录式文件（例如目录文件）<ul>
<li>文件由<strong>若干个记录</strong>组成，可以按记录进行读、写、查找等操作</li>
<li>每条记录有其内部结构</li>
</ul>
</li>
</ul>
<p><strong>文件存取：</strong></p>
<ul>
<li>顺序存取（访问）</li>
<li>随机存取（访问）<ul>
<li>提供读写位置（当前位置）<ul>
<li>例如unix的seek操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="文件的存储介质"><a href="#文件的存储介质" class="headerlink" title="文件的存储介质"></a>文件的存储介质</h4><ul>
<li><p>磁盘（包括固态盘SSD）</p>
<ul>
<li>磁盘的物理块号与磁盘地址可以相互转换</li>
<li>读写磁头：一个盘面一个<ul>
<li>任何时刻只有一个磁头处于活动状态：输入输出数据流以位串形式出现</li>
</ul>
</li>
<li>盘面上的<strong>同心圆</strong>：磁道</li>
<li>扇区：磁道划分成很多段；信息存放在扇区里<ul>
<li>标题+数据<strong>（通常512字节）</strong>+ECC纠错信息</li>
<li>坏扇区<ul>
<li>在控制器中处理它们<ul>
<li>最后加入用备用品代替坏道</li>
<li>转移所有扇区（避开坏块），在坏块之后加入备用品</li>
</ul>
</li>
<li>在操作系统中处理它们</li>
<li>如果操作系统正在处理重映射，则必须确保在任何文件中都不会出现坏扇区，并且也不会在空闲列表或位图中出现<ul>
<li>一种方法是创建一个由所有坏扇区组成的秘密文件</li>
</ul>
</li>
<li>如果磁盘是逐个文件备份的，则备份实用程序不要尝试复制坏块文件，这一点很重要</li>
</ul>
</li>
</ul>
</li>
<li>把一个给定的磁盘臂位置上的所有磁道合并起来，组成了一个<strong>柱面</strong>（cylinder）</li>
<li>物理地址：<strong>磁头号（盘面号）、磁道号（柱面号）、扇区号</strong></li>
<li>磁盘访问<ul>
<li>磁盘调度时，首先是移臂调度，然后是旋转调度</li>
<li>一次访盘请求：读/写，磁盘地址（设备号，柱面号，磁头号，扇区号），内存地址（源/目）</li>
<li>三个动作（对于SSD只有最后一个，前面两个不存在）<ul>
<li>寻道（时间）：磁头移动定位到指定<strong>磁道</strong>【一般这个占主要部分】<ul>
<li>大多数硬盘控制器会自动纠正<strong>寻道错误</strong></li>
</ul>
</li>
<li>旋转延迟（时间）：等待指定<strong>扇区</strong>从磁头下旋转经过</li>
<li>数据传输（时间）：<strong>数据</strong>在磁盘与内存之间的实际传输</li>
</ul>
</li>
</ul>
</li>
<li><strong>稳定存储器</strong>使用一对<strong>完全相同</strong>的磁盘，对应的块一同工作以形成一个无差错的块<ul>
<li>当不存在错误时，在两个驱动器上对应的块是相同的</li>
<li>稳定存储器定义了3种操作：<ul>
<li>Stable writes（稳定写）<br> 首先将块写到驱动器1上，然后将其读回以校验写的是正确的。如果不正确，就再次做写和重读操作<br><strong>对驱动器1的写成功之后</strong>，对驱动器2上对应的块进行写和重读</li>
<li>Stable reads（稳定读）<br>首先从驱动器1上读取块。若始终无法正确读取，则从驱动器2上读取对应的块</li>
<li>Crash recovery（崩溃恢复）<br>恢复程序扫描两个磁盘并比较对应的块<br>如果一对块都是好的并且相同，什么都不做<br>如果其中一个有错，用对应的好块来覆盖坏块<br>如果一对块都是好的但不相同，将<strong>驱动器1</strong>上的块写到驱动器2上</li>
</ul>
</li>
</ul>
</li>
<li>磁带</li>
<li>Magnetic Disks<ul>
<li>现代磁盘被划分为区域，外部区域上的扇区多于内部区域</li>
<li>cylinder skew（柱面斜进）在设置低级格式时，每个磁道上第0扇区的位置与前一个磁道存在偏移，让磁盘在一次连续的操作中读取多个磁道而不丢失数据</li>
<li>格式化磁盘时以交错（交错）方式对扇区编号，扇区0包含主引导记录（主引导记录）：一些启动代码，分区表（给出每个分区的起始扇区和大小）；要从硬盘引导，必须在分区表中将一个分区标记为活动</li>
<li>最后一步是准备一个磁盘，用于执行每个分区的高级格式化，设置引导块，空闲存储管理，根目录和一个空文件系统</li>
</ul>
</li>
<li>RAID</li>
<li>CD-ROMs</li>
<li>CD-Recordable</li>
<li>CD-Rewritable</li>
<li>DVD</li>
</ul>
</li>
<li><p>光盘</p>
</li>
<li><p>U盘</p>
</li>
</ul>
<p>物理块（block、cluster）</p>
<ul>
<li>信息存储、传输、分配的独立单位</li>
<li>存储设备划分为大小相等的物理块，统一编号</li>
</ul>
<h3 id="文件系统-2"><a href="#文件系统-2" class="headerlink" title="文件系统"></a>文件系统</h3><p><img src="/2018/12/08/操作系统-笔记/文件系统布局.png" alt=""></p>
<p>操作系统中<strong>统一管理信息资源</strong>的一种软件，管理文件的存<strong>储、检索、更新</strong>，提供安全可靠的<strong>共享和保护</strong>手段，并且<strong>方便用户使用</strong></p>
<ul>
<li>统一管理磁盘空间，实施磁盘空间的分配与回收</li>
<li>实现文件的按名存取：名字空间【映射到】磁盘空间</li>
<li>实现文件信息的共享，并提供文件的保护、保密手段</li>
<li>向用户提供一个方便使用、易于维护的接口，并向用户提供有关统计信息</li>
<li>提高文件系统的性能</li>
<li>提供与I/O系统的统一接口</li>
</ul>
<h4 id="文件控制块FCB"><a href="#文件控制块FCB" class="headerlink" title="文件控制块FCB"></a>文件控制块FCB</h4><p>大小固定的</p>
<p>为管理文件而设置的数据结构，保存管理文件所需要的所有有关信息</p>
<p>文件属性或元数据（即数据的数据）</p>
<p>常用属性：</p>
<p>文件名，文件号，文件大小，文件地址，创建时间，最后修改时间，最后访问时间，各种标志等等</p>
<h4 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h4><ul>
<li>统一管理每个文件的元数据，以支持文件名到文件物理地址的转换</li>
<li>将所有文件的管理信息组织在一起，即构成文件目录</li>
<li>按名存取</li>
</ul>
<p>目录文件：将文件目录以文件的形式存放在磁盘上</p>
<p>目录项：</p>
<ul>
<li>构成文件目录的基本单元</li>
<li>目录项可以是FCB，<strong>目录是文件控制块的有序集合</strong></li>
</ul>
<p>路径名（文件名）：<strong>绝对/相对路径名</strong></p>
<p>当前/工作目录</p>
<ul>
<li>1层目录系统<ul>
<li>优点：简单，能够快速定位文件</li>
<li>坏处：在具有多个用户的系统中，不同用户为自己的文件选择相同的文件名会导致冲突</li>
</ul>
</li>
<li>2层目录系统<ul>
<li>增加了中间的用户层</li>
<li>可以缩短访问文件存储器时间</li>
</ul>
</li>
<li>多层目录系统</li>
</ul>
<h5 id="管理文件目录的系统调用"><a href="#管理文件目录的系统调用" class="headerlink" title="管理文件目录的系统调用"></a>管理文件目录的系统调用</h5><ul>
<li>Create</li>
<li>mDelete</li>
<li>Opendir </li>
<li>Closedir</li>
<li>Readdir</li>
<li>Rename</li>
<li>Link</li>
<li>Uplink</li>
</ul>
<h4 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h4><p>文件在存储介质上的存放方式</p>
<h5 id="顺序（连续）结构"><a href="#顺序（连续）结构" class="headerlink" title="顺序（连续）结构"></a>顺序（连续）结构</h5><p>文件的信息存放在若干连续的物理块中</p>
<p>FCB记录文件的第一块的地址+文件长度</p>
<p><strong>优点：</strong></p>
<ul>
<li>简单</li>
<li>支持顺序存取和随机存取</li>
<li>所需的磁盘寻道次数和寻道时间最少</li>
<li>可以同时读入多个块，检索一个块也很容易</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>文件不能动态增长<ul>
<li>可以通过预留空间（但是会浪费）或重新分配和移动</li>
</ul>
</li>
<li>不利于文件插入和删除（CD-ROM适合这种方法，</li>
<li>外部碎片：紧缩技术</li>
</ul>
<h5 id="链接结构"><a href="#链接结构" class="headerlink" title="链接结构"></a>链接结构</h5><p>一个文件的信息存放在若干不连续的物理块中，各块之间通过指针连接，前一个物理块指向下一个物理块</p>
<p>FCB记录文件的第一块的地址</p>
<p><strong>优点：</strong></p>
<ul>
<li>提高了磁盘空间利用率，不存在外部碎片问题</li>
<li>有利于文件插入和删除</li>
<li>有利于文件动态扩充</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>存取速度慢，不适于随机存取</li>
<li>可靠性问题，如指针出错</li>
<li>更多的寻道次数和寻道时间</li>
<li>链接指针占用一定的空间</li>
</ul>
<h6 id="文件分配表FAT"><a href="#文件分配表FAT" class="headerlink" title="文件分配表FAT"></a>文件分配表FAT</h6><p>变形：将链接指针的内容都存放在FAT中，块中存放文件的下一个的地址（0表示空闲，-1表示文件的最后一块了，其余表示下一块块号）</p>
<p>FCB记录起始块号</p>
<p>缺点是必须把整个表都放在内存中</p>
<h5 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h5><ul>
<li>一个文件的信息存放在若干不连续物理块中</li>
<li>系统为每个文件建立一个专用数据结构——索引表，并将这些物理块的块号存放在索引表中</li>
<li>索引表就是磁盘块地址数组，其中第i个条目指向文件的第i块（所以可以随机存取</li>
<li>索引块存放索引表<ul>
<li>如果索引表很大的时候，需要多个索引块的时候：<ul>
<li>链接方式：一个盘块存一个索引表，多个索引表链接起来</li>
<li>多级索引方式：将文件的额索引表地址放在另一个索引表中（unix采用，一般为256的次方个）</li>
<li>综合模式：直接索引方式和间接索引方式的结合</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>优点：</strong></p>
<p>保持了链接结构的优点，又解决了其缺点</p>
<ul>
<li>既能顺序存取，又能随机存取</li>
<li>满足了文件动态增长、插入删除的要求</li>
<li>能充分利用磁盘空间</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>较多的寻道次数和寻道时间</li>
<li>索引表本身带来了系统开销：如：内存、磁盘空间、存取时间</li>
</ul>
<h5 id="i-node"><a href="#i-node" class="headerlink" title="i-node"></a>i-node</h5><p><img src="/2018/12/08/操作系统-笔记/i-node.png" alt=""></p>
<p>FAT正比于磁盘大小；i节点正比于同时打开的最大文件个数，与磁盘大小无关</p>
<p>保存文件的块号，保存各个子目录的文件块号</p>
<p>元数据+数据块</p>
<ul>
<li>为每个文件赋予一个i节点</li>
<li>每个i节点都有<strong>固定数量的磁盘地址空间</strong>；当文件超出此限制时，将出现问题，可以将最后一个磁盘块地址不指向数据块，而是指向一个包含额外磁盘块地址的块的地址</li>
<li>记录<strong>文件块的属性和磁盘地址</strong></li>
<li>在i节点中存储文件属性</li>
<li>每个目录条目包括文件名和索引节点号</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>只有在文件打开时，才在内存中</li>
<li>该数组远小于FAT，其大小与一次打开的最大文件数成比例</li>
</ul>
<h4 id="共享文件系统Shared-Files"><a href="#共享文件系统Shared-Files" class="headerlink" title="共享文件系统Shared Files"></a>共享文件系统Shared Files</h4><p>共享文件通常同时出现在属于不同用户的不同目录中，方便多个用户访问<br>目录和共享文件之间的连接称为<strong>链接</strong><br>文件系统本身是<strong>有向无环图（DAG）</strong></p>
<p>问题：导致一个对共享文件的修改，其他用户看不到</p>
<p>解决方案：</p>
<ul>
<li>磁盘块未列在目录中，而是列在与文件本身关联的小数据结构（i节点）中<ul>
<li>i节点中记录一些属性：所有者，链接数count（如果硬连接，会动态变化）</li>
<li>不会改变文件的所有权</li>
<li>软连接中：如果文件所有者删除了文件，则其他可共享的用户将会指向一个无效的i节点（目录条目）；硬连接中，无影响</li>
<li>硬链接就是同一个文件<strong>使用了多个别名（它们有共同的inode）</strong>，由于硬链接是有相同inode号仅文件名不同的文件，因此删除一个硬链接文件并不影响其他有相同inode号的文件，硬链接不能对目录进行创建，只可对<strong>文件</strong>进行创建。</li>
<li>软连接：也叫符号链接，<strong>文件用户数据块中存放的内容是另一文件的路径名的指向</strong>，<strong>软连接就是一个普通文件，只是数据块内容有点特殊</strong>，软链接可以对<strong>文件或目录创建</strong></li>
</ul>
</li>
<li>通过让系统创建LINK类型的新文件并在B的目录中输入该文件来链接到A的文件<ul>
<li>新文件仅包含与其链接的文件的路径名，这种方法称为符号连接</li>
<li>符号链接的问题是需要额外的开销</li>
</ul>
</li>
</ul>
<h4 id="日志文件系统Journaling-File-Systems"><a href="#日志文件系统Journaling-File-Systems" class="headerlink" title="日志文件系统Journaling File Systems"></a>日志文件系统Journaling File Systems</h4><p>在文件系统<strong>执行之前</strong>记录文件系统要执行的操作，以便在系统崩溃之前可以执行其计划的工作，在重新启动系统后可以查看日志以查看崩溃时发生的情况 并完成工作，这样的文件系统，称为日志文件系统（journaling file systems）</p>
<h4 id="虚拟文件系统VFS-Virtual-File-Systems"><a href="#虚拟文件系统VFS-Virtual-File-Systems" class="headerlink" title="虚拟文件系统VFS(Virtual File Systems)"></a>虚拟文件系统VFS(Virtual File Systems)</h4><p>尝试将多个文件系统集成到一个有序的结构中，关键思想是抽象出所有文件系统<strong>通用的文件</strong>系统部分，并将该代码放在一个单独的<strong>层</strong>中，该层调用底层的具体文件系统来实际管理数据（用户层和虚拟文件系统交互，虚拟文件系统和文件系统交互，作为一个中间层）<br>示例：Sun Microsystems，UNIX</p>
<h4 id="UNIX文件系统的实现"><a href="#UNIX文件系统的实现" class="headerlink" title="UNIX文件系统的实现"></a>UNIX文件系统的实现</h4><p><strong>磁盘分区</strong>：把一个<strong>物理磁盘</strong>存储空间划分为几个<strong>相互独立</strong>的部分，称为<strong>分区</strong></p>
<p><strong>文件卷</strong>：磁盘上的<strong>逻辑分区</strong>，由一个或多个物理块（簇）组成</p>
<ul>
<li>一个文件卷可以是整个磁盘或部分磁盘或跨盘（RAID）</li>
<li>同一个文件卷中<strong>使用同一份管理数据</strong>进行<strong>文件分配和磁盘空闲空间管理</strong>，不同文件卷中的管理数据是相互独立的</li>
<li><strong>一个文件卷上：包括文件系统信息、一组文件（用户文件、目录文件）、未分配空间</strong></li>
<li>块（BLOCK）或簇（CLUSTER）：一个或多个（2的幂）连续的扇区，可寻址数据块</li>
<li>包括了<ul>
<li>引导区，包括了从该卷引导操作系统所需要的信息，<strong>每个卷（分区）一个</strong>，通常为第一个扇区</li>
<li>卷（分区）信息：包括块（簇）数，块（簇）大小，空闲块（簇）数量和指针，空闲DCB数量和指针</li>
<li>目录文件（根目录文件及其他目录文件）</li>
<li>用户文件</li>
</ul>
</li>
</ul>
<p><strong>格式化</strong>：在一个文件卷上建立文件系统，即建立并初始化用于文件分配和磁盘空闲空间管理的<strong>管理数据</strong>（建立元数据）</p>
<p>内存中需要提供的<strong>数据结构</strong>以支持这个进程对文件的使用：</p>
<ul>
<li>系统打开文件表：整个系统一张，放在内存，用于保存已打开文件的FCB<ul>
<li>格式：FCB(i节点)信息+引用计数+修改标记</li>
</ul>
</li>
<li>用户打开文件表<ul>
<li>每个进程一个</li>
<li>进程的PCB中记录了用户打开文件表的位置</li>
<li>格式：文件描述符+打开方式+读写指针+系统打开文件表索引</li>
</ul>
</li>
</ul>
<p>以UNIX为例：</p>
<ul>
<li>目录检索<ul>
<li>根据<strong>用户给出文件名-&gt;按文件名查找到目录项/FCB</strong></li>
<li>全路径名：从根开始</li>
<li>相对路径：从当前目录开始</li>
</ul>
</li>
<li>文件寻址<ul>
<li>根据<strong>目录项/FCB中文件物理地址等信息</strong>，<strong>计算出</strong>文件中任意记录或字符<strong>在存储介质上的地址</strong></li>
</ul>
</li>
</ul>
<p>因此，目录检索的速度是关键因素。加快目录检索的解决方案：</p>
<ul>
<li>目录项分解法：即把FCB分成两部分<ul>
<li>符号目录项：文件名，文件号</li>
<li>基本目录项：除文件名外的所有字段</li>
<li>例如：UNIX的FCB=目录项 + i节点（索引节点或inode）<ul>
<li>本目录节点的目录项<code>.</code>，他自己的i-node</li>
<li>附目录的目录项<code>..</code>，他的爸爸的i-node</li>
</ul>
</li>
<li>目录文件改进后减少了访盘次数，提高了文件检索速度</li>
</ul>
</li>
</ul>
<p><img src="/2018/12/08/操作系统-笔记/目录项分解的好处.png" alt="目录项分解的好处">图中的不是物理地址，而是得到所在的物理地址的块</p>
<h4 id="Windows—FAT16文件系统"><a href="#Windows—FAT16文件系统" class="headerlink" title="Windows—FAT16文件系统"></a>Windows—FAT16文件系统</h4><p>簇大小为$2^n$个扇区</p>
<p>文件系统的数据记录在“引导扇区”中</p>
<p>对空闲区采用位示图法</p>
<p><strong>文件分配表FAT</strong></p>
<p>可以把文件分配表看成一个整数数组，每个整数代表磁盘分区的一个簇号</p>
<p>状态：未使用、坏簇、系统保留、被文件占用（下一簇簇号）、最后一簇（0xFFFF）</p>
<p>作用：描述簇的分配状态，标注下一簇的簇号等</p>
<p>FAT表项：2字节（16-&gt;2*8bit）</p>
<p>目录项：32字节（等效于FCB）</p>
<p>FAT16一个文件对应一个目录项；而对于FAT32长文件名来说，一个文件可能对应多个目录项；其中短文件目录项是必须有的</p>
<h6 id="长文件名的存储"><a href="#长文件名的存储" class="headerlink" title="长文件名的存储"></a>长文件名的存储</h6><ul>
<li><p>左边的是线性的</p>
<ul>
<li>删除文件时，会在目录中引入可变大小的间隙，下一个要输入的文件可能不适合该目录</li>
<li>读取文件时可能会发生页面错误</li>
</ul>
</li>
<li><p>右边的是堆形的</p>
<ul>
<li>通过hash或者Cache来加速搜索</li>
</ul>
</li>
</ul>
<p><img src="/2018/12/08/操作系统-笔记/长文件名.png" alt="长文件名实现方式"></p>
<p>根目录大小固定（大小信息均在引导扇区中）【在FAT32中，根目录大小不固定了】</p>
<h4 id="文件操作的实现"><a href="#文件操作的实现" class="headerlink" title="文件操作的实现"></a>文件操作的实现</h4><h5 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h5><p>建立系统与文件的联系，实质是建立文件的FCB</p>
<ul>
<li>在目录中为新文件建立一个目录项，根据提供的参数及需要填写相关内容</li>
<li>分配必要的存储空间</li>
</ul>
<p>create(文件名， 访问权限)</p>
<ul>
<li>检查参数的合法性（是否符合命名规则；有无重名文件），若合法，下一步；否则，报错</li>
<li>申请空闲目录项，并填写相关内容</li>
<li>为文件申请磁盘块</li>
<li>返回</li>
</ul>
<h5 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h5><p>根据文件名在文件目录中检索，并将该文件的目录项读入内存，建立相应的数据结构（系统打开文件表/用户打开文件表），得到文件描述符/文件句柄（来操作），为后续的文件操作做好准备</p>
<p>fd=open(文件路径名， 打开方式)</p>
<ul>
<li>根据文件路径名查目录，<strong>找到目录项（或i节点号）</strong></li>
<li>根据文件号查<strong>系统打开文件表</strong>，看文件是否已被打开；是，则共享计数加1；否则，将目录项（i节点）等信息填入系统打开文件表空表项，<strong>共享计数</strong>置1</li>
<li>根据打开方式，共享说明和用户身份<strong>检查访问合法性</strong></li>
<li>在<strong>用户打开文件表</strong>中获取一空表项，填写打开方式等，并指向系统打开文件表对应表项；<strong>返回信息</strong>：fd——文件描述符，是一个非负整数，用于以后读写文件</li>
</ul>
<h5 id="指针定位"><a href="#指针定位" class="headerlink" title="指针定位"></a>指针定位</h5><p>seek(fd， 新指针的位置)</p>
<p>系统为<strong>每个进程打开的每个文件维护一个读写指针</strong>，即相对于文件开头的偏移地址（读写指针指向每次文件读写的开始位置，在每次读写完成后，读写指针按照读写的数据量自动后移相应数值）</p>
<ul>
<li>由fd查用户打开文件表，找到对应的表项</li>
<li>将用户打开文件表中文件读写指针位置设为新指针的位置，供后继读写命令存取该指针处文件内容</li>
</ul>
<h5 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h5><p>read(文件描述符， 读指针， 要读的长度， 内存目的地址)</p>
<ul>
<li>根据打开文件时得到的文件描述符，找到相应的文件控制块（目录项）；确定读操作的合法性，若合法，进入下一步；否则，出错处理</li>
<li>将文件的逻辑块号转换为物理块号；根据参数中的读指针、长度与文件控制块中的信息确定块号、块数、块内偏移</li>
<li><strong>申请缓冲区</strong></li>
<li>启动磁盘I/O操作，把磁盘块中的信息读入缓冲区，<strong>再送到指定的内存区（多次读盘）</strong></li>
<li>反复执行3、4直至读出所需数量的数据或读至文件尾</li>
</ul>
<p><img src="/2018/12/08/操作系统-笔记/Linux文件系统调用.png" alt=""></p>
<h4 id="文件系统的管理"><a href="#文件系统的管理" class="headerlink" title="文件系统的管理"></a>文件系统的管理</h4><h5 id="文件系统的空间管理"><a href="#文件系统的空间管理" class="headerlink" title="文件系统的空间管理"></a>文件系统的空间管理</h5><ul>
<li>固定大小<ul>
<li>过大，浪费磁盘空间</li>
<li>过小，差的性能（增加寻道时间、旋转延迟、数据传输时间等等）</li>
</ul>
</li>
<li>已知块号，则磁盘地址：<ul>
<li>柱面号=[块号/(磁头数x扇区数)]</li>
<li>磁头号=[(块号mod(磁头数x扇区数))/扇区数]</li>
<li>扇区号(块号mod(磁头数x扇区数))mod扇区数</li>
</ul>
</li>
<li>已知磁盘地址：<ul>
<li><strong>块号=柱面号x(磁头数x扇区数)+磁头号x扇区号+扇区号</strong></li>
</ul>
</li>
<li>Disk Quotas（磁盘配额）<br>为防止人们占用太多磁盘空间，多用户操作系统通常提供强制磁盘配额的机制（强制性磁盘配额），系统管理员<strong>为每个用户分配最大的文件和块分配</strong>，操作系统确保用户不超过他们的配额</li>
<li>位图（0/1表示是否被占用）<ul>
<li>块号=i*字长+j</li>
<li>其中字号：i；位号：j</li>
<li>存在的问题，每次需要找到连续的k个0，才能找到可以存放的空闲块</li>
</ul>
</li>
<li>空闲块表（将所有空闲块记录在一个表中，记录每一个空闲块的起始块号，块数）</li>
<li>空闲块链表（把所有空闲块链成一个链）<ul>
<li>一些短暂的临时文件将会导致不必要的I/O</li>
<li>指针块还可能存在溢出<ul>
<li>解决方法：保持磁盘上的大多数指针块为满的状态，但是在内存中保留一个半满的指针块</li>
</ul>
</li>
<li>扩展：<strong>成组链接法 UNIX中</strong></li>
</ul>
</li>
</ul>
<p><img src="/2018/12/08/操作系统-笔记/%E6%88%90%E7%BB%84%E9%93%BE%E6%8E%A5%E6%B3%95.png" alt=""></p>
<p><img src="/2018/12/08/操作系统-笔记/%E6%88%90%E7%BB%84%E9%93%BE%E6%8E%A5%E6%B3%952.png" alt="成组链接法2"></p>
<h5 id="文件系统的可靠性"><a href="#文件系统的可靠性" class="headerlink" title="文件系统的可靠性"></a>文件系统的可靠性</h5><p>可靠性：抵御和预防各种物理性破坏和人为性破坏的能力</p>
<ul>
<li><p>坏块问题</p>
</li>
<li><p>备份（通过转储操作，形成文件或文件系统的多个副本）</p>
<ul>
<li><p>全量转储</p>
<ul>
<li><strong>定期</strong>将所有文件拷贝到后援存储器</li>
</ul>
</li>
<li><p>增量转储</p>
<ul>
<li><strong>只转储修改过的文件</strong>，即两次备份之间的修改，减少系统开销</li>
</ul>
</li>
<li>物理转储<ul>
<li>从磁盘第0块开始，将所有磁盘块<strong>按序</strong>输出到磁带</li>
<li>缺点：<ul>
<li>备份未使用的磁盘块没有任何价值</li>
<li>避免倾倒坏块</li>
</ul>
</li>
</ul>
</li>
<li><p>逻辑转储</p>
<ul>
<li>从一个或几个指定<strong>目录</strong>开始，递归地转储<strong>自给定日期后</strong>所有更改的文件和目录</li>
<li>UNIX</li>
</ul>
</li>
<li><p>操作流程在位图和i节点下</p>
<ul>
<li><p>Phase 1<br>从起始目录开始检查其中的所有目录项<br>对每一个修改过的文件，算法在位图中标记其i-node<br>标记并递归检查每一个目录，无论其是否被修改过</p>
</li>
<li><p>Phase 2</p>
<p>以递归方式再次遍历树，取消标记任何没有修改过的文件或目录的目录</p>
</li>
<li><p>Phase 3</p>
<p>按数字顺序扫描i节点并转储所有标记为转储的目录</p>
</li>
<li><p>Phase 4</p>
<p>转储标记为转储的文件</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="文件系统的一致性"><a href="#文件系统的一致性" class="headerlink" title="文件系统的一致性"></a>文件系统的一致性</h5><p>源数据的一致性（word文件未保盘，系统奔溃后，这不算）</p>
<p>大多数计算机都有一个检查文件系统一致性的实用程序，如：UNIX – fsck，Windows – Scandisk</p>
<p>所有文件系统检查器都独立于其他文件系统验证每个文件系统</p>
<p>除检查<strong>每个块的计数</strong>是否正确之外，还检查<strong>目录系统</strong></p>
<ol>
<li>创建一张计数器表，每个文件对应一个计数器</li>
<li>程序从根目录开始检验，沿着目录层次递归下降，检查文件系统的每个目录</li>
<li>对于目录中的每个文件，将文件使用计数器加1（符号连接不计数）</li>
<li>检查全部完成后，得到一张由i-node索引的表，说明每个文件被多个目录包含</li>
<li>将这些数字与存储在文件i-node中的连接数相比较</li>
</ol>
<p><strong>问题的产生：</strong></p>
<p>磁盘块-&gt;内存-&gt;写回磁盘块</p>
<p>若在写回之前，系统奔溃，则文件系统出现不一致</p>
<p><strong>解决方案：</strong></p>
<p>设计一个实用程序，当系统再次启动时，运行该程序，检查磁盘块和目录系统</p>
<p>UNIX存在两张表，初始为0；</p>
<p>表一：记录了每块在<strong>文件中出现的次数</strong></p>
<p>表二：记录了每块在<strong>空闲块表中出现的次数</strong></p>
<p>两表相互补充，进行恢复</p>
<p>两个都没有：空闲块置1</p>
<p>表二两次：变1</p>
<p>表一两次：增加一块，复制内容，两个为一</p>
<h5 id="文件系统的写入策略"><a href="#文件系统的写入策略" class="headerlink" title="文件系统的写入策略"></a>文件系统的写入策略</h5><p>需要考虑文件系统一致性和速度</p>
<ul>
<li>通写（write-through）<ul>
<li>内存中的修改立即写到磁盘</li>
<li>缺点：速度性能差</li>
<li>例：FAT文件系统</li>
</ul>
</li>
<li>延迟写（lazy-write）<ul>
<li>利用回写(write back)缓存的方法得到高速</li>
<li>可恢复性差</li>
</ul>
</li>
<li>可恢复写（transaction log）<ul>
<li>采用事务日志来实现文件系统的写入</li>
<li>既考虑安全性，又考虑速度性能</li>
</ul>
</li>
</ul>
<h4 id="文件系统的安全性"><a href="#文件系统的安全性" class="headerlink" title="文件系统的安全性"></a>文件系统的安全性</h4><h5 id="文件保护机制"><a href="#文件保护机制" class="headerlink" title="文件保护机制"></a>文件保护机制</h5><ul>
<li>用于提供安全性、特定的操作系统机制</li>
<li>对拥有权限的用户，应该让其进行相应操作，否则，应禁止</li>
<li>防止其他用户冒充对文件进行操作</li>
</ul>
<p>实现：</p>
<ul>
<li>用户身份验证</li>
<li>访问控制<ul>
<li>主动控制：访问控制表<ul>
<li>每个<strong>文件</strong>一个</li>
<li>记录用户ID和访问权限（没有ID即没有权限）</li>
<li>用户可以是一组用户</li>
<li>文件可以是一组文件</li>
</ul>
</li>
<li>能力表（权限表）<ul>
<li>每个<strong>用户</strong>一个</li>
<li>记录文件名及访问权限</li>
<li>用户可以是一组用户</li>
<li>文件可以是一组文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>UNIX：文件的二级存取控制（审查用户的身份、审查操作的合法性）</p>
<ul>
<li>对用户分类<ul>
<li>文件主(owner)</li>
<li>文件主的同组用户(group)</li>
<li>其他用户(other)</li>
</ul>
</li>
<li>对操作分类<ul>
<li>读操作（r）</li>
<li>写操作（w）</li>
<li>执行操作（x）</li>
<li>不能执行任何操作（-）</li>
</ul>
</li>
</ul>
<p>比如711，则文件主可读可写可执行，而同组用户和其他用户只可以执行；</p>
<p>比如755，则文件主可读可写可执行，而同组用户和其他用户可读可执行101</p>
<h4 id="文件系统的性能"><a href="#文件系统的性能" class="headerlink" title="文件系统的性能"></a>文件系统的性能</h4><p>磁盘服务-&gt;速度成为系统性能的主要瓶颈之一，所以需要<strong>尽可能减少磁盘访问次数</strong></p>
<p>提高文件系统性能的方法：</p>
<ul>
<li>目录项（FCB）分解</li>
<li>当前目录</li>
<li>磁盘碎片整理</li>
<li>磁盘的扇区0称为MBR（主引导记录），MBR的末尾包含分区表（分区表）<br>当计算机启动时，BIOS读入并执行MBR<br>MBR程序首先是找到活动分区，读取它的第一个块，称为引导块，然后执行它<br>引导块中的程序加载该分区中包含的操作系统<br>为了统一，每个分区都以引导块开始</li>
<li><strong>块高速缓存(BLOCK CACHE)</strong><ul>
<li>又称为文件缓存、磁盘高速缓存、缓冲区高速缓存</li>
<li>是指：在<strong>内存</strong>中为磁盘块设置的一个缓冲区，保存了磁盘中某些块的副本</li>
<li>过程<ul>
<li>检查所有的读请求，看所需块是否在块高速缓存中</li>
<li>如果在，则可直接进行读操作；否则，先将数据块读入块高速缓存，再拷贝到所需的地方</li>
</ul>
</li>
<li>由于访问的局部性原理，当数据块被读入块高速缓存以满足一个I/O请求时，很可能将来还会再次访问到这一数据块</li>
<li>实现<ul>
<li>块高速缓存的组织（通过Hash table+链表来维护）</li>
<li>块高速缓存的置换（修改LRU）【每一次放到队尾；如果不久后再次使用，也要靠队尾放置】</li>
<li>块高速缓存写入策略【该块是否会影响文件系统的一致性】<ul>
<li>立即写/回写</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>缓冲区高速缓存（buffer caching）</strong></li>
<li>磁盘调度<ul>
<li>当有多个访盘请求等待时，采用一定的策略，对这些请求的<strong>服务顺序调整安排</strong>，来<strong>降低平均磁盘服务时间</strong>，达到公平、高效<ul>
<li>公平：一个I/O请求在有限时间内满足</li>
<li>高效：减少设备机械运动带来的时间开销</li>
</ul>
</li>
<li>一次访盘时间=寻道时间+旋转延迟时间+传输时间<ul>
<li>减少寻道时间</li>
<li>减少延迟时间</li>
</ul>
</li>
</ul>
</li>
<li><strong>块提前读，又称为提前读取预取</strong><ul>
<li>每次访问磁盘的时候，多读入一些磁盘块（根据程序执行的空间局部性原理），从而提高命中率</li>
<li>开销：较小（只有数据传输时间）</li>
<li>具有针对性，只适用于顺序读取的文件</li>
</ul>
</li>
<li>合理分配磁盘空间，<strong>减少磁盘臂的移动</strong><ul>
<li>分配磁盘块时，把有可能顺序存取的块放在一起</li>
<li>尽量<strong>分配在同一柱面上</strong>，从而减少磁盘臂的移动次数和距离</li>
</ul>
</li>
<li>信息的优化分布<ul>
<li>记录在磁道上的排列方式也会影响输入输出操作的时间</li>
<li>比如：处理也需要时间，这样对于需要顺序处理的第二个，不应该放在毗邻的位置，而是应该在处理之后磁盘转到的新位置更加合理</li>
</ul>
</li>
<li>RAID技术 （独立磁盘冗余阵列）<ul>
<li>Redundant Arrays of Independent Disks</li>
<li>多块磁盘按照一定要求构成一个独立的存储设备</li>
<li>目标：提高<strong>可靠性</strong>和<strong>性能</strong></li>
<li>组织<ul>
<li>通过把多个磁盘组织在一起，作为一个逻辑卷提供磁盘跨越功能</li>
<li>通过把数据分成多个数据块，<strong>并行</strong>写入/读出多个磁盘，以提高数据传输率（数据分条stripe）</li>
<li>通过镜像或校验操作，提供<strong>容错能力（冗余）</strong></li>
<li>RAID 0，条带化，数据分布在阵列的所有磁盘上，有数据请求时，同时多个磁盘并行操作，充分利用总线带宽，数据吞吐率提高，驱动器负载均衡，无冗余（即差错控制），性能最佳</li>
<li>RAID 1，镜像，最大限度保证数据安全及可恢复性，所有数据同时存放在两块磁盘的相同位置，磁盘利用率50%，数据安全性最好</li>
<li>RAID 4，交错块奇偶校验，以数据块为单位，综合，提高了性能和安全性</li>
</ul>
</li>
</ul>
</li>
<li>记录的成组与分解<ul>
<li>记录的成组<ul>
<li>把若干个逻辑记录合成一组存放一块的工作</li>
<li>进行成组操作时必须使用内存缓冲区，缓冲区的长度等于逻辑记录长度乘以成组的块因子（缓冲区的大小）</li>
<li>成组的目的：提高了存储空间的利用率，减少了调动外设的次数，提高了系统的工作效率</li>
<li>记录的分解：从一组逻辑记录中把一个逻辑记录分离出来</li>
<li>典型例子：目录文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h5><h6 id="先来先服务FCFS-1"><a href="#先来先服务FCFS-1" class="headerlink" title="先来先服务FCFS"></a>先来先服务FCFS</h6><p>按访问请求到达的先后次序服务</p>
<p>优点：简单，公平</p>
<p>缺点：效率不高，相邻两次请求可能会造成最内到最外的柱面寻道，使磁头反复移动，增加了服务时间，对机械也不利</p>
<h6 id="最短寻道时间优先Shortest-Seek-Time-First"><a href="#最短寻道时间优先Shortest-Seek-Time-First" class="headerlink" title="最短寻道时间优先Shortest Seek Time First"></a>最短寻道时间优先Shortest Seek Time First</h6><p><strong>优先选择距当前磁头最近的访问请求进行服务，主要考虑寻道优先</strong></p>
<p>优点：改善了磁盘平均服务时间</p>
<p>缺点：造成某些访问请求长期等待得不到服务（远离中间的请求可能得不到服务）</p>
<h6 id="扫描算法SCAN（电梯算法elevator-algorithm）"><a href="#扫描算法SCAN（电梯算法elevator-algorithm）" class="headerlink" title="扫描算法SCAN（电梯算法elevator algorithm）"></a>扫描算法SCAN（电梯算法elevator algorithm）</h6><p>当设备无访问请求时，磁头不动；</p>
<p>当有访问请求时，磁头按一个方向移动，在移动过程中对遇到的访问请求进行服务，然后<strong>判断该方向上是否还有访问请求，如果有则继续扫描；否则改变移动方向，并为经过的访问请求服务</strong>，这种算法权衡了距离、方向</p>
<p>优点：对任意的一组给定请求，磁盘臂<strong>移动总次数的上界是固定的：正好是柱面数的2倍</strong></p>
<p><strong>单向扫描调度算法C-SCAN</strong>（循环算法）</p>
<p>每次从0号柱面开始向里扫描</p>
<p>返回时不为任何的等待访问者服务</p>
<p>减少了新请求的最大延迟</p>
<p><strong>#N-step-SCAN策略</strong></p>
<p>把磁盘请求队列分成长度为N的子队列，每一次用SCAN处理一个子队列</p>
<p>当N较大时，相当于SCAN；N=1，即FCFS</p>
<p>克服“磁头臂”的粘性</p>
<p><strong>#FSCAN</strong></p>
<p>两个队列，老的和新的，可以克服“磁头臂”的粘性</p>
<h6 id="旋转调度算法"><a href="#旋转调度算法" class="headerlink" title="#旋转调度算法"></a>#旋转调度算法</h6><p>根据延迟时间来决定执行次序的调度</p>
<p>扇区近的先来，相同的话，随机选择一个，另一个则要转一圈后才可以轮到，所以可能中间还会夹杂别的扇区的</p>
<h3 id="quiz-9-错题和模糊题"><a href="#quiz-9-错题和模糊题" class="headerlink" title="quiz 9 错题和模糊题"></a>quiz 9 错题和模糊题</h3><p>应选择3</p>
<p>文件的逻辑结构是指文件的外部组织形式，即从用户角度看到的文件的组织形式。因此文件的逻辑结构是由用户决定的</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz9.1.png" alt=""></p>
<p>应选择3</p>
<p>文件系统的一个最大特点是“按名存取”，用户只要给出文件的符号名就能方便地存取在外存空间的文件信息，而不必关心文件的具体物理地址。而实现文件符号名到文件物理地址映射的主要环节是检索文件目录。</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz9.6.png" alt=""></p>
<p>应选择4 和 1</p>
<p><strong>对于第4题</strong>：文件控制块中包含的信息有：文件号、文件名、文件的物理位置、文件的逻辑结构、文件的存取控制权限、文件的建立日期和时间以及文件的修改日期和时间、当前已打开该文件的进程数及是否被进程锁住等。</p>
<p>文件在内存中的位置会改变，不属于文件本生的属性和信息</p>
<p><strong>对于第5题</strong>：目录项分解法中，就分解为了符号目录项和基本目录项了！</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz9.2.png" alt="quiz9.2"></p>
<p>应选择4</p>
<p>文件系统存储空间共有块数$2^{42}/2^{10}=2^{32}$。为表示$2^{32}$个块号，一个索引表项至少要32位，$32b=4B$。$512$字节可存放$2^7$个索引表项，故最大文件长度：$2^7×2^{10}=2^{17}B=128 KB$。</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz9.3.png" alt="quiz9.3"></p>
<p>应选择3 第九题如图</p>
<p>每个索引表相当于一个物理块，有$2^10 / 2^2 = 2^8$ 个索引项，由题可知，前六个直接索引指向6个物理块，而第七个一级索引有$undefined$ 个索引项指向 $undefined$个物理块，同理，第八个二级索引指向 $2^8 * 2^8 = 2^16$ 个物理块，第九个三级索引指向$undefined$个物理块，第十个四级索引指向$undefined$个物理块。</p>
<p>第九题，采用算法前，一个盘块可以放1024/128=8个目录项，254/8=32个目录块，所以平均访问时间为16.5次；采用算法后，一个盘块可以放1024/20=51个目录项，这样254/51=5个目录块，所以平均查找一个目录项需访问磁盘（1+5）/2+1=4次</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz9.4.png" alt="quiz9.4"></p>
<p>11 题如图 12题应选择1345</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz9.5.png" alt="quiz9.5"></p>
<p>13应选择“错”</p>
<p>应是<strong>（链接结构）</strong>是文件系统中可以采用的文件的物理结构</p>
<p>而成组链接法是一种扩展思想</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz9.7.png" alt=""></p>
<p>15应选择“对” 16选择对</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz9.8.png" alt=""></p>
<h3 id="quiz-10-错题和模糊题"><a href="#quiz-10-错题和模糊题" class="headerlink" title="quiz 10 错题和模糊题"></a>quiz 10 错题和模糊题</h3><p>练习1dh</p>
<p><img src="/2018/12/08/操作系统-笔记/10.练习1.png" alt=""></p>
<p><img src="/2018/12/08/操作系统-笔记/10.3.png" alt=""></p>
<p>练习2</p>
<p><img src="/2018/12/08/操作系统-笔记/10.练习2.png" alt=""></p>
<p>如图选择 （FAT32支持Unicode编码）</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz10.1.png" alt="">（65-46）+（46-16）+（85-16）+（114-85）+（116-114）=19+30+69+29+2=149</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz10.2.png" alt=""></p>
<p>选1</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz10.3.png" alt=""></p>
<h3 id="PPT练习题-3"><a href="#PPT练习题-3" class="headerlink" title="PPT练习题"></a>PPT练习题</h3><ol>
<li><p>P326 9. Consider the directory tree of Fig. 4-8. If /usr/jim is the working directory, what is the absolute path name for the file whose relative path name is ../ast/x?</p>
<p><img src="/2018/12/08/操作系统-笔记/练习题10.1.png" alt=""></p>
<p>分析：/usr/ast/x</p>
</li>
<li><p>P326 15. Consider the i-node shown in Fig. 4-13. If it contains 10 direct addresses of 4 bytes each and all disk blocks are 1024B, what is the largest possible file?</p>
<p><img src="/2018/12/08/操作系统-笔记/练习题10.2.png" alt=""></p>
<p>分析：题意：首先是i节点包含了10个直接地址，每个地址4B，所有磁盘块都是1024B，文件最大可能是多少？</p>
<p>首先这里Address of disk block有10个，图里仅为示意；然后最后存在一个地址块指针，即一个间接块，指向另一个更大的空间，那么这个指针块可以指向多少个地址呢？$1024B/4B=256$个，所以这个文件最大可能有：$10<em>1024B+256</em>1024B=266KB$</p>
</li>
<li><p>一个空闲块位图开始时和磁盘分区首次初始化类似，比如：1000 0000 0000 0000（首块被根目录使用），系统总是从最小编号的盘块开始寻找空闲块，所以在有6块的文件A写入之后，该位图为1111 1110 0000 0000。请说明在完成如下每一个附加动作之后位图的状态：</p>
<p>a. 写入有5块的文件B</p>
<p>b. 删除文件A</p>
<p>c. 写入有8块的文件C</p>
<p>d. 删除文件B</p>
<p>分析：1111 1111 1111 0000</p>
<p>1000 0001 1111 0000</p>
<p>1111 1111 1111 1100</p>
<p>1111 1110 0000 1100</p>
</li>
<li><p>In UNIX i-node scheme, a directory entry contains only two fields: the file name (14 bytes) and the number of the i-node for that file (2 bytes). These parameters limit the number of files per file system to   （    ） . </p>
<pre><code>  A. 64k         B. 32k          C. 16k         D. 4k
</code></pre><p>分析：i-node用2 bytes来表示的，那么共有16位来表示它，所以有2^16个不同来表示i-node的方法，所以说，每个文件系统中，最多有64K个文件</p>
</li>
<li><p>Consider the following page-request string in Demand Paging system:    1,2,3,4,5,3,4,1,6,7,8,7,6,3,2,1,2,3,6. How many page faults would occur for the following replacement algorithms, assuming four frames? Remember that all frames are initially empty, so your first unique pages will all cost one fault each.</p>
<pre><code>(1) LRU replacement
(2) FIFO replacement
(3) Optimal replacement
</code></pre><p>分析：12，13，10</p>
</li>
</ol>
<h2 id="I-O-系统"><a href="#I-O-系统" class="headerlink" title="I/O 系统"></a>I/O 系统</h2><h3 id="I-O管理"><a href="#I-O管理" class="headerlink" title="I/O管理"></a>I/O管理</h3><p><img src="/2018/12/08/操作系统-笔记/I:O管理.png" alt="示意图"></p>
<h4 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h4><p>I / O设备通常由两部分组成：<strong>设备控制器和设备本身</strong><br>设备控制器是插件板上的芯片或一组芯片，用于<strong>物理</strong>控制设备<br>与设备控制器通信，给出命令并接受响应的软件称为<strong>设备驱动程序</strong>device driver</p>
<p>控制器的工作是将<strong>串行比特流</strong>转换为<strong>字节块</strong>并执行必要的任何<strong>纠错</strong><br>每个控制器都有一些用于与<strong>CPU通信的寄存器</strong></p>
<p>CPU如何与控制寄存器和设备数据缓冲区通信？</p>
<ul>
<li>解决方案1<br>每个控制寄存器都分配有一个I / O<strong>端口号</strong><br>所有I / O端口的集合构成<strong>I / O端口空间</strong><br>在此模式中，<strong>内存和I / O的地址空间不同</strong><br>示例：IBM 360系列</li>
<li>解决方案2：<strong>内存映射I / O</strong><br>将所有控制寄存器<strong>映射</strong>到存储空间<br>为每个控制寄存器分配一个<strong>唯一的存储器地址</strong>，没有分配存储器<br>通常，分配的地址位于地址空间的顶部<br>示例：PDP-11</li>
<li>混合模式<br>具有内存映射的I / O数据缓冲区和用于控制寄存器的独立I / O端口<br>示例：奔腾</li>
</ul>
<h4 id="I-O特点"><a href="#I-O特点" class="headerlink" title="I/O特点"></a>I/O特点</h4><ul>
<li>I/O性能常常成为系统性能的瓶颈</li>
<li><p>操作系统庞大复杂的原因之一：</p>
<ul>
<li>资源多、杂、并发，均来自I/O</li>
<li><strong>速度差异大</strong></li>
<li>不同应用要求不同</li>
<li>控制接口的复杂性</li>
<li>传送单位不同</li>
<li>数据表示不同</li>
<li>错误条件</li>
</ul>
</li>
<li><p>与其他功能联系密切，特别是文件系统</p>
</li>
</ul>
<h4 id="I-O设备分类"><a href="#I-O设备分类" class="headerlink" title="I/O设备分类"></a>I/O设备分类</h4><ul>
<li>按数据组织分<ul>
<li>块设备<ul>
<li>以固定大小的数据块为单位存储、传输信息，每个块具有其自己的地址</li>
<li>传输速率较高、可寻址（随机读写）</li>
<li>基本属性是可以独立地读取或写入每个块</li>
<li>示例：磁盘，CD-ROM，USB</li>
</ul>
</li>
<li>字符设备<ul>
<li>以字符为单位存储、传输信息</li>
<li>传输速率低、不可寻址，也没有任何搜索操作</li>
<li>提供或接受字符流，而不考虑任何块结构</li>
<li>示例：打印机，网络接口，鼠标</li>
</ul>
</li>
</ul>
</li>
<li>按功能分<ul>
<li>存储设备<ul>
<li>磁盘、磁带</li>
</ul>
</li>
<li>传输设备<ul>
<li>网卡、Modem（调制解调器）</li>
</ul>
</li>
<li>人机交互设备<ul>
<li>显示器、键盘、鼠标</li>
</ul>
</li>
</ul>
</li>
<li>从资源分配角度<ul>
<li>独占设备<ul>
<li>在一段时间内只能有一个进程使用的设备，一般为低速I/O设备（如打印机，磁带等）</li>
</ul>
</li>
<li>共享设备<ul>
<li>在一段时间内可有多个进程共同使用的设备，多个进程以交叉的方式来使用设备，其资源利用率高（如硬盘）</li>
</ul>
</li>
<li>虚设备<ul>
<li>在一类设备上模拟另一类设备，常用<strong>共享设备模拟独占设备</strong>，<strong>用高速设备模拟低速设备</strong>，被模拟的设备称为虚设备</li>
<li>目的：<strong>将慢速的独占设备改造成多个用户可共享的设备，提高设备的利用率</strong></li>
<li>例如：SPOOLING技术，利用虚设备技术——用硬盘模拟输入输出设备</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="输入设备"><a href="#输入设备" class="headerlink" title="输入设备"></a>输入设备</h5><ul>
<li>键盘<ul>
<li>可以通过串行端口，并行端口或USB端口连接，在<strong>每个键操作上CPU被中断</strong>，<strong>键盘驱动程序提取键入的字符</strong>，所有键盘硬件提供的是密钥编号而不是ASCII代码</li>
<li>键盘驱动程序的基本工作是<strong>收集输入并将其传递给用户程序</strong><ul>
<li>面向字符模式<br>驱动程序接受输入并将其向上传递未经修改<br>POSIX中的非规范模式</li>
<li>面向行模式<br>驱动程序处理所有的intraline编辑，只是将<strong>更正的行</strong>提供给用户程序<br>POSIX中的规范模式</li>
</ul>
</li>
</ul>
</li>
<li>鼠标<ul>
<li>只要鼠标在任一方向上<strong>移动</strong>了某个最小距离或<strong>按下</strong>或<strong>释放</strong>按钮，就会向计算机发送一条消息<br>最小距离约为0.1mm<br>该消息包含三个项目：<strong>△x，△y，按钮</strong></li>
</ul>
</li>
</ul>
<h5 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备"></a>输出设备</h5><ul>
<li>X终端<ul>
<li>运行X软件并与<strong>远程计算机上运行的程序交互</strong>的计算机<ul>
<li>X服务器<br>X终端内部的程序，用于从键盘或鼠标收集输入并接受来自远程计算机的命令</li>
<li>X客户端<br>在某个远程主机上运行</li>
<li>客户端和服务器之间的消息类型：<ul>
<li>从程序到工作站命令</li>
<li>工作站对程序查询的回复</li>
<li>键盘，鼠标和其他活动公告</li>
<li>错误消息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h5><ul>
<li>图形用户界面（GUI）<ul>
<li>GUI有四个基本要素<ul>
<li>视窗/窗口Windows（基本项）</li>
<li>图标ICons</li>
<li>菜单Menus</li>
<li>指点设备Pointing device</li>
</ul>
</li>
<li>GUI系统的输入仍然使用键盘和鼠标，但输出几乎总是进入称为图形适配器的特殊硬件板；图形适配器包含一个称为视频RAM的特殊内存，用于保存屏幕上显示的图像</li>
<li>位图<ul>
<li>用于照片和视频<br>通过在图像上覆盖网格来扫描<br>每个网格方块的平均红色，绿色和蓝色值被采样并保存为一个像素的值</li>
<li>用于文本<br>将特定字符表示为小位图</li>
<li>一种使用位图的一般方法是通过一个程序<br>bitblt（dsthdc，dx，dy，wid，ht，srchdc，sx，sy，rasterop）</li>
<li>位图的一个问题是它们不能缩放，因此，Windows还支持称为DIB（设备无关位图，设备无关的位图）的数据结构，使用此格式的文件使用扩展名.bmp。</li>
</ul>
</li>
<li>TrueType字体<br>字体外有轮廓（像空心字）<br>每个TrueType字符由其周围的一系列点定义（周界）<br>所有点都相对于（0,0）原点<br>在向上或向下缩放字符时，将每个坐标乘以相同的比例因子</li>
</ul>
</li>
</ul>
<h4 id="I-O管理的目标和任务"><a href="#I-O管理的目标和任务" class="headerlink" title="I/O管理的目标和任务"></a>I/O管理的目标和任务</h4><ol>
<li><p>按照用户的请求，控制设备的各种操作，完成I/O设备与内存之间的数据交换，最终完成用户的I/O请求</p>
<ul>
<li>设备分配与回收<ul>
<li>记录设备的状态</li>
<li>根据用户的请求和设备的类型，采用一定的分配算法，选择一条数据通路</li>
</ul>
</li>
<li>执行设备驱动程序，实现真正的I/O操作</li>
<li>设备中断处理：处理外部设备的中断</li>
<li>缓冲区管理：管理I/O缓冲区</li>
</ul>
</li>
<li><p>建立方便、统一的独立于设备的接口</p>
<p>通用性：种类繁多、结构各异-&gt;设计简单、避免错误-&gt;采用统一的方式处理所有设备</p>
<ul>
<li>方便性<ul>
<li>向用户提供使用外部设备的方便接口，使用户编程时不考虑设备的复杂物理特性</li>
</ul>
</li>
<li>统一性：<ul>
<li>对不同的设备采取统一的操作方式，即在用户程序中使用的是逻辑设备</li>
<li>逻辑设备与物理设备</li>
<li>屏蔽硬件细节（设备的物理特性、错误处理、不同I/O过程的差异性）</li>
</ul>
</li>
</ul>
</li>
<li><p>充分利用各种技术（通道、中断、缓冲、异步I/O等）提高CPU与设备、设备与设备之间的并行工作能力，充分利用资源，提高资源利用率</p>
<p>性能：CPU与I/O的速度差别大-&gt;减少由于速度差异造成的整体性能开销-&gt;尽量使两者交叠运行</p>
<ul>
<li>并行性</li>
<li>均衡性（使设备充分忙碌）</li>
</ul>
</li>
<li><p>保护</p>
<p>设备传送或管理的数据应该是安全的、不被破坏的、保密的</p>
</li>
</ol>
<h3 id="I-O硬件组成"><a href="#I-O硬件组成" class="headerlink" title="I/O硬件组成"></a>I/O硬件组成</h3><p>I/O设备一般由机械（设备本身，物理装置）和电子（设备控制器或适配器）两部分组成</p>
<p><strong>控制器的作用</strong></p>
<ul>
<li>操作系统将命令写入控制器的接口寄存器（或接口缓冲区）中，以实现输入/输出，并从接口寄存器读取状态信息或结果信息</li>
<li>当控制器接受一条命令后，可<strong>独立于CPU</strong>完成指定操作，CPU可以另外执行其他计算；命令完成时，控制器产生一个中断，CPU响应中断，控制转给操作系统；通过读控制器寄存器中的信息，获得操作结果和设备状态</li>
<li>控制器与设备之间的接口常常是一个低级接口</li>
<li>控制器的任务：把串行的位流转换为字节块，并进行必要的错误修正：首先，控制器按位进行组装，然后存入控制器内部的缓冲区中形成以字节为单位的块；在对块验证检查和并证明无错误时，再将它复制到内存中</li>
</ul>
<p><strong>I/O端口地址</strong></p>
<ul>
<li>接口电路中每个寄存器具有的、唯一的地址，是个整数</li>
<li>所有I/O端口地址形成I/O端口空间（受到保护）</li>
</ul>
<p>I/O指令形式与I/O地址是相互关联的，主要有两种形式：</p>
<ul>
<li><strong>内存映像编址（内存映像I/O模式）</strong><ul>
<li>分配给系统中所有端口的地址空间与内存的地址空间<strong>统一编址</strong></li>
<li>把I/O端口看作一个存储单元，对I/O的读写操作等同于对内存的操作</li>
<li>优点：<ul>
<li>凡是可对内存操作的指令都可对I/O端口操作</li>
<li>不需要专门的I/O指令</li>
<li><strong>I/O端口可占有较大的地址空间</strong></li>
</ul>
</li>
<li>缺点：<ul>
<li>占用内存空间</li>
</ul>
</li>
</ul>
</li>
<li>I/O独立编址（I/O专用指令）<ul>
<li>分配给系统中所有端口的地址空间完全独立，与内存地址空间无关</li>
<li>使用专门的I/O指令对端口进行操作</li>
<li>优点：<ul>
<li>外设不占用内存的地址空间</li>
<li>编程时，易于区分是对内存操作还是对I/O端口操作</li>
</ul>
</li>
<li>缺点：<ul>
<li>I/O端口操作的指令类型少，操作不灵活</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>内存映射I/O</strong></p>
<ul>
<li>优点<ul>
<li>不需要特殊的保护机制来阻止用户进程执行I/O操作<ul>
<li>操作系统必须要做的事情：避免把包含控制寄存器的那部分地址空间放入任何用户的虚地址空间之中</li>
</ul>
</li>
<li>可以引用内存的每一条指令也可以引用控制寄存器</li>
</ul>
</li>
<li>缺点<ul>
<li><strong>对一个控制寄存器不能进行高速缓存</strong><ul>
<li>当设备引用进入高速缓存，则只会从高速缓存中取值并且不会再查询设备，之后当设备最终变为就绪时，软件将没有办法发现这一点，循环将永远进行下去</li>
<li>因此，为了避免这一情形，硬件必须针对每个页面具备<strong>选择性禁用高速缓存</strong>的能力，操作系统必须管理选择性高速缓存，这一特性为硬件和操作系统两者增添了额外的复杂性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h3><h4 id="可编程I-O（轮询-查询）"><a href="#可编程I-O（轮询-查询）" class="headerlink" title="可编程I/O（轮询/查询）"></a>可编程I/O（轮询/查询）</h4><p>让CPU做所有的事情</p>
<p>由CPU代表进程给I/O模块发I/O命令，进程进入<strong>忙等待</strong>，直到操作完成才继续执行</p>
<p>程序控制I/O(PIO, Programmed I/O)通过CPU的in/out或者load/store传输所有数据；适合字符设备</p>
<h4 id="中断驱动I-O"><a href="#中断驱动I-O" class="headerlink" title="中断驱动I/O"></a>中断驱动I/O</h4><p><strong>允许CPU在等待设备准备就绪时执行其他操作</strong></p>
<p>为了减少设备驱动程序不断地询问控制器状态寄存器的开销，I/O操作结束后，由设备控制器<strong>主动通知</strong>设备驱动程序</p>
<p><img src="/2018/12/08/操作系统-笔记/中断控制器.png" alt=""></p>
<p>不符合以下这些要求的中断称为<strong>不精确中断</strong></p>
<ul>
<li><strong>PC（程序计数器）</strong>保存在<strong>已知</strong>位置</li>
<li>PC指向的<strong>所有指令</strong>都<strong>已完全执行</strong></li>
<li><strong>没有执行超出</strong>PC指向的指令</li>
<li>PC指向的指令的<strong>执行状态是已知的</strong></li>
</ul>
<p>中断驱动I / O的一个明显<strong>缺点</strong>是<strong>每个字符</strong>都会发生<strong>中断</strong><br>让<strong>DMA控制器</strong>将字符输入打印机，而不会打扰CPU<br>此策略需要<strong>特殊硬件（DMA控制器）</strong>，但在<strong>I / O期间释放CPU以执行其他工作</strong></p>
<h4 id="DMA（直接内存存取"><a href="#DMA（直接内存存取" class="headerlink" title="DMA（直接内存存取)"></a>DMA（直接内存存取)</h4><p>Direct Memory Access，使用了中断</p>
<p>仅仅在传送数据的开始和结束时需要CPU干预</p>
<p>一个专门的控制器来完成数据从内存到设备或者是从设备到内存的传输工作</p>
<p>DMA设备控制器可<strong>直接访问系统总线</strong>并<strong>直接与内存互相传输数据</strong></p>
<p>其基本思想是，在<strong>I/O设备和内存</strong>之间开辟<strong>直接的数据交换通路</strong><br>DMA控制器可用来代替CPU<strong>控制内存和设备</strong>之间进行<strong>成批</strong>的数据交换</p>
<p>（让DMA控制器一次给打印机提供一个字符，不必打扰CPU，将中断次数从打印每个字符一次变为打印每个缓冲区一次）</p>
<p>适合块设备</p>
<h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><p><img src="/2018/12/08/操作系统-笔记/DMA.png" alt=""></p>
<ol>
<li><strong>CPU设置DMA控制器的寄存器：</strong>将准备存放输入数据的内存起始地址、要传送的字节数存入DMA控制器的寄存器</li>
<li><strong>DMA控制器</strong>通过在<strong>总线上</strong>发出一个<strong>读请求</strong>到<strong>磁盘控制器</strong>而发起<strong>DMA传送</strong></li>
<li><strong>磁盘控制器</strong>将<strong>数据写入内存</strong></li>
<li><strong>磁盘控制器</strong>发送<strong>应答信号</strong>至<strong>DMA控制器</strong>。重复2-4，<strong>当数据全部传送完毕</strong>，<strong>DMA控制器将中断CPU</strong></li>
</ol>
<h5 id="操作模式"><a href="#操作模式" class="headerlink" title="操作模式"></a>操作模式</h5><ul>
<li>word-at-a time mode（<strong>每次一字模式</strong>）<br>DMA控制器请求<strong>传输一个字</strong>并获取它，该机制称为周期窃取</li>
<li>block mode（块模式）<br>DMA控制器告诉设备获取总线，发出<strong>一系列传输</strong>，然后释放总线，这种形式称为突发模式</li>
<li>fly-by mode（飞跃模式）<br>DMA控制器告诉设备控制器将数据<strong>直接传输</strong>到<strong>主存储器</strong></li>
</ul>
<h3 id="I-O软件设计"><a href="#I-O软件设计" class="headerlink" title="I/O软件设计"></a>I/O软件设计</h3><h4 id="分层的设计思想"><a href="#分层的设计思想" class="headerlink" title="分层的设计思想"></a>分层的设计思想</h4><ul>
<li>每一层都执行操作系统所需要的功能的一个相关子集，它依赖于更低一层所执行的更原始的功能，从而可以隐藏这些功能细节；同时，它又给高一层提供服务</li>
<li>较低层考虑硬件的特性，并向较高层软件提供接口</li>
<li>较高层不依赖于硬件，并向用户提供一个友好的、清晰的、简单的、功能更强的接口</li>
</ul>
<p>通常分为四层：</p>
<p><img src="/2018/12/08/操作系统-笔记/分层I:O.png" alt=""></p>
<ul>
<li><strong>用户级I/O软件</strong><ul>
<li>用户进程层执行<strong>输入输出系统调用</strong>，<strong>对I/O数据进行格式化</strong>，<strong>为假脱机输入/输出作准备</strong></li>
<li>系统调用，包括I / O系统调用，通常由库过程完成</li>
<li>假脱机是一种在多道程序设计系统中处理专用I / O设备的方法<br>守护进程（守护进程）<br>假脱机目录（假脱机目录）</li>
<li>假脱机文件传输<br>USENET新闻系统</li>
</ul>
</li>
<li><strong>与设备无关的OS软件</strong><ul>
<li>独立于设备的软件<strong>实现设备的命名、设备的保护、成块处理、缓冲技术和设备分配</strong></li>
<li>又分为：<ul>
<li>驱动程序的统一接口<ul>
<li>如何使所有I / O设备和驱动程序看起来相同<ul>
<li>将符号设备名称映射到正确的驱动程序<br>主设备号（用于定位驱动程序），次设备号（作为传递给驱动程序的参数）（在Unix中）</li>
<li>阻止用户访问他们无权访问的设备<br>在Unix和Windows 2000中，设备在文件系统中显示为命名对象</li>
</ul>
</li>
</ul>
</li>
<li>缓冲<ul>
<li>缓冲区的作用：<ul>
<li>缓和<strong>CPU和I/O设备</strong>之间<strong>速率不匹配</strong>的矛盾</li>
<li><strong>减少对CPU的中断频率</strong>，<strong>放宽对中断响应时间的限制</strong></li>
<li>提高<strong>CPU和I/O设备</strong>之间的<strong>并行性</strong></li>
</ul>
</li>
<li>无缓冲输入的缺点：必须为每个传入的角色启动用户进程</li>
<li>缓冲在用户空间的缺点：当字符到达时缓冲区被分页时，可用<strong>页面池将缩小</strong>，<strong>性能将降低</strong></li>
<li>在内核中缓冲，然后复制到用户空间：当内核空间中的缓冲区已满时，将引入带有用户缓冲区的页面；当从磁盘引入带有用户缓冲区的页面时，字符送达</li>
<li>在内核有双缓冲区</li>
<li>如果数据被缓冲太多次，性能会受到影响（网络中还可能涉及许多副本）</li>
<li>UNIX设置多缓冲的目的是：为了<strong>提高</strong>基本速率相差比较大的块设备之间的<strong>吞吐量</strong>，并<strong>减少对CPU的中断次数</strong></li>
</ul>
</li>
<li>错误报告<ul>
<li>编程错误<br>解决方案：向调用者报告错误代码</li>
<li>实际的I / O错误<br>由调用者决定做什么</li>
</ul>
</li>
<li>分配与释放设备</li>
<li>提供与设备无关的块大小<ul>
<li>与设备无关的软件，为更高层提供统一的块大小</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>设备驱动程序</strong><ul>
<li>设备驱动程序<strong>设置设备寄存器、检查设备的执行状态</strong></li>
<li>连接到计算机的每个I / O设备都需要一些特定于设备的代码来控制它，此代码称为<strong>设备驱动程序</strong></li>
<li>设备驱动程序最明显的功能是接受来自<strong>其上方与设备无关的软件</strong>的<strong>抽象</strong>读写请求</li>
<li>设备驱动程序通常必须是<strong>操作系统内核</strong>的一部分，至少在当前架构下</li>
<li>驱动程序可以通过三种方式放入内核<ul>
<li>使用<strong>新驱动程序</strong>重新<strong>链接</strong>内核，然后<strong>重新引导</strong>系统<br>示例：UNIX</li>
<li>在操作系统文件中<strong>创建一个条目</strong>，<strong>告诉它需要驱动程序</strong>，然后<strong>重新启动</strong>系统<br>  示例：Windows</li>
<li>能够在<strong>运行时接受新驱动程序</strong>并<strong>即时安装</strong>它们而无需重新启动<br>示例：USB，IEEE 1394设备</li>
</ul>
</li>
</ul>
</li>
<li><strong>中断处理程序</strong><ul>
<li><strong>中断处理程序负责I/O完成时，唤醒设备驱动程序进程，进行中断处理</strong></li>
<li>让驱动程序启动I / O操作块，直到中断通知完成<br>当中断发生时，中断过程执行其任务，然后取消阻止启动它的驱动程序</li>
<li>中断完成后，必须在<strong>软件中</strong>执行步骤<br><strong>保存</strong>尚未由中断硬件保存的<strong>寄存器</strong><br>设置中断服务程序的<strong>上下文</strong><br>为<strong>中断服务程序</strong>设置<strong>堆栈</strong><br>确认<strong>中断控制器</strong>，<strong>重新启用中断</strong><br>从保存的位置<strong>复制寄存器</strong><br><strong>运行服务程序</strong><br>选择<strong>下一个</strong>要运行的进程<br>设置<strong>MMU上下文</strong>以便下一步运行该进程<br><strong>加载新进程</strong>的注册表<br><strong>开始运行新进程</strong></li>
</ul>
</li>
<li>硬件<ul>
<li><strong>实现物理I/O的操作，关于I/O操作的性能的问题</strong></li>
</ul>
</li>
</ul>
<h4 id="I-O软件设计目标"><a href="#I-O软件设计目标" class="headerlink" title="I/O软件设计目标"></a>I/O软件设计目标</h4><h6 id="设备独立性（设备无关性）"><a href="#设备独立性（设备无关性）" class="headerlink" title="设备独立性（设备无关性）"></a>设备独立性（设备无关性）</h6><p>用户编写的程序可以<strong>访问任意I/O设备</strong>，<strong>无需事先指定设备</strong>（软盘，硬盘或CD-ROM）</p>
<p>好处：设备分配时的灵活性，易于实现I/O重定向</p>
<p>从用户角度：用户在编制程序时，使用逻辑设备名，由系统实现从逻辑设备到物理设备（实际设备）的转换，并实施I/O操作</p>
<p>从系统角度：设计并实现I/O软件时，除了直接与设备打交道的低层软件之外，其他部分的软件不依赖于硬件</p>
<h6 id="统一命名"><a href="#统一命名" class="headerlink" title="统一命名"></a>统一命名</h6><p>文件或设备的名称应该只是一个字符串或整数，而<strong>不是以任何方式依赖于设备</strong></p>
<h6 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h6><p><strong>错误</strong>应该尽可能地在<strong>接近硬件的层面处理</strong></p>
<h6 id="同步与异步传输"><a href="#同步与异步传输" class="headerlink" title="同步与异步传输"></a>同步与异步传输</h6><p>阻塞与中断驱动</p>
<h6 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h6><p>从设备发出的数据不能直接存储在最终目的地</p>
<h6 id="共享与独占设备"><a href="#共享与独占设备" class="headerlink" title="共享与独占设备"></a>共享与独占设备</h6><p>磁盘是共享的，磁带驱动器是独占的</p>
<h3 id="I-O相关技术"><a href="#I-O相关技术" class="headerlink" title="I/O相关技术"></a>I/O相关技术</h3><h4 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h4><ul>
<li><strong>解决CPU与I/O设备之间速度的不匹配问题</strong>（现在凡是数据到达和离去速度不匹配的地方均可采用缓冲技术</li>
<li>提高CPU与I/O设备之间的<strong>并行性</strong></li>
<li><strong>减少了I/O设备对CPU的中断请求次数</strong>，放宽CPU对中断响应时间的要求</li>
</ul>
<p><strong>缓冲区</strong></p>
<ul>
<li>分类<ul>
<li>硬缓冲区：由硬件寄存器实现（例如：设备中设置的缓冲区）</li>
<li>软缓冲区：在内存中开辟一个空间，用作缓冲区</li>
</ul>
</li>
<li>管理<ul>
<li>单缓冲</li>
<li>双缓冲</li>
<li>缓冲池（多缓冲、循环缓冲）：统一管理多个缓冲区，采用有界缓冲区的生产者/消费者模型对缓冲池中的缓冲区进行循环使用</li>
</ul>
</li>
</ul>
<p><strong>unix SYSTEM V缓冲技术</strong></p>
<ul>
<li>采用缓冲池技术，可平滑和加快信息在内存和磁盘之间的传输<ul>
<li>缓冲区结合提前读和延迟写技术对具有重复性及阵发性I/O进程、提高I/O速度很有帮助</li>
<li>可以充分利用之前从磁盘读入、虽已传入用户区但仍在缓冲区的数据（尽可能减少磁盘I/O的次数，提高系统运行的速度</li>
</ul>
</li>
<li>数据结构<ul>
<li>200个缓冲区（每个512字节或1024字节）</li>
<li>每个缓冲区由缓冲控制块或缓冲首部+缓冲数据区构成，系统通过缓冲控制块来实现对缓冲区的管理</li>
<li>空闲缓冲区队列（av链）队列头部为bfreelist</li>
<li>设备缓冲队列（b链）链接所有分配给各类设备使用的缓冲区，按照散列方式阻止</li>
<li>逻辑设备号+盘块号是缓冲区的唯一标志</li>
<li>每个缓冲区可同时在av链和b链中（I/O完成后）</li>
</ul>
</li>
</ul>
<h3 id="I-O设备管理"><a href="#I-O设备管理" class="headerlink" title="I/O设备管理"></a>I/O设备管理</h3><p><strong>数据结构</strong></p>
<ul>
<li>描述设备、控制器等部件的表格<ul>
<li>每个部件、每台设备分别设置一张表格，常称为设备表或部件控制块</li>
</ul>
</li>
<li>建立同类资源的队列</li>
<li>面向进程I/O请求的动态数据结构</li>
<li>建立I/O队列</li>
</ul>
<p><strong>独占设备的分配</strong></p>
<ul>
<li>静态分配<ul>
<li>在进程运行前，完成设备分配；运行结束时，收回设备</li>
<li>缺点：设备利用率低</li>
</ul>
</li>
<li>动态分配<ul>
<li>在进程运行过程中，当用户提出设备要求时，进行分配，一旦停止使用立即收回</li>
<li>优点：效率高</li>
<li>缺点：分配策略不好时，产生死锁</li>
</ul>
</li>
</ul>
<p><strong>分时式共享设备的分配</strong></p>
<ul>
<li>所谓分时式共享就是以一次I/O为单位分时使用设备，不同进程的I/O操作请求以排队方式分时地占用设备进行I/O</li>
<li>由于同时有多个进程同时访问，且访问频繁，就会影响整个设备使用效率，影响系统效率。因此要考虑多个访问请求到达时服务的顺序，使平均服务时间越短越好</li>
</ul>
<p><strong>设备驱动程序</strong></p>
<ul>
<li>一般，设备驱动程序的任务是接受来自与设备无关的上层软件的抽象请求，并执行这个请求</li>
<li>每一个控制器都设有一个或多个设备寄存器，用来存放向设备发送的命令和参数。设备驱动程序负责释放这些命令，并监督它们正确执行</li>
<li>接口<ul>
<li>与操作系统的接口：为实现设备无关性，设备作为特殊文件处理。用户的I/o请求、对命令的合法性检查以及参数处理在文件系统中完成。在需要各种设备执行具体操作时，通过相应数据结构转入不同的设备驱动程序。</li>
<li>与系统引导接口（初始化，包括分配数据结构，建立设备的请求队列）</li>
<li>与设备的接口</li>
</ul>
</li>
<li>接口函数<ul>
<li>驱动程序初始化函数</li>
<li>驱动程序卸载函数</li>
<li>申请设备函数</li>
<li>释放设备函数</li>
<li>I/O操作函数</li>
<li>中断处理函数</li>
</ul>
</li>
</ul>
<p><strong>I/O进程</strong></p>
<ul>
<li>专门处理系统中的I/O请求和I/O中断工作</li>
<li><strong>是系统进程，一般赋予最高优先级。</strong>一旦被唤醒，可以很快抢占处理机投入运行</li>
<li>I/O进程开始运行后，首先关闭中断，然后用receive去接收消息<ul>
<li>没有消息，则开中断，将自己阻塞</li>
<li>有消息，则判断消息类型<ul>
<li>I/O请求的进入<ul>
<li>准备通道程序，发出启动I/O指令，继续判断有无消息</li>
<li>用户程序：调用send将I/O请求发送给I/O进程；调用block将自己阻塞，直到I/O任务完成后被唤醒</li>
<li>系统：利用wakeup唤醒I/o进程，完成用户所要求的I/o处理</li>
</ul>
</li>
<li>I/O中断的进入<ul>
<li>进一步判断正常或异常结束<ul>
<li>正常：唤醒要求进行I/O操作的进程</li>
<li>异常：转入相应的错误处理程序</li>
</ul>
</li>
<li>当I/O中断发送时，内核中的中断处理程序发一条消息给I/O进程，由I/O进程负责判断并处理中断</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="I-O性能问题"><a href="#I-O性能问题" class="headerlink" title="I/O性能问题"></a>I/O性能问题</h3><p>从两个角度入手：</p>
<ul>
<li>使CPU利用率尽可能不被I/O降低<ul>
<li><strong>减少或缓解速度差距：缓冲技术</strong></li>
<li><strong>使CPU不等待I/O：异步I/O</strong></li>
</ul>
</li>
<li>使CPU尽可能摆脱I/O<ul>
<li><strong>DMA、通道</strong></li>
</ul>
</li>
</ul>
<h4 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h4><p>用于优化应用程序的性能</p>
<p>通过异步I/O，应用程序可以启动一个I/O操作，然后在I/O请求执行的同时继续处理</p>
<p>基本思想：填充I/O操作间等待的CPU时间</p>
<h4 id="同步I-O"><a href="#同步I-O" class="headerlink" title="同步I/O"></a>同步I/O</h4><p>应用程序被阻塞直到I/O操作完成</p>
<h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p>可编程时钟的操作模式</p>
<ul>
<li>一次性模式（一次完成模式）<br>当时钟启动时，它将保持寄存器的值复制到计数器中，然后在晶体的每个脉冲处<strong>递减计数器</strong><br>当计数器变为零时，它会导致<strong>中断并停止</strong>，直到软件再次明确说明</li>
<li>square-wave mode（方波模式）<br>在<strong>达到零并导致中断后</strong>，<strong>保持寄存器自动复制到计数器</strong><br>这些<strong>周期性中断</strong>称为<strong>时钟周期</strong></li>
</ul>
<p>时钟驱动器的任务</p>
<ul>
<li>保持一天的时间</li>
<li>防止进程运行的时间超过允许的时间</li>
<li>考虑CPU使用率</li>
<li>处理用户进程发出的警报系统调用</li>
<li>为部分系统本身提供监视定时器</li>
<li>进行性能分析，监视和统计信息收集</li>
</ul>
<p>如果时钟驱动程序有足够的时钟，它可以为每个请求设置一个单独的时钟。否则，必须用一个物理时钟来模拟多个虚拟时钟</p>
<h3 id="瘦客户端"><a href="#瘦客户端" class="headerlink" title="瘦客户端"></a>瘦客户端</h3><p>多年来，主要的计算范例在集中式计算和分散计算之间摇摆不定；大多数用户都想要高性能的交互式计算，但实际上并不想管理计算机，这导致研究人员使用满足现代终端期望的瘦客户端重新检查分时共享</p>
<p>如，THINC，客户端只作为显示用，所有计算都在服务器端完成</p>
<h3 id="电源管理"><a href="#电源管理" class="headerlink" title="电源管理"></a>电源管理</h3><ul>
<li>电的消耗<ul>
<li>环境需要</li>
</ul>
</li>
<li>电池供电的电脑<ul>
<li>电池不能保持足够的电量持续很长时间</li>
</ul>
</li>
<li>两种降低能耗的一般方法<ul>
<li>操作系统在不使用时关闭计算机的部件<ul>
<li>CPU<br>笔记本电脑CPU可以通过软件进入睡眠状态，将功耗降低到几乎为零<br>它在这种状态下唯一能做的就是在发生中断时唤醒</li>
<li>显示器<ul>
<li>一部分开启，一部分关闭</li>
</ul>
</li>
<li>硬盘<br>几分钟不活动后旋转磁盘<br>Td  - 磁盘的收支平衡点，5~15秒<br>RAM中有大量的磁盘缓存<br>通过发送消息或信号，让运行程序了解磁盘状态</li>
<li>内存<br>缓存可以刷新然后关闭<br>将主内存的内容写入磁盘，然后关闭主内存</li>
<li>无线通信<br>当关闭无线设备时，基站在其磁盘上缓冲到来的消息。</li>
<li>Thermal Management（热量管理）</li>
<li>电池管理</li>
<li>驱动程序接口<br>ACPI（高级配置和电源接口，高级配置与电源接口）</li>
</ul>
</li>
<li>应用程序使用更少的能源<ul>
<li>可能意味着较差的用户体验<br>例子：颜色输出变为黑白，语音识别减少了词汇量，图像中的分辨率或细节较少</li>
</ul>
</li>
</ul>
</li>
<li>电池有两种通用类型：<ul>
<li>一次性的（一次性使用）<br>可用于运行手持设备<br>最常见的是AAA，AA和D细胞</li>
<li>可再充电的（可再充电的）<br>可以储存足够的能量为笔记本电脑供电几个小时<br>电池节约的一般方法是将CPU，内存和I / O设备设计为具有多种状态：开，睡，休眠（休眠）和关闭</li>
</ul>
</li>
<li></li>
</ul>
<h3 id="quiz-11-错题和模糊题"><a href="#quiz-11-错题和模糊题" class="headerlink" title="quiz 11 错题和模糊题"></a>quiz 11 错题和模糊题</h3><p>1，2，3，4，5如图选择</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz11.1.png" alt=""></p>
<p><img src="/2018/12/08/操作系统-笔记/quiz11.2.png" alt="quiz11.2"></p>
<p>第六题应选择1 2 4 5</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz11.3.png" alt="quiz11.3"></p>
<p>第九题如图</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz11.4.png" alt=""></p>
<p>应填入 设备无关软件/设备独立软件/设备独立性软件/设备无关性软件/逻辑I/O</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz11.5.png" alt="quiz11.5"></p>
<h3 id="PPT练习题-4"><a href="#PPT练习题-4" class="headerlink" title="PPT练习题"></a>PPT练习题</h3><ol>
<li><p>In which of the four I/O software layers is each of the following done.</p>
<ul>
<li>Computing the track, sector and head for a disk read</li>
<li>Writing commands to the device registers</li>
<li>Checking to see if the user is permitted to use the device</li>
<li>Converting binary integers to ASCII for printing</li>
</ul>
<p>分析：</p>
<p><img src="/2018/12/08/操作系统-笔记/分层I:O.png" alt=""></p>
<p>a. 设备驱动层</p>
<p>b. 设备驱动层</p>
<p>c. 设备独立软件层（protection）</p>
<p>d. 用户空间软件层（format I/O）</p>
</li>
<li><p>Disk requests come into the disk driver for cylinders 10, 22, 20, 2, 40, 6, and 38, in that order. In all cases, the arm is initially at cylinder 20. A seek takes 6 mesc per cylinder moved. How much seek times is needed for</p>
<ul>
<li>First Come first Served (FCFS) </li>
<li>Shortest Seek Time First (SSTF) </li>
<li>Elevator algorithm (SCAN, initially moving upward) </li>
</ul>
<p>分析：</p>
<p>20-10-22-20-2-40-6-38   [（20-10）+（22-10）+（22-20）+（20-2）+（40-2）+（40-6）+（38-6）]*6=876mesc</p>
<p>20-22-10-6-2-38-40   [（22-20）+（22-10）+（10-6）+（6-2）+（38-2）+（40-38）]*6=360mesc</p>
<p>20-22-38-40-10-6-2      [（22-20）+（38-22）+（40-38）+（40-10）+（10-6）+（6-2）]*6=348mesc</p>
</li>
<li><p>假定一磁盘有200个柱面，编号为0~199，当前存取臂的位置在143号柱面上，并刚刚完成了125号柱面的服务请求，如果请求队列的先后顺序是：86，147，91，177，94，150，102，175，130。为完成上述请求，下列算法存取臂移动的总量是多少？写出存取臂移动的顺序【FCFS，SSTF，SCAN】</p>
<p>分析：</p>
<p>143-86-147-91-177-94-150-102-175-130</p>
<p>存取臂移动的总量：57+61+56+86+83+56+48+73+45=565</p>
<p>143-147-150-130-102-94-91-86-175-177</p>
<p>存取臂移动的总量：4+3+20+28+8+3+5+89+2=162</p>
<p>143-147-150-175-177-130-102-94-91-86</p>
<p>存取臂移动的总量：4+3+25+2+47+28+8+3+5=125</p>
</li>
</ol>
<h2 id="死锁-1"><a href="#死锁-1" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的基本概念"><a href="#死锁的基本概念" class="headerlink" title="死锁的基本概念"></a>死锁的基本概念</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>一组进程中，每个进程都<strong>无限等待</strong>被该组进程中<strong>另一进程</strong>所占有的资源，因而永远无法得到的资源，这种现象称为进程死锁，这一组进程就称为死锁进程</p>
<ul>
<li>参与死锁的所有进程都在等待状态（所以都处在等待状态或者阻塞状态）</li>
<li>参与死锁的进程是当前系统中所有进程的子集</li>
</ul>
<h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><p><em>资源数量有限、锁和信号量错误使用</em></p>
<h4 id="产生条件"><a href="#产生条件" class="headerlink" title="产生条件"></a>产生条件</h4><ul>
<li>互斥使用（资源独占）<ul>
<li>一个资源每次只能给一个进程使用</li>
</ul>
</li>
<li>占有且等待（请求和保持，<strong>部分分配</strong>）<ul>
<li>进程在<strong>申请新的资源</strong>的同时<strong>保持对原有资源的占有</strong></li>
</ul>
</li>
<li>不可抢占（不可剥夺）<ul>
<li>资源申请者不能强行的从资源占有者手中夺取资源，资源只能由占有者资源释放</li>
</ul>
</li>
<li>循环等待<ul>
<li>存在一个进程等待队列$\{P_1,P_2,\cdot\cdot\cdot,P_n\}$</li>
<li>其中$P_1$等待$P_2$占有的资源，$P_2$等待$P_3$占有的资源，$\cdot\cdot\cdot$，$P_n$等待$P_1$占有的资源，形成一个进程等待环路</li>
</ul>
</li>
</ul>
<p><strong>资源的使用方式：</strong></p>
<p>“申请—分配—使用—释放”模式</p>
<p><strong>可重用资源：</strong>可被多个进程多次使用</p>
<p>又可分为可抢占资源（CPU、内存）与不可抢占资源（打印机）</p>
<p>例如：处理器、I/O部件、<strong>内存</strong>、文件、数据库、信号量</p>
<p><strong>可消耗资源：</strong>只可使用一次、可创建和销毁的资源</p>
<p>例如：信号、中断、消息</p>
<h4 id="活锁和饥饿"><a href="#活锁和饥饿" class="headerlink" title="活锁和饥饿"></a>活锁和饥饿</h4><p>活锁（既无进展也没有阻塞）</p>
<ul>
<li>先加锁</li>
<li>再轮询【忙等待】（超时后，下CPU，再过段时间上CPU，不断循环）</li>
</ul>
<p>饥饿（资源分配策略决定）</p>
<h3 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h3><p>RAG: Resoure allocation graph</p>
<p>用<strong>有向图</strong>描述系统资源和进程的状态，从而来解决死锁的问题</p>
<p>通过二元组$G=(V,E)$</p>
<p>V:  结点的集合，分为P（进程），R（资源）两部分</p>
<p>E：有向边的集合，其元素为有序二元组</p>
<p>系统由若干类资源构成，一类资源称为一个资源类；每个资源类中若干个同种资源，称为资源实例</p>
<p>资源类：方框表示</p>
<p>资源实例：方框中的黑圆点表示</p>
<p>进程：用圆圈中加进程名表示</p>
<p>分配边：资源实例-&gt;进程（资源实例分配给某进程）</p>
<p>申请边：进程-&gt;资源类（进程申请某类资源）</p>
<h4 id="资源分配图化简"><a href="#资源分配图化简" class="headerlink" title="资源分配图化简"></a>资源分配图化简</h4><ol>
<li><p>寻找一个非孤立、且<strong>只有分配边</strong>（资源都充足，可以完成进程）的进程结点</p>
<p>去掉分配边，将其变为孤立节点</p>
</li>
<li><p>再把相应的资源分配给一个等待该资源的进程，即将该进程的申请边变为分配边（先后顺序无关）</p>
</li>
<li><p>重复1、2，直到找不到点了；那么如果只剩下孤立节点，就是没有死锁存在的；否则就存在环路</p>
</li>
</ol>
<h4 id="死锁定理"><a href="#死锁定理" class="headerlink" title="死锁定理"></a>死锁定理</h4><ul>
<li>如果资源分配图中没有环路，则系统中没有死锁；如果图中存在环路则系统中<strong>可能</strong>存在死锁</li>
<li>如果每个资源类中只包含一个资源实例，则环路是死锁存在的充分必要条件</li>
</ul>
<h3 id="资源轨迹图"><a href="#资源轨迹图" class="headerlink" title="资源轨迹图"></a>资源轨迹图</h3><p>Resource Trajectories</p>
<p>如果直到了进程在各个阶段需要哪些资源，那么可以在图中进程标注；两个进程的交叠区域就是一个会造成死锁的区域；进程在图中只能向右或者向上前进，一旦进入了危险区，那么就可能发生死锁；为了避免死锁，应当在合适的时间阻塞某个进程，使得运行避开这个区域</p>
<p><img src="/2018/12/08/操作系统-笔记/资源轨迹图.png" alt=""></p>
<p>A在I1-I3使用Printer，在I2-I4使用Plotter；同理B</p>
<p>现在资源的分配是虚线的走法，如果要安全则要避开交叠区域，比如到左下角这个点的时候，则会出现，A占用Printer，并且还需要保持，B占用Plotter，并且还需要保持</p>
<h3 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h3><h4 id="不考虑死锁问题"><a href="#不考虑死锁问题" class="headerlink" title="不考虑死锁问题"></a>不考虑死锁问题</h4><h5 id="鸵鸟算法"><a href="#鸵鸟算法" class="headerlink" title="鸵鸟算法"></a>鸵鸟算法</h5><h4 id="不让死锁发生"><a href="#不让死锁发生" class="headerlink" title="不让死锁发生"></a>不让死锁发生</h4><h5 id="死锁预防deadlock-prevention"><a href="#死锁预防deadlock-prevention" class="headerlink" title="死锁预防deadlock prevention"></a>死锁预防deadlock prevention</h5><p><strong>静态</strong>策略：设计合适的<strong>资源分配算法</strong>，不让死锁发生</p>
<p>具体做法：破坏产生死锁的四个必要条件之一</p>
<ul>
<li>互斥使用（资源独占）<ul>
<li>资源转换技术：把独占资源变为共享资源</li>
<li>SPOOLing技术的引入<ul>
<li>解决不允许任何进程直接占有打印机的问题</li>
<li>设计一个“守护进程/线程daemon”负责管理打印机，进程需要打印时，将请求发给该daemon，由它完成打印任务</li>
</ul>
</li>
<li>核心思想：如果资源不被一个进程独占，那么就不会发生死锁</li>
<li>原理：<ul>
<li>避免在不必要时分配资源</li>
<li>尽可能少的进程占用资源</li>
</ul>
</li>
</ul>
</li>
<li>占有且等待（请求和保持，部分分配）<ul>
<li>核心思想：禁止已持有资源的进程再等待其他资源</li>
<li>问题：进程在运行开始时可能不知道所需的资源，还会占用其他流程可能使用的资源</li>
<li>实现方案一：要求每个进程在运行前<strong>必须一次性</strong>申请它所要求的<strong>所有资源</strong>，且仅当该进程所要资源均可满足时才给予一次性分配，<strong>资源静态分配</strong><ul>
<li>资源利用率低；会产生“饥饿”现象</li>
</ul>
</li>
<li>实现方法二：在允许进程动态申请资源前提下规定，一个进程在申请新的资源不能立即得到满足而变为等待状态之前，<strong>必须释放已占有的全部资源</strong>，若需要再重新申请<ul>
<li>也会产生“饥饿”现象</li>
</ul>
</li>
</ul>
</li>
<li>不可抢占（不可剥夺）<ul>
<li>当一个进程申请的资源被其他进程占用时，可以通过操作系统抢占这一资源（两个进程优先级不同）  </li>
<li>局限性：适用于状态易于保存和恢复的资源（CPU【进程抢占】、内存【页面置换算法】）  </li>
<li>不可行的，例如一个打印机在执行的时候，被抢占了……</li>
</ul>
</li>
<li>循环等待<ul>
<li>通过定义资源类型的<strong>线性顺序</strong>实现</li>
<li>方案一：保证每个进程在任何时刻只能占用一个资源。若需要另外一个资源，必须先释放第一个资源<ul>
<li>若进程正在把一个大文件从磁带机上读入并送到打印机打印，那么这种限制是不可接受的</li>
</ul>
</li>
<li>方案二：<strong>资源有序分配法</strong><ul>
<li>把系统中所有资源编号，进程在申请资源时必须严格<strong>按资源编号的递增次序进行</strong>，否则操作系统不予分配</li>
<li>常使用的资源，放在前面；不常使用的资源，放在后面  </li>
<li>可以通过此方法解决哲学家就餐问题</li>
<li>但是几乎找不到一种令每个人都满意的编号次序</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h5><p><strong>动态</strong>策略：以不让死锁发生为目标，跟踪（动态）并评估资源分配过程，根据评估结果决策是否分配【若分配后系统发生死锁或可能发生死锁，则不予分配，否则（安全状态）予以分配】</p>
<p>安全状态：如果系统中存在一个由所有进程构成的安全序列$P_1,\cdot\cdot\cdot,P_n​$，则称系统处于安全状态【安全状态一定没有死锁发生】</p>
<p>安全序列：一个进程序列$\{P_1,\cdot\cdot\cdot,P_n\}$是安全的，如果对于每一个进程$P_i(1\leq i \leq n)$： 它以后还需要的资源量不超过系统当前剩余资源量与所有进程$P_j(j&lt;i)$当前占有资源量之和，则称系统处于安全状态</p>
<p>不安全状态：系统中不存在一个安全序列【不安全状态一定导致死锁，但是目前不一定在死锁状态，即死锁状态是不安全状态的子集】</p>
<h6 id="银行家算法-Banker’s-Algorithm"><a href="#银行家算法-Banker’s-Algorithm" class="headerlink" title="银行家算法 Banker’s Algorithm"></a>银行家算法 Banker’s Algorithm</h6><p>仿照银行发放贷款时采取的控制方式而设计的一种<strong>死锁避免算法</strong></p>
<p><strong>应用条件：</strong></p>
<ul>
<li>在固定数量的进程中共享固定的资源</li>
<li>每个进程预先指定完成工作所需的最大资源数量</li>
<li>进程不能申请比系统中可用资源总数还多的资源</li>
<li>进程等待资源的时间是有限的</li>
<li>如果系统满足了进程对资源的最大需求，那么，进程应该在有限的时间内使用资源，然后归还给系统</li>
</ul>
<p><strong>Algorithm:</strong></p>
<blockquote>
<p>n：系统中进程数量</p>
<p>m：资源类数量</p>
<p>Available：Array[1..m] of integer 资源（总共m个，剩余的可用量）</p>
<p>Max： Array[1..n,1..m] of integer 每一个进程对每一类资源的最大需求量</p>
<p>Allocation：Array[1..n,1..m] of integer 当前系统中哪些进程得到了哪些资源（即分配给这个进程的资源的数量）</p>
<p>Need：Array[1..n,1..m] of integer 每个进程对每一类资源还需要的资源量</p>
<p>Request：Array[1..n,1..m] of integer 本次进程对资源的申请量</p>
</blockquote>
<p>当进程Pi提出资源申请时，系统执行下列步骤：</p>
<p>1）若Request[i]&lt;=Need[i]，转（2）；否则，报错返回</p>
<p>2）若Request[i]&lt;=Available，转（3）；否则，进程等待</p>
<p>3）假设系统分配了资源，则有（系统新状态）：</p>
<p>​    Available = Available - Request[i];</p>
<p>​    Allocation[i] = Allocation[i] + Request[i];</p>
<p>​    Need[i] = Need[i] - Request[i];</p>
<p>​    若系统新状态是安全的，则分配完成</p>
<p>​    若系统新状态是不安全的，则恢复原来状态，进程等待</p>
<p>为进行安全性检查，定义数据结构：</p>
<blockquote>
<p>Work：Array[1..m] of integer</p>
<p>Finish：Array[1..n] of integer</p>
</blockquote>
<p>安全性检查的步骤：</p>
<p>1）  Work = Available;</p>
<p>​    Finish = false;</p>
<p>2）寻找满足条件的i：</p>
<pre><code>  a. Finish[i] == false;

  b. Need[i] &lt;= Work;
</code></pre><p>​      如果不存在，则转（4）</p>
<p>3）Work = Work + Allocation[i];</p>
<p>​      Finish[i] = true;</p>
<p>​      转（2）</p>
<p>4）若对所有i，Finish[i] == true，则系统处于安全状态，否则系统处于不安全状态</p>
<h4 id="让死锁发生"><a href="#让死锁发生" class="headerlink" title="让死锁发生"></a>让死锁发生</h4><h5 id="死锁检测与解除"><a href="#死锁检测与解除" class="headerlink" title="死锁检测与解除"></a>死锁检测与解除</h5><h6 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h6><ul>
<li>允许死锁发生，但是操作系统会<strong>不断监视操作系统进展情况</strong>，判断死锁是否真的发生</li>
<li>一旦死锁发生则采取专门的措施，<strong>解除死锁</strong>并以<strong>最小的代价</strong>恢复操作系统运行</li>
</ul>
<p>检测时机：</p>
<ul>
<li>当进程由于资源请求不满足而等待时检测死锁<ul>
<li>缺点：系统开销大</li>
</ul>
</li>
<li>定时检测</li>
<li>系统资源利用率下降时检测死锁</li>
</ul>
<p><strong>一个简单的死锁检测算法</strong></p>
<ul>
<li>每个进程、资源指定唯一编号</li>
<li>设置一张资源分配表，记录各进程与其占用资源之间的关系</li>
<li>设置一张进程等待表，记录各进程与要申请资源之间的关系</li>
</ul>
<p>通过寻找进程等待表，找对应资源；再去资源分配表中寻找这个资源被哪一进程占用了；如此反复循环，直到被占用的资源的进程不出现在进程等待表（说明不存在死锁）或者直到被占用的资源的进程出现在之前找到过的进程中（说明出现了死锁）</p>
<h6 id="死锁解除"><a href="#死锁解除" class="headerlink" title="死锁解除"></a>死锁解除</h6><p>利用<strong>抢占恢复/回退恢复/杀死（撤销）进程</strong></p>
<ul>
<li>撤销所有死锁进程【所有：消耗过大】</li>
<li>进程回退（Roll back）再启动【记录进程中的中间点，每一个进程都后退一步，但是记录中间点需要很多消耗】</li>
<li>按照某种原则<strong>逐一</strong>撤销<strong>死锁进程</strong>，直到……</li>
<li>按照某种原则<strong>逐一</strong>抢占<strong>资源</strong>（资源被抢占的进程必须回退到之前的对应状态），直到……</li>
</ul>
<p>后面两种需要进行“选择原则”</p>
<h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><ul>
<li>两阶段加锁（第一阶段：对所需资源加锁；第二阶段：更新，释放锁）适合数据库</li>
<li>通信死锁（避免通信死锁的方法：超时）</li>
</ul>
<h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p>问题描述：</p>
<p>有五个哲学家围坐在一圆桌旁，每个人面前有一只空盘子，每两个人之间放一只筷子；每个哲学家的行为是<strong>思考</strong>，感到<strong>饥饿</strong>，然后<strong>吃</strong>通心粉；为了吃通心粉，每个哲学家必须拿到两只筷子，并且每个人只能直接从自己的左边或右边去取筷子（<strong>筷子的互斥使用、不能出现死锁现象</strong>）</p>
<p>问题模型：</p>
<p>应用程序中并发线程执行时，协调处理共享资源</p>
<h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h5><p><strong>把筷子当作一个信号量来处理；</strong>拿筷子时，对筷子进行P操作，申请筷子（都是先申请右边的，再申请左边的）</p>
<h6 id="何时发生死锁？"><a href="#何时发生死锁？" class="headerlink" title="何时发生死锁？"></a>何时发生死锁？</h6><p>当每个哲学家都拿到右边的筷子，都等待左边的筷子时，发生死锁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">semaphore fork[<span class="number">5</span>] = &#123;<span class="number">1</span>&#125;;</div><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">        think();</div><div class="line">        P(fork[i]);</div><div class="line">        P(fork[(i+<span class="number">1</span>) mod <span class="number">5</span>]);</div><div class="line">        eat();</div><div class="line">        V(fork[(i+<span class="number">1</span>) mod <span class="number">5</span>]);</div><div class="line">        V(fork[i]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    parbegin(philosopher(<span class="number">0</span>),philosopher(<span class="number">1</span>),philosopher(<span class="number">2</span>),philosopher(<span class="number">3</span>),philosopher(<span class="number">4</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="怎样从死锁中恢复？"><a href="#怎样从死锁中恢复？" class="headerlink" title="怎样从死锁中恢复？"></a>怎样从死锁中恢复？</h6><p>某个哲学家放下一只筷子</p>
<h6 id="怎样避免死锁的发生？"><a href="#怎样避免死锁的发生？" class="headerlink" title="怎样避免死锁的发生？"></a>怎样避免死锁的发生？</h6><ul>
<li>最多允许4个哲学家同时坐在桌子周围（思考的时候让他四处溜达）</li>
</ul>
<p>【增加一个新的信号量<code>room</code>，表示是否有空间可以让哲学家坐在桌子边上】</p>
<p>{是一种鸽巢原理或者是抽屉原理，银行家算法}</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">semaphore fork[<span class="number">5</span>] = &#123;<span class="number">1</span>&#125;;</div><div class="line">semaphore room = &#123;<span class="number">4</span>&#125;;</div><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">        think();</div><div class="line">        P(room); <span class="comment">// 最多允许4个哲学家同时坐在桌子周围</span></div><div class="line">        P(fork[i]);</div><div class="line">        P(fork[(i+<span class="number">1</span>) mod <span class="number">5</span>]);</div><div class="line">        eat();</div><div class="line">        V(fork[(i+<span class="number">1</span>) mod <span class="number">5</span>]);</div><div class="line">        V(fork[i]);</div><div class="line">        V(room);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    parbegin(philosopher(<span class="number">0</span>),philosopher(<span class="number">1</span>),philosopher(<span class="number">2</span>),philosopher(<span class="number">3</span>),philosopher(<span class="number">4</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>仅当一个哲学家左右两边的筷子都可用时，才允许它拿筷子</p>
<p>通过信号量来实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></div><div class="line"><span class="comment">// 把哲学家分为三种状态：思考，饥饿，进食</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> THINKING 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HUNGRY 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> EATING 2</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</div><div class="line"><span class="keyword">int</span> state[N];</div><div class="line">semaphore mutex = <span class="number">1</span>;</div><div class="line">semaphore s[N];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">        think();</div><div class="line">        </div><div class="line">        P(&amp;mutex);</div><div class="line">        state[i] = HUNGRY;</div><div class="line">        test(i); <span class="comment">// 判断是否能同时拿到两只筷子</span></div><div class="line">        V(&amp;mutex);</div><div class="line">        </div><div class="line">        P(&amp;s[i]);<span class="comment">// 如果test通过，则在里面进行了V操作，所以这里就可以用P操作了；否则阻塞在P操作了</span></div><div class="line">        <span class="comment">// 拿左筷子</span></div><div class="line">        <span class="comment">// 拿右筷子</span></div><div class="line">        eat();</div><div class="line">        <span class="comment">// 放左筷子</span></div><div class="line">        <span class="comment">// 放右筷子</span></div><div class="line">        </div><div class="line">        P(&amp;mutex); </div><div class="line">        state[i] = THINKING;</div><div class="line">        test([i<span class="number">-1</span>]%<span class="number">5</span>); <span class="comment">// 对左右哲学家进行测试，看是不是因为刚才i号哲学家吃饭，抢走了周围哲学家的筷子</span></div><div class="line">        test([i+<span class="number">1</span>]%<span class="number">5</span>);</div><div class="line">        V(&amp;mutex);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(state[i] == HUNGRY &amp;&amp; (state[(i<span class="number">-1</span>)%<span class="number">5</span>] != EATING) &amp;&amp; (state[(i+<span class="number">1</span>)%<span class="number">5</span>] != EATING))&#123;</div><div class="line">        state[i] = EATING;</div><div class="line">        V(&amp;s[i]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过<strong>管程</strong>来解决</p>
<p>伪代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> philosopher[k=<span class="number">0</span> to <span class="number">4</span>]</div><div class="line"><span class="comment">/* the five philosopher clients */</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">        &lt;think&gt;;</div><div class="line">        get_forks(k); <span class="comment">/* client requests two forks via monitor */</span></div><div class="line">        &lt;eat spaghetti&gt;;</div><div class="line">        release_forks(k); <span class="comment">/* client releases forks via the monitor */</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">monitor dining_controller;</div><div class="line">cond ForkReady[<span class="number">5</span>];</div><div class="line">boolean fork[<span class="number">5</span>] = &#123;<span class="literal">true</span>&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_forks</span><span class="params">(<span class="keyword">int</span> pid)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> left = pid;</div><div class="line">    <span class="keyword">int</span> right = (++pid)%<span class="number">5</span>;</div><div class="line">    <span class="comment">/* grant the left fork */</span></div><div class="line">    <span class="keyword">if</span>(!fork[left])</div><div class="line">       cwait(ForkReady[left]);</div><div class="line">    <span class="comment">/* queue on condition variable */</span></div><div class="line">    fork[left] = <span class="literal">false</span>;</div><div class="line">    <span class="comment">/* grant the right fork */</span></div><div class="line">    <span class="keyword">if</span>(!fork[right]) </div><div class="line">       cwait(ForkReady[right]);</div><div class="line">    <span class="comment">/* queue on cindition variable */</span></div><div class="line">    fork[right] = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_forks</span><span class="params">(<span class="keyword">int</span> pid)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> left = pid;</div><div class="line">    <span class="keyword">int</span> right = (++pid)%<span class="number">5</span>;</div><div class="line">    <span class="comment">/* release the left fork */</span></div><div class="line">    <span class="keyword">if</span>(!empty(ForkReady[left]))</div><div class="line">       <span class="comment">/* no one is waiting for this fork */</span></div><div class="line">       fork[left] = <span class="literal">true</span>;</div><div class="line">    <span class="comment">/* awaken a process waiting on fork */</span></div><div class="line">    <span class="keyword">else</span> csignal(ForkReady[left]);</div><div class="line">    <span class="comment">/* release the right fork */</span></div><div class="line">    <span class="keyword">if</span>(!empty(ForkReady[right]))</div><div class="line">       <span class="comment">/* no one is waiting for this fork */</span></div><div class="line">       fork[left] = <span class="literal">true</span>;</div><div class="line">    <span class="comment">/* awaken a process waiting on fork */</span></div><div class="line">    <span class="keyword">else</span> csignal(ForkReady[right]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>给所有哲学家编号，奇数号的哲学家必须首先拿左边的筷子，偶数号的哲学家则反之</p>
</li>
<li><p>……</p>
</li>
</ul>
<h6 id="如何预防死锁？"><a href="#如何预防死锁？" class="headerlink" title="如何预防死锁？"></a>如何预防死锁？</h6><ul>
<li>一次性分配思想（一次拿两只筷子）</li>
<li>资源的有序分配（先拿大编号，再拿小编号的筷子，对于第五个就先拿左边，再拿右边的；其余都是先拿右边的，再拿左边的）</li>
</ul>
<h3 id="quiz-12-错题和模糊题"><a href="#quiz-12-错题和模糊题" class="headerlink" title="quiz 12 错题和模糊题"></a>quiz 12 错题和模糊题</h3><p>如图选择</p>
<p>第二题：能上CPU，但是得不到资源</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz12.1.png" alt=""></p>
<p>如图选择</p>
<p>死锁预防，是未进入之前，设定好的资源分配策略</p>
<p>死锁避免，是进入之后，决定下一步是否安全，银行家算法</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz12.2.png" alt="quiz12.2"></p>
<p>应选择4</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz12.3.png" alt=""></p>
<p>应选择4，因为“<strong>分配后</strong>系统”</p>
<p>应选择3（2个该类资源）</p>
<p>因为共有3个进程，5个资源，进程数小于资源数，则不会发生死锁的公式为<br><strong>①最多申请资源数=资源总数/进程数（可以整除的条件下）</strong><br><strong>②最多申请资源数=（资源总数/进程数）+1（不可以整除的条件下）</strong><br>所以本题用②的计算方式，得出结果为5/3+1=2</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz12.5.png" alt=""></p>
<p>应选择1234</p>
<p>对于1来说，只分配了一部分，不是一下子全部分配，导致资源再申请新资源的时候还保持着自己已占用的资源，这样就会导致死锁，<strong>是占有且等待（请求和保持，部分分配）的条件</strong></p>
<p>应选择23</p>
<p>首先要先算出还需要的资源数量，同时得到系统中还剩余的A、B、C资源数量</p>
<p>对于每一次选择的时候，系统中的数量应该大于还需要的；然后进行更新，系统数量减去还需要的；然后释放资源，系统数量+最大资源数量（即已经拥有的所有数量）【后面两步相当于在系统资源数量上增加已分配的数量】</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz12.6.png" alt="quiz12.5"></p>
<p>如图选择</p>
<p><img src="/2018/12/08/操作系统-笔记/quiz12.4.png" alt=""></p>
<h3 id="PPT练习题-5"><a href="#PPT练习题-5" class="headerlink" title="PPT练习题"></a>PPT练习题</h3><ol>
<li><p>在系统中仅有m个同类资源，由n个进程互斥使用。如果每个进程对该类资源的最大需求量为w，那么当m、n、w分别取下表列出的值时，问在表中（a）~（e）各种情况下，哪种可能发生死锁？如果可能死锁，请举例说明。</p>
<p>|       | (a)   | (b)   | (c)   | (d)   | (e)   |<br>| ——- | ——- | ——- | ——- | ——- | ——- |<br>| <strong>m</strong> | <strong>2</strong> | <strong>2</strong> | <strong>2</strong> | <strong>4</strong> | <strong>4</strong> |<br>| <strong>n</strong> | <strong>1</strong> | <strong>2</strong> | <strong>2</strong> | <strong>3</strong> | <strong>3</strong> |<br>| <strong>w</strong> | <strong>2</strong> | <strong>1</strong> | <strong>2</strong> | <strong>2</strong> | <strong>3</strong> |</p>
<p>可能死锁：c, e</p>
</li>
<li><p>某系统有A、B、C3类资源供5个进程使用，进程对资源的需求和分配情况如下：</p>
<p>| <strong>进程</strong> | 已分  | 配资  | 源数  | 最大  | 需求  | 量    |<br>| ———— | ——- | ——- | ——- | ——- | ——- | ——- |<br>|          | A     | B     | C     | A     | B     | C     |<br>| <strong>P1</strong>   | <strong>0</strong> | <strong>1</strong> | <strong>0</strong> | <strong>7</strong> | <strong>5</strong> | <strong>3</strong> |<br>| <strong>P2</strong>   | <strong>3</strong> | <strong>0</strong> | <strong>2</strong> | <strong>3</strong> | <strong>2</strong> | <strong>2</strong> |<br>| <strong>P3</strong>   | <strong>3</strong> | <strong>0</strong> | <strong>2</strong> | <strong>9</strong> | <strong>0</strong> | <strong>2</strong> |<br>| <strong>P4</strong>   | <strong>2</strong> | <strong>1</strong> | <strong>1</strong> | <strong>2</strong> | <strong>2</strong> | <strong>2</strong> |<br>| <strong>P5</strong>   | <strong>0</strong> | <strong>0</strong> | <strong>2</strong> | <strong>4</strong> | <strong>3</strong> | <strong>3</strong> |</p>
<p>目前系统还剩A、B、C三类资源为(2, 3, 0)。请按银行家算法回答下面问题：</p>
<ul>
<li>该状态是否安全？</li>
<li>如果进程P1提出(0,1,0)的资源请求，系统能否满足它的请求？</li>
</ul>
<p>| 进程 | 还需 | 资源 | 量   |<br>| —— | —— | —— | —— |<br>|      | A    | B    | C    |<br>| P1   | 7    | 4    | 3    |<br>| P2   | 0    | 2    | 0    |<br>| P3   | 6    | 0    | 0    |<br>| P4   | 0    | 1    | 1    |<br>| P5   | 4    | 3    | 1    |</p>
<p>P2(5,3,5)-p4(7,4,6)-p5(7,4,8)-p3(10,4,10)-p1(10,5,10)安全</p>
<p>| 进程 | 还需 | 资源 | 量   |<br>| —— | —— | —— | —— |<br>|      | A    | B    | C    |<br>| P1   | 7    | 3    | 3    |<br>| P2   | 0    | 2    | 0    |<br>| P3   | 6    | 0    | 0    |<br>| P4   | 0    | 1    | 1    |<br>| P5   | 4    | 3    | 1    |</p>
<p>系统还剩A、B、C三类资源为(2,2,0)</p>
<p>P2(5,2,2)-p4(7,3,6)-p5(7,3,8)-p3(10,3,10)-p1(10,5,10)可以满足</p>
</li>
</ol>
<h2 id="多处理器系统-1"><a href="#多处理器系统-1" class="headerlink" title="多处理器系统"></a>多处理器系统</h2><p><img src="/2018/12/08/操作系统-笔记/多处理器系统.png" alt=""></p>
<h3 id="多处理机"><a href="#多处理机" class="headerlink" title="多处理机"></a>多处理机</h3><p>Share-memory multiprocessor（<strong>共享存储器</strong>多处理机，简称多处理机）</p>
<p>共享内存多处理器是一种计算机系统，其中两个或多个CPU共享对公共RAM的完全访问权限</p>
<p>每个CPU都可以<strong>平等</strong>访问整个物理内存，可以使用<strong>LOAD和STORE指令读写单个单词</strong>，数据速度：10-50nsec</p>
<p><strong>多处理机的同步问题：</strong></p>
<p>如果无法锁定总线，TSL指令可能会失败；为了阻止这种情况的发生，TSL指令必须<strong>首先锁住总线</strong>，阻止其他的CPU访问它，然后进行存储器的读写访问，再解锁总线</p>
<p><strong>多处理机的调度问题</strong></p>
<ul>
<li><p><strong>Timesharing（分时）</strong><br>为就绪进程准备一个<strong>系统级的大数据结构</strong></p>
</li>
<li><p><strong>Space sharing（空间共享）</strong><br>在多个CPU上<strong>同时调度多个线程</strong>称为空间共享</p>
</li>
<li>群调度<br>作为一个单元（一个团伙）安排的相关线程组，团伙的所有成员在不同的分时CPU上同时运行，所有帮派成员<strong>一起开始和结束时间片</strong></li>
</ul>
<h4 id="UMA"><a href="#UMA" class="headerlink" title="UMA"></a>UMA</h4><p>Uniform Memory Access，统一内存访问</p>
<ul>
<li>每个存储器字的读<strong>出速度是一样快的</strong></li>
<li>具有<strong>总线架构</strong>的UMA多处理器</li>
<li>使用<strong>交叉开关</strong>的UMA多处理器（交叉开关）<ul>
<li>交叉开关最好的一个特性是，<strong>非阻塞网络</strong>（nonblocking network）</li>
<li>最差的一个特性是，<strong>交叉点的数量以$n^2$方式增长</strong></li>
</ul>
</li>
<li>使用<strong>多级交换网络</strong>的UMA多处理器（多级交换网络）<ul>
<li>Omega Switching Network</li>
</ul>
</li>
</ul>
<h4 id="NUMA"><a href="#NUMA" class="headerlink" title="NUMA"></a>NUMA</h4><p>Nonuniform Memory Access，非统一内存访问</p>
<p>所有CPU都可以看到<strong>单个地址空间</strong>，通过命令LOAD和STORE访问<strong>远程内存</strong><br><strong>访问远程内存比本地内存慢</strong><br>NC-NUMA：不隐藏远程内存的访问时间<br>基于目录的多处理器（基于目录的多处理）：维护一个数据库，告诉每个缓存行的位置以及它的状态是什么<br>CC-NUMA（高速缓存一致NUMA）：存在连贯的缓存</p>
<h4 id="Multicore-Chips（多核芯片）"><a href="#Multicore-Chips（多核芯片）" class="headerlink" title="Multicore Chips（多核芯片）"></a>Multicore Chips（多核芯片）</h4><p>将两个或更多完整的CPU（通常称为内核）放在同一芯片上（技术上，在同一个芯片上）。<br>多核芯片有时被称为CMP（芯片级多处理器）</p>
<h4 id="片上系统（片上系统）"><a href="#片上系统（片上系统）" class="headerlink" title="片上系统（片上系统）"></a>片上系统（片上系统）</h4><p>这些芯片具有一个或多个主CPU，但也有专用内核，如视频和音频解码器，网络接口等，从而在芯片上实现完整的计算机系统</p>
<ul>
<li>为每个CPU提供私有存储器及操作系统的各自私有副本</li>
<li>允许所有的CPU共享操作系统代码，只需提供数据的私有副本</li>
<li>没有进程共享、没有页面共享、高速缓存不一致</li>
</ul>
<h4 id="Master-Slave-multiprocessors（主从多处理机）"><a href="#Master-Slave-multiprocessors（主从多处理机）" class="headerlink" title="Master-Slave multiprocessors（主从多处理机）"></a>Master-Slave multiprocessors（主从多处理机）</h4><p>操作系统的一个副本及其表都在CPU 1上<br>所有的系统调用都重定向到CPU 1 上<br>问题：当有很多CPU时，CPU1会变成瓶颈</p>
<h4 id="Symmetric-Multiprocessors（SMP，对称多处理机）"><a href="#Symmetric-Multiprocessors（SMP，对称多处理机）" class="headerlink" title="Symmetric Multiprocessors（SMP，对称多处理机）"></a>Symmetric Multiprocessors（SMP，对称多处理机）</h4><p>在存储器中有操作系统的一个副本，但是任何CPU都可以运行它<br>在操作系统中使用<strong>互斥信号量（锁）</strong>，使整个系统成为一个<strong>大临界区</strong></p>
<h3 id="多计算机"><a href="#多计算机" class="headerlink" title="多计算机"></a>多计算机</h3><p>Message-passing multicomputer（消息传递多计算机，简称多计算机）【每个都有自己的私有内存】</p>
<p>多计算机上不同CPU上的进程通过<strong>相互发送消息进行通信</strong><br><strong>send（dest，＆mptr），receive（addr，＆mptr）</strong><br><strong>阻止（同步）呼叫与非阻塞（异步）呼叫</strong></p>
<p><strong>Remote Procedure Call(RPC) （远程过程调用）</strong>：allowing programs to call procedures located on other</p>
<ul>
<li>紧耦合的CPU<strong>不共享内存</strong></li>
<li>通过某种<strong>高速互连连接</strong></li>
<li>每个内存对于单个CPU是<strong>本地的，</strong>只能由该CPU访问</li>
<li>数据速度：10-50μsec</li>
<li><strong>集群计算机</strong></li>
<li><strong>COWS（工作站集群）</strong></li>
<li>互连技术</li>
</ul>
<p><strong>Switching schema（交换机制）</strong></p>
<ul>
<li>store-and-forward packet switching（存储转发包交换）<br>由源节点的网络接口卡注入第一个交换机的包组成<br><strong>当整个包达到时，它被复制到这条路径上的下一个交换机</strong></li>
<li>circuit switching（电路交换）<br>包括由第一个交换机建立的、通过所有交换机而到达目标交换机的一条路径<br><strong>一旦该路径建立起来，</strong>位流就从源到目标通过整个路径不停留地输送</li>
<li>wormhole routing（虫孔路由）<br><strong>把每个包拆成子包，</strong>并允许第一个子包在整个路径还没有完全建立之前就开始流动</li>
</ul>
<h3 id="广域分布式系统"><a href="#广域分布式系统" class="headerlink" title="广域分布式系统"></a>广域分布式系统</h3><p>Wide area distributed system（广域分布式系统）【通过Internet连接起来的系统】<br>通过<strong>广域网</strong>连接完整的计算机系统<br>这些计算机中的<strong>每一台都有自己的内存，系统通过消息传递进行通信</strong><br>数据速度：10-50毫秒</p>
<p>一些网络协议：IP/TCP</p>
<p>一些服务：无连接的和面向连接的</p>
<h3 id="虚拟机技术"><a href="#虚拟机技术" class="headerlink" title="虚拟机技术"></a>虚拟机技术</h3><p>虚拟机技术，通常称为虚拟化（virtualisation化）。<br>该技术允许<strong>单台计算机</strong>托管<strong>多个虚拟机</strong>，每个虚拟机<strong>可能</strong>运行<strong>不同的操作系统</strong>；这种方法的优点是<strong>一个虚拟机中的故障不会自动降低任何其他虚拟机</strong></p>
<p>Type 1 Hypervisor1型管理程序，本省就是一个操作系统，唯一一个运行在内核态的程序，工作是支持真实硬件的多个副本，也称为虚拟机，与普通操作系统支持的进程类似<br>虚拟机运行一个客户机操作系统，认为它处于内核模式（它真的处于用户模式）这称为虚拟内核模式</p>
<p>Type 2 Hypervisors2型管理程序<br>示例：VMware，VMware在主机操作系统之上作为<strong>普通用户程序运行</strong>，当它第一次启动时，它会将操作系统安装到其<strong>虚拟磁盘上</strong></p>
<p>准虚拟化（半虚拟化）<br>要修改客户机操作系统的源代码，<strong>使其完全不执行敏感指令，而是进行管理程序调用</strong><br>管理程序必须定义一个接口，该接口由客户操作系统可以使用的一组过程调用组成（API）<br><strong>故意删除（某些）敏感指令的客户操作系统被称为半虚拟化</strong></p>
<p>半虚拟化的问题<br>如果通过调用虚拟机管理程序替换敏感指令，操作系统如何在本机硬件上运行？<br>如果市场上有多个虚拟机管理程序怎么办？<br>解<br>内核被修改为在需要执行敏感操作时调用特殊过程<br>这些称为VMI（虚拟机接口）的过程组成了一个与硬件和管理程序接口的低级层</p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><ul>
<li>Document-Based Middleware（基于文档的中间件）</li>
<li>File System-Based Middleware（基于文件系统的中间件）<ul>
<li>Naming Transparency（命名透明性）</li>
<li>location transparency（位置透明性） - 路径名称不提示文件的位置</li>
<li>location independent（位置独立性） - 可以移动文件而不更改其名称</li>
<li>文件和目录命名的三种方法<ul>
<li>机器+路径命名</li>
<li>将远程文件系统挂载到本地文件层次结构上</li>
<li>在所有计算机上看起来相同的单个名称空间</li>
</ul>
</li>
</ul>
</li>
<li>Shared Object-Based Middleware（基于共享对象的中间件）<ul>
<li>CORBA(Common Object Request Broker Architecture)</li>
</ul>
</li>
<li>Coordination-Based Middleware（基于协作的中间件）<ul>
<li>Linda</li>
<li>Publish/Subscribe（发布/订阅）</li>
<li>Jini</li>
</ul>
</li>
</ul>
<h2 id="安全-1"><a href="#安全-1" class="headerlink" title="安全"></a>安全</h2><h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><ul>
<li>threats（威胁）<ul>
<li>Data confidentiality（数据机密性） - 秘密数据保密【数据暴露】</li>
<li>Data integrity（数据完整性） - 未经所有者许可，未经授权的用户不得修改任何数据【数据篡改】</li>
<li>系统可用性（系统可用性） - 没有人可以打扰系统使其无法使用【拒绝服务】</li>
<li>隐私/排外性：保护个人不被滥用有关他们的信息【系统被病毒控制】</li>
</ul>
</li>
<li>intruders（入侵者）<ul>
<li>被动入侵者- <strong>阅读</strong>他们无权阅读的文件</li>
<li>主动入侵者- 对数据进行未经授权的<strong>更改</strong></li>
<li>常见类别<ul>
<li>非专业用户的随意浏览</li>
<li>内部人员的窥视</li>
<li>为获取利益而尝试</li>
<li>商业或军事间谍</li>
<li>病毒：一段能够自我复制并通常会产生危害的程序代码</li>
</ul>
</li>
</ul>
</li>
<li>accidental data loss（数据的意外遗失）<ul>
<li>常见原因：天灾：火灾，洪水，战争；硬件或软件错误：CPU故障（故障），坏磁盘，程序错误；人为错误：数据输入，错误的磁带安装</li>
<li>Protection Domains（保护域）<ul>
<li>A domain is a set of <strong>(object, right)</strong> pairs. Each pair specifies an object and some subset of the operations that can be performed一对对象权限的组合，每对组合指定一个对象和一些可在上面运行的操作子集。权限是指对某个操作的执行许可</li>
<li><strong>A right</strong> means <strong>permission to perform one of the operations</strong></li>
<li>An important question is how the system track of <strong>which object belongs which domain</strong>：Protection matrix</li>
<li><strong>Domain switching itself</strong> can be easily included in the matrix model by realizing that a domain is itself an object, with the operation enter</li>
</ul>
</li>
<li>Access Control Lists（访问控制列表）【每个对象的】<ul>
<li>每个对象都有一个（有序）列表，其中<strong>包含可以访问该对象的所有域</strong>。 此列表称为访问控制列表（ACL）</li>
<li>许多系统<strong>支持一组用户</strong>的概念。 组具有名称，可以包含在ACL中。以这种方式使用组有效地引入了<strong>角色的概念</strong></li>
</ul>
</li>
<li>Capabilities（权能字）【每个进程的】<ul>
<li><strong>将每个进程与可访问的对象列表相关联，</strong>并指示每个进程允许哪些操作。此列表称为功能列表（C-list），其上的各个项称为功能</li>
<li>必须保护能力列表免受用户篡改（用户干预）<ul>
<li>标记架构（例如IBM AS / 400）</li>
<li>将C列表保留在操作系统内（例如Hydra）</li>
<li>将C列表保留在用户空间中，但以加密方式管理功能</li>
</ul>
</li>
<li>能力的通用权利<ul>
<li>复制功能：为同一对象创建新功能</li>
<li>复制对象：使用新功能创建复制对象</li>
<li>删除功能：从C列表中删除条目; 对象不受影响</li>
<li>销毁对象：永久删除对象和功能</li>
</ul>
</li>
</ul>
</li>
<li>Trusted Systems（可信任系统）</li>
</ul>
</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>当用户登录到计算机时，操作系统通常希望确定用户是谁，这是一个称为<strong>用户验证</strong>的过程。<br>基本原则认证必须识别：</p>
<ul>
<li>用户知道什么</li>
<li>用户拥有什么</li>
<li>用户是什么</li>
</ul>
<p>试图闯入不属于计算机系统的人是<strong>骇客</strong></p>
<p>有不同的<strong>用户身份验证架构：</strong></p>
<ul>
<li>使用<strong>密码/口令验证</strong><ul>
<li>最广泛使用的身份验证形式是要求用户键入<strong>登录名和密码</strong>，最简单的实现只保留（登录名，密码）对的中央列表</li>
<li><strong>UNIX Password Security</strong><ul>
<li>将每一个口令同一个叫做盐（Salt）的n位随机数相关联</li>
<li>无论何时口令改变，这个随机数就改变</li>
<li>将口令和随机数连接起来，一同加密，加密后的结果存放进口令文件</li>
</ul>
</li>
</ul>
</li>
<li>使用<strong>实际物体</strong>验证<ul>
<li><strong>Magnetic cards（磁卡）</strong><ul>
<li>magnetic stripe cards（磁条卡）</li>
<li>chip cards（芯片卡）: stored value cards, smart cards</li>
</ul>
</li>
</ul>
</li>
<li>使用生物特征验证<ul>
<li>一个典型的生物识别系统由<strong>注册部分和识别部分</strong>两部分构成<ul>
<li>使用手指长短进行识别</li>
<li>视网膜组织分析</li>
<li>签名分析</li>
<li>声音测定</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="内部攻击"><a href="#内部攻击" class="headerlink" title="内部攻击"></a>内部攻击</h3><ul>
<li>Logic Bombs（逻辑炸弹）嵌在产品的操作系统中的代码，特定情况下爆炸</li>
<li>Trap Doors（后门）<ul>
<li>陷阱门/后门是由<strong>程序员插入系统的代码创建的，以绕过一些正常检查</strong>（代码审查）</li>
</ul>
</li>
<li>Login Spoofing（登录欺骗）<ul>
<li>通过在多个终端上进行假冒登录界面，入侵者可收集到多个口令，通常当没有人登录到UNIX终端或局域网上的工作站时，会显示登录屏幕</li>
</ul>
</li>
</ul>
<h3 id="利用代码漏洞"><a href="#利用代码漏洞" class="headerlink" title="利用代码漏洞"></a>利用代码漏洞</h3><ul>
<li>Buffer Overflow Attacks缓冲区溢出攻击<ul>
<li>一个常见的攻击源是由于几乎所有操作系统和系统程序都是用<strong>C语言编写的</strong>，而C编译器没有<strong>数组边界检查</strong></li>
</ul>
</li>
<li>Format String Attacks格式化字符串攻击</li>
<li>Return to libc Attacks返回libc攻击</li>
<li>Integer Overflow Attacks整数溢出攻击</li>
<li>Code Injection Attacks代码注入攻击<ul>
<li>可能导致代码注入攻击的代码，比如请输入后，接受用户的输入，并且作为cmd</li>
</ul>
</li>
<li>Privilege Escalation Attacks权限提升攻击</li>
</ul>
<h3 id="恶意软件"><a href="#恶意软件" class="headerlink" title="恶意软件"></a>恶意软件</h3><p>可以用于敲诈勒索的形式<br>示例：加密受害者磁盘上的文件，然后显示消息…</p>
<h4 id="病毒"><a href="#病毒" class="headerlink" title="病毒"></a>病毒</h4><ul>
<li><p>Companion virus（共事者病毒）</p>
<ul>
<li>实际上不会影响程序，但在<strong>程序运行时会运行</strong></li>
</ul>
</li>
<li><p>Executable program virus可执行程序病毒</p>
<ul>
<li>覆盖病毒overwriting viruses<br>这些病毒中最简单的只是用自己<strong>覆盖可执行程序</strong></li>
<li>寄生病毒Parasitic virus<br>将自己<strong>附加到程序</strong>并执行其脏工作，但<strong>允许程序正常运行</strong></li>
</ul>
</li>
<li>Memory-resident virus内存驻留病毒<ul>
<li>总是<strong>驻留在内存中</strong><br>把<strong>自身地址放置在Trap或者中断向量</strong>中，从而将<strong>Trap或中断向量指向病毒</strong></li>
</ul>
</li>
<li>Boot sector virus引导扇区病毒<ul>
<li>覆盖主引导记录（MBR）或主引导扇区<br>把真正的引导记录扇区复制到磁盘的安全区域<br>使用<strong>磁盘内任意空闲的扇区</strong>，然后<strong>更改坏扇区列表</strong>，把<strong>隐藏引导记录的扇区标记为坏扇区</strong></li>
</ul>
</li>
<li>Device driver virus设备驱动病毒</li>
<li>Macro virus宏病毒</li>
<li>Source code virus源代码病毒</li>
</ul>
<h4 id="间谍软件"><a href="#间谍软件" class="headerlink" title="间谍软件"></a>间谍软件</h4><p>粗略地说，间谍软件是在<strong>没有所有者知情的情况下</strong>秘密地加载到PC上的软件，并且在后台运行并在所有者的背后做事<br>特点：</p>
<ul>
<li><strong>受害者不能轻易找到</strong></li>
<li><strong>收集有关用户的数据</strong></li>
<li>将收集的信息<strong>传达给远方的主人</strong></li>
<li>试图在确定的删除它的尝试中生存</li>
</ul>
<p><strong>间谍软件采取的行动</strong></p>
<ul>
<li>更改浏览器的主页</li>
<li>修改浏览器的收藏（已添加书签）页面列表</li>
<li>将新工具栏添加到浏览器</li>
<li>更改用户的默认媒体播放器</li>
<li>更改用户的默认搜索引擎</li>
<li>将新图标添加到Windows桌面</li>
<li>将网页上的横幅广告替换为间谍软件选择的横幅广告</li>
<li>将广告放入标准Windows对话框中</li>
<li>生成连续且不可阻挡的弹出式广告流</li>
</ul>
<h4 id="隐蔽软件"><a href="#隐蔽软件" class="headerlink" title="隐蔽软件"></a>隐蔽软件</h4><p>rootkit（隐蔽软件）是一个程序或一组程序和文件，<strong>试图隐藏它的存在</strong>，即使面对受感染机器的所有者确定的定位和删除它的努力。<br>通常，rootkit包含一些被隐藏的恶意软件</p>
<p>一个典型rootkit包括：</p>
<ul>
<li>以太网嗅探器程序，用于获得网络上传输的用户名和密码等信息</li>
<li>特洛伊木马程序，例如：inetd或者login，为攻击者提供后门</li>
<li>隐藏攻击者的目录和进程的程序，例如：ps、netstat、rshd和ls等</li>
<li>可能还包括一些日志清理工具，例如：zap、zap2或者z2，攻击者使用这些清理工具删除wtmp、utmp和lastlog等日志文件中有关自己行踪的条目</li>
<li>一些复杂的rootkit还可以向攻击者提供telnet、shell和finger等服务</li>
</ul>
<p>rootkit的类型</p>
<ul>
<li>固件rootkit</li>
<li>Hypervisor（管理程序）rootkit</li>
<li>内核rootkit</li>
<li>库rootkit</li>
<li>应用程序rootkit</li>
</ul>
<h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><ul>
<li><p>纵深防御：你应该有<strong>多层安全性</strong>，这样如果其中一个被破坏，还有其他一些需要克服</p>
</li>
<li><p>防火墙</p>
</li>
<li>Virus Scanner（病毒扫描程序）<br>have the virus infect a program that does nothing, often called goat file（诱饵文件）, to get the copy of the virus in its purest form<br>make an exact listing of the virus’ code and enter it into the database of known viruses</li>
<li>防病毒程序检测文件感染的另一种方法是在磁盘上记录并存储所有文件的长度</li>
<li>Integrity checkers（完整性检查程序）<br>首先扫描硬盘上的病毒，一旦确信硬盘是干净的，它就开始计算每个可执行文件的校验和，并把一个目录里所有相关文件的校验和的列表写入该目录的checksum文件中</li>
<li>Behavioral checkers（行为检查程序）<br>反病毒程序在系统运行时驻留在内存，并自己捕捉所有的系统调用</li>
<li>Virus avoidance（病毒避免）<ul>
<li>good OS（提供高度安全保障的操作系统）</li>
<li>install only shrink-wrapped software（仅安装从可靠的供应商处购买的正版软件）<br>use antivirus software</li>
<li>do not click on attachments to email</li>
<li>frequent backups</li>
</ul>
</li>
<li>Recovery from virus attack<ul>
<li>halt computer, reboot from safe disk, run antivirus</li>
</ul>
</li>
<li>代码签名<ul>
<li>仅接受来自可信来源的Applet</li>
<li>用户通过数字签名来验证Applet来自可信的供应商</li>
<li>代码签名是基于公钥加密体制的</li>
</ul>
</li>
</ul>
<p>JAVA的安全体制：</p>
<ul>
<li>一种类型安全的语言</li>
<li>编译器拒绝尝试滥用变量</li>
<li>Java程序被编译为称为JVM（Java虚拟机）字节代码的中间二进制代码</li>
<li>在Java模型中，通过Internet发送以进行远程执行的applet是JVM程序</li>
<li>applet通过JVM字节验证程序运行，该验证程序检查applet是否遵守某些规则</li>
<li>检测包括<ul>
<li>试图伪造（伪造）指针</li>
<li>违反私人集体成员的访问限制</li>
<li>按类型滥用变量</li>
<li>堆栈上溢/下溢的生成</li>
<li>非法将变量转换为另一种类型</li>
</ul>
</li>
</ul>
<h3 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h3><p>Bell-LaPadula（军方）【保守机密，但不能保证数据的完整性】</p>
<ul>
<li>在密级k上面运行的进程只能<strong>读</strong>取同一密级或更<strong>低</strong>密级的对象</li>
<li>在密级k上面运行的进程只能<strong>写</strong>取同一密级或更<strong>高</strong>密级的对象</li>
<li>进程可以读写对象，但不能直接相互通信</li>
</ul>
<p>Biba（民用）【刚好相反】</p>
<ul>
<li>在密级k上面运行的进程只能<strong>写</strong>取同一密级或更<strong>低</strong>密级的对象</li>
<li>在密级k上面运行的进程只能<strong>读</strong>取同一密级或更<strong>高</strong>密级的对象</li>
</ul>
<p>转载请注明出处，谢谢。<br><blockquote class="blockquote-center"><p>愿 我是你的小太阳</p>
</blockquote></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=2931596&auto=1&height=66"></iframe>

<!-- UY BEGIN -->
<p><div id="uyan_frame"></div></p>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2142537"></script>

<!-- UY END -->

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>买糖果去喽</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechat.jpg" alt="Mrs_empress WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/课堂笔记/" rel="tag"><i class="fa fa-tag"></i> 课堂笔记</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11/30/Deep-learning-frameworks/" rel="next" title="Deep Learning Frameworks">
                <i class="fa fa-chevron-left"></i> Deep Learning Frameworks
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/12/Reinforcement-Learning-outline/" rel="prev" title="Reinforcement Learning outline">
                Reinforcement Learning outline <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="/images/avatar.jpg"
              alt="Mrs_empress" />
          
            <p class="site-author-name" itemprop="name">Mrs_empress</p>
            <p class="site-description motion-element" itemprop="description">Hope be better and better, wish be happy and happy!</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives">
            
                <span class="site-state-item-count">97</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">39</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">70</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/mrsempress" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.facebook.com/chenxi.huang.56211" target="_blank" title="FB Page">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      FB Page
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/3309079767?refer_flag=1001030001_&nick=Mrs_empress_阡沫昕&is_hot=1" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      微博
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://tobiaslee.top" title="TobiasLee" target="_blank">TobiasLee</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://abcml.xin/" title="ZeZe" target="_blank">ZeZe</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://notes-hongbo.top" title="Bob" target="_blank">Bob</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://undefinedf.github.io/" title="Fjh" target="_blank">Fjh</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#考试题型"><span class="nav-number">1.</span> <span class="nav-text">考试题型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程和线程"><span class="nav-number">1.1.</span> <span class="nav-text">进程和线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存管理"><span class="nav-number">1.2.</span> <span class="nav-text">内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件系统"><span class="nav-number">1.3.</span> <span class="nav-text">文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O"><span class="nav-number">1.4.</span> <span class="nav-text">I/O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁"><span class="nav-number">1.5.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多处理器系统"><span class="nav-number">1.6.</span> <span class="nav-text">多处理器系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全"><span class="nav-number">1.7.</span> <span class="nav-text">安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UNIX-amp-LINUX常用系统调用"><span class="nav-number">1.8.</span> <span class="nav-text">UNIX&LINUX常用系统调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统概述"><span class="nav-number">2.</span> <span class="nav-text">操作系统概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#程序执行流程（Hello-world为例）"><span class="nav-number">2.1.</span> <span class="nav-text">程序执行流程（Hello world为例）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统概念"><span class="nav-number">2.2.</span> <span class="nav-text">操作系统概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统的作用"><span class="nav-number">2.3.</span> <span class="nav-text">操作系统的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统的特征"><span class="nav-number">2.4.</span> <span class="nav-text">操作系统的特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统的架构"><span class="nav-number">2.5.</span> <span class="nav-text">操作系统的架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统的分类"><span class="nav-number">2.6.</span> <span class="nav-text">操作系统的分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行环境和运行机制"><span class="nav-number">3.</span> <span class="nav-text">运行环境和运行机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#运行环境"><span class="nav-number">3.1.</span> <span class="nav-text">运行环境</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU状态"><span class="nav-number">3.1.1.</span> <span class="nav-text">CPU状态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行机制"><span class="nav-number">3.2.</span> <span class="nav-text">运行机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#中断-异常"><span class="nav-number">3.2.1.</span> <span class="nav-text">中断/异常</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Quiz2-错题"><span class="nav-number">3.3.</span> <span class="nav-text">Quiz2 错题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程-线程"><span class="nav-number">4.</span> <span class="nav-text">进程/线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多道程序设计"><span class="nav-number">4.1.</span> <span class="nav-text">多道程序设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程"><span class="nav-number">4.2.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的管理"><span class="nav-number">4.2.1.</span> <span class="nav-text">进程的管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的状态"><span class="nav-number">4.2.2.</span> <span class="nav-text">进程的状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程控制"><span class="nav-number">4.2.3.</span> <span class="nav-text">进程控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的分类"><span class="nav-number">4.2.4.</span> <span class="nav-text">进程的分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程和程序"><span class="nav-number">4.2.5.</span> <span class="nav-text">进程和程序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程"><span class="nav-number">4.3.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程的属性"><span class="nav-number">4.3.1.</span> <span class="nav-text">线程的属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程机制的实现"><span class="nav-number">4.3.2.</span> <span class="nav-text">线程机制的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#用户级线程"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">用户级线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#内核级线程"><span class="nav-number">4.3.2.2.</span> <span class="nav-text">内核级线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#用户级线程与内核级线程"><span class="nav-number">4.3.2.3.</span> <span class="nav-text">用户级线程与内核级线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#混合级线程"><span class="nav-number">4.3.2.4.</span> <span class="nav-text">混合级线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Pthread的线程操作"><span class="nav-number">4.3.2.5.</span> <span class="nav-text">Pthread的线程操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程调度"><span class="nav-number">4.3.3.</span> <span class="nav-text">线程调度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Quiz3错题"><span class="nav-number">4.4.</span> <span class="nav-text">Quiz3错题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理器调度"><span class="nav-number">5.</span> <span class="nav-text">处理器调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#上下文切换"><span class="nav-number">5.1.</span> <span class="nav-text">上下文切换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#具体步骤"><span class="nav-number">5.1.1.</span> <span class="nav-text">具体步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#开销"><span class="nav-number">5.1.2.</span> <span class="nav-text">开销</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度算法"><span class="nav-number">5.2.</span> <span class="nav-text">调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#衡量指标"><span class="nav-number">5.2.1.</span> <span class="nav-text">衡量指标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#批处理系统的调度算法"><span class="nav-number">5.2.2.</span> <span class="nav-text">批处理系统的调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#先来先服务FCFS"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">先来先服务FCFS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#最短作业优先-SJF"><span class="nav-number">5.2.2.2.</span> <span class="nav-text">最短作业优先 SJF</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#最短剩余时间优先-SRTN"><span class="nav-number">5.2.2.2.1.</span> <span class="nav-text">最短剩余时间优先 SRTN</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#最高响应比优先HRRN"><span class="nav-number">5.2.2.3.</span> <span class="nav-text">#最高响应比优先HRRN</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#交互式系统的调度算法"><span class="nav-number">5.2.3.</span> <span class="nav-text">交互式系统的调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#时间片轮转调度RR"><span class="nav-number">5.2.3.1.</span> <span class="nav-text">时间片轮转调度RR</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#虚拟轮转法-Virtual-RR"><span class="nav-number">5.2.3.1.1.</span> <span class="nav-text">#虚拟轮转法 Virtual RR</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#最高优先级调度HPF"><span class="nav-number">5.2.3.2.</span> <span class="nav-text">最高优先级调度HPF</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#多级反馈队列"><span class="nav-number">5.2.3.3.</span> <span class="nav-text">多级反馈队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#短进程优先"><span class="nav-number">5.2.3.4.</span> <span class="nav-text">短进程优先</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#保证调度"><span class="nav-number">5.2.3.5.</span> <span class="nav-text">保证调度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#彩票调度"><span class="nav-number">5.2.3.6.</span> <span class="nav-text">彩票调度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#公平分享调度"><span class="nav-number">5.2.3.7.</span> <span class="nav-text">公平分享调度</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实时系统调度"><span class="nav-number">5.2.4.</span> <span class="nav-text">实时系统调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#各调度算法的比较"><span class="nav-number">5.2.5.</span> <span class="nav-text">各调度算法的比较</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#windows线程调度"><span class="nav-number">5.2.5.1.</span> <span class="nav-text">windows线程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#UNIX两级调度算法"><span class="nav-number">5.2.5.1.1.</span> <span class="nav-text">UNIX两级调度算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多处理器调度算法"><span class="nav-number">5.2.6.</span> <span class="nav-text">多处理器调度算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Quiz4-模糊题"><span class="nav-number">5.3.</span> <span class="nav-text">Quiz4 模糊题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PPT练习题"><span class="nav-number">5.4.</span> <span class="nav-text">PPT练习题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同步机制"><span class="nav-number">6.</span> <span class="nav-text">同步机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的并发执行"><span class="nav-number">6.1.</span> <span class="nav-text">进程的并发执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程互斥"><span class="nav-number">6.2.</span> <span class="nav-text">进程互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解决方案"><span class="nav-number">6.2.1.</span> <span class="nav-text">解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#软件方案"><span class="nav-number">6.2.1.1.</span> <span class="nav-text">软件方案</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Dekker"><span class="nav-number">6.2.1.1.1.</span> <span class="nav-text">Dekker</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Peterson"><span class="nav-number">6.2.1.1.2.</span> <span class="nav-text">Peterson</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#硬件方案"><span class="nav-number">6.2.1.2.</span> <span class="nav-text">硬件方案</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#屏蔽中断"><span class="nav-number">6.2.1.2.1.</span> <span class="nav-text">屏蔽中断</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#TSL指令"><span class="nav-number">6.2.1.2.2.</span> <span class="nav-text">TSL指令</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#XCHG指令"><span class="nav-number">6.2.1.2.3.</span> <span class="nav-text">XCHG指令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#忙等待busy-waiting"><span class="nav-number">6.2.2.</span> <span class="nav-text">忙等待busy waiting</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#阻塞Block"><span class="nav-number">6.2.3.</span> <span class="nav-text">阻塞Block</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程同步synchronization"><span class="nav-number">6.3.</span> <span class="nav-text">进程同步synchronization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量及PV操作"><span class="nav-number">6.4.</span> <span class="nav-text">信号量及PV操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#生产者-消费者问题（有界缓冲区问题）"><span class="nav-number">6.4.1.</span> <span class="nav-text">生产者/消费者问题（有界缓冲区问题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读者-写者问题"><span class="nav-number">6.4.2.</span> <span class="nav-text">读者/写者问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#读者优先"><span class="nav-number">6.4.2.1.</span> <span class="nav-text">读者优先</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管程"><span class="nav-number">6.5.</span> <span class="nav-text">管程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#管程与进程的区别"><span class="nav-number">6.5.1.</span> <span class="nav-text">管程与进程的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HOARE管程"><span class="nav-number">6.5.2.</span> <span class="nav-text">HOARE管程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#条件变量"><span class="nav-number">6.5.2.1.</span> <span class="nav-text">条件变量</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MESA管程"><span class="nav-number">6.5.3.</span> <span class="nav-text">MESA管程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#管程的实现和应用"><span class="nav-number">6.5.4.</span> <span class="nav-text">管程的实现和应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#生产者-消费者问题"><span class="nav-number">6.5.4.1.</span> <span class="nav-text">生产者/消费者问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程与管程"><span class="nav-number">6.5.5.</span> <span class="nav-text">进程与管程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pthread的同步机制"><span class="nav-number">6.6.</span> <span class="nav-text">Pthread的同步机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#生产者-消费者问题-1"><span class="nav-number">6.6.1.</span> <span class="nav-text">生产者/消费者问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通信机制"><span class="nav-number">6.7.</span> <span class="nav-text">通信机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux的进程通信机制"><span class="nav-number">6.7.1.</span> <span class="nav-text">Linux的进程通信机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Quiz-5-错题和模糊题"><span class="nav-number">6.8.</span> <span class="nav-text">Quiz 5 错题和模糊题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Quiz-6-错题和模糊题"><span class="nav-number">6.9.</span> <span class="nav-text">Quiz 6 错题和模糊题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PPT练习题-1"><span class="nav-number">6.10.</span> <span class="nav-text">PPT练习题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#存储管理"><span class="nav-number">7.</span> <span class="nav-text">存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#地址重定位"><span class="nav-number">7.1.</span> <span class="nav-text">地址重定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#物理内存管理"><span class="nav-number">7.2.</span> <span class="nav-text">物理内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内存分配算法"><span class="nav-number">7.2.1.</span> <span class="nav-text">内存分配算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#伙伴系统"><span class="nav-number">7.2.2.</span> <span class="nav-text">伙伴系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存回收问题"><span class="nav-number">7.2.3.</span> <span class="nav-text">内存回收问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存管理方案"><span class="nav-number">7.2.4.</span> <span class="nav-text">内存管理方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存“扩充”技术"><span class="nav-number">7.2.5.</span> <span class="nav-text">内存“扩充”技术</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#内存紧缩技术（例如：可变分区）"><span class="nav-number">7.2.5.1.</span> <span class="nav-text">内存紧缩技术（例如：可变分区）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#覆盖技术-overlaying"><span class="nav-number">7.2.5.2.</span> <span class="nav-text">覆盖技术 overlaying</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#交-对换技术-swapping"><span class="nav-number">7.2.5.3.</span> <span class="nav-text">交/对换技术 swapping</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#虚拟存储技术-virtual-memory"><span class="nav-number">7.2.5.4.</span> <span class="nav-text">虚拟存储技术 virtual memory</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#虚拟内存："><span class="nav-number">7.2.5.4.1.</span> <span class="nav-text">虚拟内存：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#虚拟地址空间"><span class="nav-number">7.2.5.4.2.</span> <span class="nav-text">虚拟地址空间</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#虚拟地址"><span class="nav-number">7.2.5.4.3.</span> <span class="nav-text">虚拟地址</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#地址保护（存储保护）"><span class="nav-number">7.2.5.4.4.</span> <span class="nav-text">地址保护（存储保护）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#虚拟页式存储管理系统（PAGING）"><span class="nav-number">7.2.5.5.</span> <span class="nav-text">虚拟页式存储管理系统（PAGING）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#基本思想"><span class="nav-number">7.2.5.5.1.</span> <span class="nav-text">基本思想</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#两种方式"><span class="nav-number">7.2.5.5.2.</span> <span class="nav-text">两种方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#页表及页表项"><span class="nav-number">7.2.5.5.3.</span> <span class="nav-text">页表及页表项</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#快表TLB-Translation-Look-aside-Buffers"><span class="nav-number">7.2.5.5.4.</span> <span class="nav-text">快表TLB(Translation Look-aside Buffers)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#页错误Page-Fault"><span class="nav-number">7.2.5.5.5.</span> <span class="nav-text">页错误Page Fault</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#驻留集"><span class="nav-number">7.2.5.5.6.</span> <span class="nav-text">驻留集</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#置换问题"><span class="nav-number">7.2.5.5.7.</span> <span class="nav-text">置换问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#影响缺页次数的因素"><span class="nav-number">7.2.6.</span> <span class="nav-text">影响缺页次数的因素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#页面置换算法"><span class="nav-number">7.2.7.</span> <span class="nav-text">页面置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#OPT最佳页面置换算法"><span class="nav-number">7.2.7.1.</span> <span class="nav-text">OPT最佳页面置换算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FIFO先进先出算法"><span class="nav-number">7.2.7.2.</span> <span class="nav-text">FIFO先进先出算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#BELADY现象"><span class="nav-number">7.2.7.2.1.</span> <span class="nav-text">BELADY现象</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SCR-Second-Chance第二次机会算法"><span class="nav-number">7.2.7.3.</span> <span class="nav-text">SCR-Second Chance第二次机会算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#CLOCK时钟算法实现"><span class="nav-number">7.2.7.3.1.</span> <span class="nav-text">CLOCK时钟算法实现</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#NRU-Not-Recently-Used最近未使用算法"><span class="nav-number">7.2.7.4.</span> <span class="nav-text">NRU-Not Recently Used最近未使用算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#CLOCK时钟算法实现-1"><span class="nav-number">7.2.7.4.1.</span> <span class="nav-text">CLOCK时钟算法实现</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LRU-Least-Recently-Used最近最少使用算法"><span class="nav-number">7.2.7.5.</span> <span class="nav-text">LRU-Least Recently Used最近最少使用算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#NFU-Not-Frequently-Used最不经常使用算法"><span class="nav-number">7.2.7.5.1.</span> <span class="nav-text">NFU-Not Frequently Used最不经常使用算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#AGING老化算法"><span class="nav-number">7.2.7.5.2.</span> <span class="nav-text">AGING老化算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#工作集算法"><span class="nav-number">7.2.7.6.</span> <span class="nav-text">工作集算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存映射文件"><span class="nav-number">7.2.8.</span> <span class="nav-text">内存映射文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#写时复制技术"><span class="nav-number">7.2.9.</span> <span class="nav-text">写时复制技术</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#quiz-7-错题和模糊题"><span class="nav-number">7.3.</span> <span class="nav-text">quiz 7 错题和模糊题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#quiz-8-错题和模糊题"><span class="nav-number">7.4.</span> <span class="nav-text">quiz 8 错题和模糊题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PPT练习题-2"><span class="nav-number">7.5.</span> <span class="nav-text">PPT练习题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件系统-1"><span class="nav-number">8.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件"><span class="nav-number">8.1.</span> <span class="nav-text">文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件的存储介质"><span class="nav-number">8.1.1.</span> <span class="nav-text">文件的存储介质</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件系统-2"><span class="nav-number">8.2.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件控制块FCB"><span class="nav-number">8.2.1.</span> <span class="nav-text">文件控制块FCB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件目录"><span class="nav-number">8.2.2.</span> <span class="nav-text">文件目录</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#管理文件目录的系统调用"><span class="nav-number">8.2.2.1.</span> <span class="nav-text">管理文件目录的系统调用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件的物理结构"><span class="nav-number">8.2.3.</span> <span class="nav-text">文件的物理结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#顺序（连续）结构"><span class="nav-number">8.2.3.1.</span> <span class="nav-text">顺序（连续）结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#链接结构"><span class="nav-number">8.2.3.2.</span> <span class="nav-text">链接结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#文件分配表FAT"><span class="nav-number">8.2.3.2.1.</span> <span class="nav-text">文件分配表FAT</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#索引结构"><span class="nav-number">8.2.3.3.</span> <span class="nav-text">索引结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i-node"><span class="nav-number">8.2.3.4.</span> <span class="nav-text">i-node</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#共享文件系统Shared-Files"><span class="nav-number">8.2.4.</span> <span class="nav-text">共享文件系统Shared Files</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#日志文件系统Journaling-File-Systems"><span class="nav-number">8.2.5.</span> <span class="nav-text">日志文件系统Journaling File Systems</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟文件系统VFS-Virtual-File-Systems"><span class="nav-number">8.2.6.</span> <span class="nav-text">虚拟文件系统VFS(Virtual File Systems)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UNIX文件系统的实现"><span class="nav-number">8.2.7.</span> <span class="nav-text">UNIX文件系统的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Windows—FAT16文件系统"><span class="nav-number">8.2.8.</span> <span class="nav-text">Windows—FAT16文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#长文件名的存储"><span class="nav-number">8.2.8.0.1.</span> <span class="nav-text">长文件名的存储</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件操作的实现"><span class="nav-number">8.2.9.</span> <span class="nav-text">文件操作的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#创建文件"><span class="nav-number">8.2.9.1.</span> <span class="nav-text">创建文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#打开文件"><span class="nav-number">8.2.9.2.</span> <span class="nav-text">打开文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#指针定位"><span class="nav-number">8.2.9.3.</span> <span class="nav-text">指针定位</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#读文件"><span class="nav-number">8.2.9.4.</span> <span class="nav-text">读文件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件系统的管理"><span class="nav-number">8.2.10.</span> <span class="nav-text">文件系统的管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#文件系统的空间管理"><span class="nav-number">8.2.10.1.</span> <span class="nav-text">文件系统的空间管理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#文件系统的可靠性"><span class="nav-number">8.2.10.2.</span> <span class="nav-text">文件系统的可靠性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#文件系统的一致性"><span class="nav-number">8.2.10.3.</span> <span class="nav-text">文件系统的一致性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#文件系统的写入策略"><span class="nav-number">8.2.10.4.</span> <span class="nav-text">文件系统的写入策略</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件系统的安全性"><span class="nav-number">8.2.11.</span> <span class="nav-text">文件系统的安全性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#文件保护机制"><span class="nav-number">8.2.11.1.</span> <span class="nav-text">文件保护机制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件系统的性能"><span class="nav-number">8.2.12.</span> <span class="nav-text">文件系统的性能</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#磁盘调度算法"><span class="nav-number">8.2.12.1.</span> <span class="nav-text">磁盘调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#先来先服务FCFS-1"><span class="nav-number">8.2.12.1.1.</span> <span class="nav-text">先来先服务FCFS</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#最短寻道时间优先Shortest-Seek-Time-First"><span class="nav-number">8.2.12.1.2.</span> <span class="nav-text">最短寻道时间优先Shortest Seek Time First</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#扫描算法SCAN（电梯算法elevator-algorithm）"><span class="nav-number">8.2.12.1.3.</span> <span class="nav-text">扫描算法SCAN（电梯算法elevator algorithm）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#旋转调度算法"><span class="nav-number">8.2.12.1.4.</span> <span class="nav-text">#旋转调度算法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#quiz-9-错题和模糊题"><span class="nav-number">8.3.</span> <span class="nav-text">quiz 9 错题和模糊题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#quiz-10-错题和模糊题"><span class="nav-number">8.4.</span> <span class="nav-text">quiz 10 错题和模糊题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PPT练习题-3"><span class="nav-number">8.5.</span> <span class="nav-text">PPT练习题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O-系统"><span class="nav-number">9.</span> <span class="nav-text">I/O 系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O管理"><span class="nav-number">9.1.</span> <span class="nav-text">I/O管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#设备控制器"><span class="nav-number">9.1.1.</span> <span class="nav-text">设备控制器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O特点"><span class="nav-number">9.1.2.</span> <span class="nav-text">I/O特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O设备分类"><span class="nav-number">9.1.3.</span> <span class="nav-text">I/O设备分类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#输入设备"><span class="nav-number">9.1.3.1.</span> <span class="nav-text">输入设备</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#输出设备"><span class="nav-number">9.1.3.2.</span> <span class="nav-text">输出设备</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#用户接口"><span class="nav-number">9.1.3.3.</span> <span class="nav-text">用户接口</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O管理的目标和任务"><span class="nav-number">9.1.4.</span> <span class="nav-text">I/O管理的目标和任务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O硬件组成"><span class="nav-number">9.2.</span> <span class="nav-text">I/O硬件组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O控制方式"><span class="nav-number">9.3.</span> <span class="nav-text">I/O控制方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#可编程I-O（轮询-查询）"><span class="nav-number">9.3.1.</span> <span class="nav-text">可编程I/O（轮询/查询）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中断驱动I-O"><span class="nav-number">9.3.2.</span> <span class="nav-text">中断驱动I/O</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DMA（直接内存存取"><span class="nav-number">9.3.3.</span> <span class="nav-text">DMA（直接内存存取)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#流程"><span class="nav-number">9.3.3.1.</span> <span class="nav-text">流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#操作模式"><span class="nav-number">9.3.3.2.</span> <span class="nav-text">操作模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O软件设计"><span class="nav-number">9.4.</span> <span class="nav-text">I/O软件设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分层的设计思想"><span class="nav-number">9.4.1.</span> <span class="nav-text">分层的设计思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O软件设计目标"><span class="nav-number">9.4.2.</span> <span class="nav-text">I/O软件设计目标</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#设备独立性（设备无关性）"><span class="nav-number">9.4.2.0.1.</span> <span class="nav-text">设备独立性（设备无关性）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#统一命名"><span class="nav-number">9.4.2.0.2.</span> <span class="nav-text">统一命名</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#错误处理"><span class="nav-number">9.4.2.0.3.</span> <span class="nav-text">错误处理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#同步与异步传输"><span class="nav-number">9.4.2.0.4.</span> <span class="nav-text">同步与异步传输</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#缓冲"><span class="nav-number">9.4.2.0.5.</span> <span class="nav-text">缓冲</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#共享与独占设备"><span class="nav-number">9.4.2.0.6.</span> <span class="nav-text">共享与独占设备</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O相关技术"><span class="nav-number">9.5.</span> <span class="nav-text">I/O相关技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#缓冲技术"><span class="nav-number">9.5.1.</span> <span class="nav-text">缓冲技术</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O设备管理"><span class="nav-number">9.6.</span> <span class="nav-text">I/O设备管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O性能问题"><span class="nav-number">9.7.</span> <span class="nav-text">I/O性能问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#异步I-O"><span class="nav-number">9.7.1.</span> <span class="nav-text">异步I/O</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步I-O"><span class="nav-number">9.7.2.</span> <span class="nav-text">同步I/O</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时钟"><span class="nav-number">9.8.</span> <span class="nav-text">时钟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#瘦客户端"><span class="nav-number">9.9.</span> <span class="nav-text">瘦客户端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#电源管理"><span class="nav-number">9.10.</span> <span class="nav-text">电源管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#quiz-11-错题和模糊题"><span class="nav-number">9.11.</span> <span class="nav-text">quiz 11 错题和模糊题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PPT练习题-4"><span class="nav-number">9.12.</span> <span class="nav-text">PPT练习题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁-1"><span class="nav-number">10.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁的基本概念"><span class="nav-number">10.1.</span> <span class="nav-text">死锁的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义"><span class="nav-number">10.1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#产生原因"><span class="nav-number">10.1.2.</span> <span class="nav-text">产生原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#产生条件"><span class="nav-number">10.1.3.</span> <span class="nav-text">产生条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#活锁和饥饿"><span class="nav-number">10.1.4.</span> <span class="nav-text">活锁和饥饿</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#资源分配图"><span class="nav-number">10.2.</span> <span class="nav-text">资源分配图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#资源分配图化简"><span class="nav-number">10.2.1.</span> <span class="nav-text">资源分配图化简</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁定理"><span class="nav-number">10.2.2.</span> <span class="nav-text">死锁定理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#资源轨迹图"><span class="nav-number">10.3.</span> <span class="nav-text">资源轨迹图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决死锁的方法"><span class="nav-number">10.4.</span> <span class="nav-text">解决死锁的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#不考虑死锁问题"><span class="nav-number">10.4.1.</span> <span class="nav-text">不考虑死锁问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#鸵鸟算法"><span class="nav-number">10.4.1.1.</span> <span class="nav-text">鸵鸟算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不让死锁发生"><span class="nav-number">10.4.2.</span> <span class="nav-text">不让死锁发生</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#死锁预防deadlock-prevention"><span class="nav-number">10.4.2.1.</span> <span class="nav-text">死锁预防deadlock prevention</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#死锁避免"><span class="nav-number">10.4.2.2.</span> <span class="nav-text">死锁避免</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#银行家算法-Banker’s-Algorithm"><span class="nav-number">10.4.2.2.1.</span> <span class="nav-text">银行家算法 Banker’s Algorithm</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#让死锁发生"><span class="nav-number">10.4.3.</span> <span class="nav-text">让死锁发生</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#死锁检测与解除"><span class="nav-number">10.4.3.1.</span> <span class="nav-text">死锁检测与解除</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#死锁检测"><span class="nav-number">10.4.3.1.1.</span> <span class="nav-text">死锁检测</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#死锁解除"><span class="nav-number">10.4.3.1.2.</span> <span class="nav-text">死锁解除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他问题"><span class="nav-number">10.4.4.</span> <span class="nav-text">其他问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#哲学家就餐问题"><span class="nav-number">10.4.5.</span> <span class="nav-text">哲学家就餐问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#解决方案-1"><span class="nav-number">10.4.5.1.</span> <span class="nav-text">解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#何时发生死锁？"><span class="nav-number">10.4.5.1.1.</span> <span class="nav-text">何时发生死锁？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#怎样从死锁中恢复？"><span class="nav-number">10.4.5.1.2.</span> <span class="nav-text">怎样从死锁中恢复？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#怎样避免死锁的发生？"><span class="nav-number">10.4.5.1.3.</span> <span class="nav-text">怎样避免死锁的发生？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#如何预防死锁？"><span class="nav-number">10.4.5.1.4.</span> <span class="nav-text">如何预防死锁？</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#quiz-12-错题和模糊题"><span class="nav-number">10.5.</span> <span class="nav-text">quiz 12 错题和模糊题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PPT练习题-5"><span class="nav-number">10.6.</span> <span class="nav-text">PPT练习题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多处理器系统-1"><span class="nav-number">11.</span> <span class="nav-text">多处理器系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多处理机"><span class="nav-number">11.1.</span> <span class="nav-text">多处理机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#UMA"><span class="nav-number">11.1.1.</span> <span class="nav-text">UMA</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NUMA"><span class="nav-number">11.1.2.</span> <span class="nav-text">NUMA</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Multicore-Chips（多核芯片）"><span class="nav-number">11.1.3.</span> <span class="nav-text">Multicore Chips（多核芯片）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#片上系统（片上系统）"><span class="nav-number">11.1.4.</span> <span class="nav-text">片上系统（片上系统）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Master-Slave-multiprocessors（主从多处理机）"><span class="nav-number">11.1.5.</span> <span class="nav-text">Master-Slave multiprocessors（主从多处理机）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Symmetric-Multiprocessors（SMP，对称多处理机）"><span class="nav-number">11.1.6.</span> <span class="nav-text">Symmetric Multiprocessors（SMP，对称多处理机）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多计算机"><span class="nav-number">11.2.</span> <span class="nav-text">多计算机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#广域分布式系统"><span class="nav-number">11.3.</span> <span class="nav-text">广域分布式系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟机技术"><span class="nav-number">11.4.</span> <span class="nav-text">虚拟机技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中间件"><span class="nav-number">11.5.</span> <span class="nav-text">中间件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安全-1"><span class="nav-number">12.</span> <span class="nav-text">安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#安全问题"><span class="nav-number">12.1.</span> <span class="nav-text">安全问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#验证"><span class="nav-number">12.2.</span> <span class="nav-text">验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部攻击"><span class="nav-number">12.3.</span> <span class="nav-text">内部攻击</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用代码漏洞"><span class="nav-number">12.4.</span> <span class="nav-text">利用代码漏洞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#恶意软件"><span class="nav-number">12.5.</span> <span class="nav-text">恶意软件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#病毒"><span class="nav-number">12.5.1.</span> <span class="nav-text">病毒</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#间谍软件"><span class="nav-number">12.5.2.</span> <span class="nav-text">间谍软件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#隐蔽软件"><span class="nav-number">12.5.3.</span> <span class="nav-text">隐蔽软件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#防御"><span class="nav-number">12.6.</span> <span class="nav-text">防御</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全模型"><span class="nav-number">12.7.</span> <span class="nav-text">安全模型</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2017 &mdash; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mrs_empress</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" href="https://hexo.io">Hexo</a></div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">Theme &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("73XX9zwrQOBeD6S0LGJO26Ac-gzGzoHsz", "92PFBxqwUfTSuVqrflFGaf5G");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
