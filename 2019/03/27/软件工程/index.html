<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">


  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="软件工程," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="This is my blog. 之前没有好好学习软件工程呢！ 所以打算好好开始看看呢！">
<meta name="keywords" content="软件工程">
<meta property="og:type" content="article">
<meta property="og:title" content="软件工程">
<meta property="og:url" content="http://mrsempress.top/2019/03/27/软件工程/index.html">
<meta property="og:site_name" content="Mrs_empress">
<meta property="og:description" content="This is my blog. 之前没有好好学习软件工程呢！ 所以打算好好开始看看呢！">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-05-07T08:31:01.628Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="软件工程">
<meta name="twitter:description" content="This is my blog. 之前没有好好学习软件工程呢！ 所以打算好好开始看看呢！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://mrsempress.top/2019/03/27/软件工程/"/>





  <title>软件工程 | Mrs_empress</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0b0957531a34243a173c768258ed03c4";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <a href="https://mrsempress.github.io/" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#fff; color:#151513; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mrs_empress</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Your bright sun</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-poem">
          <a href="/poem" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />
            
            poem
          </a>
        </li>
      
        
        <li class="menu-item menu-item-resume">
          <a href="http://mrsempress-certificate.oss-cn-beijing.aliyuncs.com/%E9%BB%84%E6%99%A8%E6%99%B0.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            resume
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mrsempress.top/2019/03/27/软件工程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mrs_empress">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mrs_empress">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">软件工程</h1>
        

        <div class="post-meta">
	  
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-27T22:59:23+08:00">
                2019-03-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/软件工程/" itemprop="url" rel="index">
                    <span itemprop="name">软件工程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/03/27/软件工程/" class="leancloud_visitors" data-flag-title="软件工程">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>This is <a href="https://mrsempress.github.io" target="_blank" rel="external">my blog</a>.</p>
<p>之前没有好好学习软件工程呢！</p>
<p>所以打算好好开始看看呢！</p>
<a id="more"></a>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>



<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><strong>软件工程</strong>是应用计算机科学、数学及管理科学等原理，以工厂化的原则和方法来解决软件问题的工程，其目的是<em>提高软件生产率、提高软件质量、降低软件成本。</em></p>
<p>软件工程学：</p>
<ul>
<li>软件开发技术<ul>
<li>软件开发方法学</li>
<li>软件工具</li>
</ul>
</li>
<li>软件工程管理<ul>
<li>软件工程管理学</li>
<li>软件经济学</li>
</ul>
</li>
</ul>
<hr>
<p>软件工程过程是指为获得软件产品，在软件工具的支持下由软件工程师完成的一系列软件工程活动</p>
<p>包括以下<strong>四个方面</strong>：</p>
<ol>
<li>P（Plan）软件规格说明，规定软件的功能及其运行时的限制</li>
<li>D（DO）软件开发，开发出满足规格说明的软件</li>
<li>C（Check）软件确认，确认开发的软件能够满足用户的需求</li>
<li>A（Action）软件演进，软件在运行过程中不断改进以满足客户新的需求</li>
</ol>
<hr>
<p><strong>原则：</strong></p>
<ol>
<li>抽象；</li>
<li>信息隐蔽；</li>
<li>模块化；</li>
<li>局部化；</li>
<li>确定性；</li>
<li>一致性；</li>
<li>完备性；</li>
<li>可验证性</li>
</ol>
<hr>
<p><strong>计算机软件：</strong></p>
<ul>
<li>系统软件：一整套服务于其他程序的程序</li>
<li>应用软件：解决特定业务需要的独立应用程序</li>
<li>工程/科学软件：通常带有”数值计算”算法的特征</li>
<li>嵌入式软件：面向最终使用者和系统本身的特性</li>
<li>产品线软件：为多个不同用户的使用提供特定功能</li>
<li>Web应用软件：以网络为中心</li>
<li>人工智能软件：利用非数值算法解决计算和直接分析无法解决的复杂问题</li>
<li>开放计算：普适计算、分布式计算</li>
<li>网络资源</li>
<li>开源软件</li>
</ul>
<hr>
<p>描述<strong>Bug</strong>的术语：</p>
<p>当人们在进行软件开发活动的过程中出错时（称为<strong>错误error</strong>），就会出现<strong>故障（fault）</strong>；是从开发人员的角度来看待系统；<strong>单个错误可能会产生多个故障</strong></p>
<p><strong>失效（failure）</strong>是指系统违背了它应有的行为；是从用户角度看到的问题；<strong>并非每一个故障对应于一个失效</strong>，如果不执行故障代码，则不会使代码失效</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>这七条原理被认为是确保软件产品质量和开发效率的原理的最小集合</p>
<ol>
<li>用分阶段的生命周期<strong>计划</strong>严格管理<br>在软件的这个生存周期中应该制定并严格执行六类计划：<ul>
<li>项目概要计划</li>
<li>里程碑计划</li>
<li>项目控制计划</li>
<li>产品控制计划</li>
<li>验证计划</li>
<li>运行维护计划</li>
</ul>
</li>
<li>坚持进行<strong>阶段评审</strong><br>统计发现设计错误占软件错误的63%，而编码错误仅占37%；而且错误发现与改正得越晚，所需付出的代价越高</li>
<li>实现严格的<strong>产品控制</strong><br>在软件开发中，改变需求是难免的；在改变需求时，为了保持软件各个配置成分的一致性，必须实行严格的产品控制，其中主要是实行<strong>基准配置管理</strong>；基准配置又称为<strong>基线配置</strong>，它是经过阶段评审后的软件配置成分；一旦有修改，必须按照严格的规程进行评审，在获得批准后才能实施修改</li>
<li>采用现代程序<strong>设计技术</strong><br>采用先进的技术既可以提高软件开发的效率，又可以降低软件维护的成本</li>
<li><strong>结果</strong>应能清楚地<strong>审查</strong></li>
<li>开发小组的<strong>人员应少而精</strong><br>人数多，则通信开销增加；高素质开发人员的效率高，同时错误也少</li>
<li>承认<strong>不断改进</strong>软件工程实践的必要性</li>
</ol>
<h2 id="软件生存周期"><a href="#软件生存周期" class="headerlink" title="软件生存周期"></a>软件生存周期</h2><p>一个软件产品或软件系统要经历孕育、诞生、成长、成熟、衰亡的阶段，一般称为<strong>软件生存周期</strong></p>
<p>从<strong>软件开发</strong>的观点看，它就是使用适当的资源（包括人员，软硬件资源，时间等），为开发软件进行的一组开发活动，在活动结束时输入（即用户的需求）转化为输出（最终符合用户需求的软件产品）</p>
<p>分为<strong>三个阶段：</strong></p>
<ul>
<li><p>定义阶段</p>
<ul>
<li><p><strong>可行性研究初步项目计划</strong></p>
<p>确定软件的<strong>开发目标</strong>及其<strong>可行性</strong></p>
<p>需要回答：要解决的问题是什么？有可行解吗？若有解，需要多少费用、资源、时间？</p>
<p>需要进行问题定义、可行性分析，制定项目开发计划</p>
<p><strong>参加人员：</strong>用户、项目负责人、系统分析师</p>
<p><strong>主要文档：</strong>可行性分析报告和项目开发计划</p>
</li>
<li><p>需求分析</p>
<p>准确地确定软件系统<strong>必须做什么</strong>，<strong>确定</strong>软件系统的功能、性能、数据和界面等<strong>要求</strong>，从而确定系统的<strong>逻辑模型</strong></p>
<p><strong>参加人员：</strong>用户、项目负责人、系统分析师</p>
<p><strong>主要文档：</strong>软件需求说明书</p>
</li>
</ul>
</li>
<li><p>开发阶段</p>
<ul>
<li><p>概要设计</p>
<p>开发人员把确定的各项<strong>功能需求</strong>转换成需要的<strong>体系结构</strong>，在该体系结构中，每个成分都是意义明确的模块，即每个<strong>模块</strong>都和某些<strong>功能需求</strong>相对应。</p>
<p>即设计软件的结构，明确软件由哪些模块组成，这些模块的层次结构、调用关系，功能，同时还要设计该项目的应用系统的总体数据结构和数据库结构，即应用系统要存储什么数据，这些数据是什么样的结构，它们之间有什么关系。</p>
<p><strong>参加人员：</strong>系统分析师、软件设计师</p>
<p><strong>主要文档：</strong>概要设计说明书</p>
</li>
<li><p>详细设计<br>对每个模块完成的功能进行<strong>具体描述</strong>，要把功能描述转变为精确的、结构化的<strong>过程描述</strong>。即该模块的控制结构是怎么样的，先做什么，后做什么，有什么样的条件判定，有些什么重复处理等，并用相应的表示工具把这些控制结构表示出来。</p>
<p><strong>参加人员：</strong>软件设计师、程序员</p>
<p><strong>主要文档：</strong>详细设计文档</p>
</li>
<li><p>实现<br>把每个模块的控制结构转换成计算机可接受的<strong>程序代码</strong>，即写成某种特定程序设计语言表示的源程序清单</p>
</li>
<li><p>测试<br>保证软件质量的重要手段，其主要方式是在设计测试用例的基础上检查软件的各个组成部分。</p>
<p><strong>参加人员：</strong>是另一部门（或单位）的软件设计师或系统分析师</p>
<p><strong>主要文档：</strong>软件测试计划、测试用例和软件测试报告</p>
</li>
</ul>
</li>
<li><p>运行和维护阶段</p>
<ul>
<li><p>运行</p>
</li>
<li><p>维护<br>软件生存周期中<strong>时间最长</strong>的阶段</p>
<p>修改的情况：发现隐含错误、为了适应软件工作环境、由于用户业务需求的增加需要扩充和增强软件性能、为将来的软件维护活动做预先准备</p>
</li>
<li><p>废弃</p>
</li>
</ul>
</li>
</ul>
<h1 id="软件过程"><a href="#软件过程" class="headerlink" title="软件过程"></a>软件过程</h1><p>在软件开发中所遵循的路线图称为<strong>“软件过程”</strong>。过程是活动的集合，活动是任务的集合。</p>
<p>软件过程有3层含义：个体含义（软件产品或系统在生存周期中的某一类活动的集合）、整体含义（软件产品或系统在所有上述含义下的软件过程的总体）、工程含义（解决软件过程的工程）</p>
<hr>
<p>过程包含以下7种类型的要素：</p>
<ol>
<li>活动</li>
<li>序列：活动的顺序</li>
<li>过程模型：是关于系统兴趣的观点</li>
<li>资源</li>
<li>控制</li>
<li>策略：指导原则</li>
<li>组织：过程代理的层次化结构</li>
</ol>
<hr>
<p>过程：一组有序的任务，它涉及<strong>活动、约束、资源</strong>使用的一系列步骤</p>
<p>软件开发过程有时又称为<strong>软件生命周期</strong></p>
<p>包含以下活动：</p>
<ul>
<li>需求分析与定义</li>
<li>系统设计</li>
<li>程序设计</li>
<li>编写程序</li>
<li>单元测试</li>
<li>集成测试</li>
<li>系统测试</li>
<li>系统交付</li>
<li>维护</li>
</ul>
<hr>
<p>开发团队人员：</p>
<ul>
<li>需求分析员</li>
<li>设计人员</li>
<li>程序员</li>
<li>测试人员</li>
<li>培训人员</li>
</ul>
<p>一般来说，维护过程中，开发团队的所有人员都需要参与</p>
<p><strong>资料管理人员</strong>负责准备和存储在系统生命周期中用到的文档，包括需求规格说明、设计描述、程序文档、培训手册、测试数据、进度等。</p>
<p><strong>配置管理小组</strong>，让开发人员知道若改变需求，需要改变哪些，会影响哪些；还要协调可能建立或支持的系统的不同版本</p>
<h2 id="评价模型"><a href="#评价模型" class="headerlink" title="评价模型"></a>评价模型</h2><h3 id="CMM（Capability-Maturity-Model-of-Software）"><a href="#CMM（Capability-Maturity-Model-of-Software）" class="headerlink" title="CMM（Capability Maturity Model of Software）"></a>CMM<em>（Capability Maturity Model of Software）</em></h3><p><strong>软件过程能力成熟度模型</strong>，提供了一种评价软件承接方能力的方法，同时它可帮助软件组织改进软件过程。</p>
<p>五个成熟度级别：</p>
<ol>
<li><p>初始级</p>
</li>
<li><p>可重复级<br>建立<strong>基本的项目管理过程和实践</strong>来跟踪项目费用、进度和功能特性，有必要的<strong>过程准则</strong>来<strong>重复</strong>以前在同类项目中的<strong>成功</strong></p>
</li>
<li><p>已定义级<br>管理和工程两方面的软件工程已经<strong>文档化、标准化</strong>，并综合成整个软件开发组织的标准软件过程。所有项目都采用<strong>根据实际情况修改后</strong>得到的<strong>标准软件工程</strong>来开发和维护软件。</p>
</li>
<li><p>已管理级<br>制定了软件过程和产品质量的<strong>详细度量标准</strong>。软件过程的产品质量都被开发组织的成员所理解和控制</p>
</li>
<li><p>优化级</p>
<p>加强了<strong>定量分析</strong>，通过来自<strong>过程质量反馈</strong>和来自<strong>新观念、新技术的反馈</strong>使过程能<strong>不断持续地改进</strong></p>
</li>
</ol>
<h3 id="CMMI"><a href="#CMMI" class="headerlink" title="CMMI"></a>CMMI</h3><p><strong>能力成熟度模型</strong>是若干过程模型的综合和改进，是支持多个工程学科和领域的、系统的、一致的过程改进框架，能适应现代工程的特点和需要，能提高过程的质量和工作效率。</p>
<p>两种表示方法：</p>
<ol>
<li><p>阶段式模型<br>类似于CMM，关注<strong>组织的</strong>成熟度</p>
<ol>
<li>初始的：过程不可预测且缺乏控制</li>
<li>可重复的：过程为项目服务</li>
<li>已定义的：过程为组织服务</li>
<li>定量管理的：过程已度量和控制</li>
<li>优化的：集中于过程改进</li>
</ol>
</li>
<li><p>连续式模型<br>关注于每个<strong>过程域的</strong>能力</p>
<p>能力等级：</p>
<ul>
<li>CL0（未完成的）</li>
<li>CL1（已执行的）</li>
<li>CL2（已管理的）</li>
<li>CL3（已定义级的）</li>
<li>CL4（定量管理的）</li>
<li>CL5（优化的）</li>
</ul>
</li>
</ol>
<h2 id="UP-统一过程"><a href="#UP-统一过程" class="headerlink" title="UP 统一过程"></a>UP 统一过程</h2><p><strong>统一过程模型</strong>是一种”<strong>用例和风险驱动</strong>，<strong>以架构为中心</strong>，<strong>迭代并且增量</strong>“的开发过程，由UML方法和工具支持。</p>
<p>迭代指的是将整个软件开发项目划分成许多个小的”袖珍项目”，每个”袖珍项目”都包含正常软件项目的所有元素：计划、分析与设计、构造、集成和测试，以及内部和外部发布。</p>
<p>典型代表：<strong><em>RUP（Rational unified Process）</em></strong>。RUP是UP的商业扩展，兼容UP，但比UP更完整、更详细</p>
<p>4个技术阶段及其制品：</p>
<ol>
<li><p>起始阶段<br>专注于项目的<strong>初创</strong>活动</p>
<p><strong>工作产品：</strong>构想文档、初始用例模型、初始项目术语表、初始业务用例、初始风险评估、项目计划（阶段及迭代）、业务模型以及一个或多个原型（需要时）</p>
<p><strong>里程碑：</strong>生命周期目标</p>
</li>
<li><p>精化阶段</p>
<p>在理解了最初的领域范围之后进行<strong>需求分析</strong>和<strong>架构演进</strong></p>
<p><strong>工作产品：</strong>用例模型、补充需求（包括非功能需求）、分析模型、软件体系结构描述、可执行的软件体系结构原型、修订的风险列表、项目计划（包括迭代计划、调整的工作流、里程碑和技术工作产品）以及初始用户手册</p>
<p><strong>里程碑：</strong>生命周期架构</p>
</li>
<li><p>构建阶段<br>关注系统的<strong>构建</strong>，产生<strong>实现模型</strong></p>
<p><strong>工作产品：</strong>设计模型、软件构件、集成的软件增量、测试计划及步骤、测试用例以及支持文档（用户手册、安装手册和对于并发增量的描述）</p>
<p><strong>里程碑：</strong>初始运作功能</p>
</li>
<li><p>移交阶段<br>关注于<strong>软件提交方面</strong>的工作，产生<strong>软件增量</strong></p>
<p><strong>工作产品：</strong>提交的软件增量、$\beta$测试报告和综合用户反馈</p>
<p><strong>里程碑：</strong>产品发布</p>
</li>
</ol>
<h2 id="软件过程模型"><a href="#软件过程模型" class="headerlink" title="软件过程模型"></a>软件过程模型</h2><p>也称为软件开发模型，它是软件开发全部过程、活动和任务的结构框架。</p>
<p><strong>静态模型</strong>描述过程，表明了从输入到输出的转换过程</p>
<p><strong>动态模型</strong>能够动态展现过程，这样用户能够看到中间产品和最终产品是如何随着时间的推移进行转换的</p>
<hr>
<p>过程模型中，方框表示活动，从左边进入的箭头表示资源，从右边离开的箭头表示输出，从顶部进入的箭头表示控制或约束，从下部进入的箭头表示机制（这些机制辅助开发人员执行活动，例如：工具、数据库或技术）</p>
<hr>
<p><strong>过程表示法：</strong>如何用执行过程的人员能够理解的方式记录过程</p>
<p><strong>过程模型：</strong>如何使用一组合适的活动、资源、产品和工具来描述过程</p>
<p><strong>过程建模支持工具：</strong>如何演示或模拟一个过程模型，从而可以评价资源的可用性、有用性和性能</p>
<p><strong>过程测度和评价：</strong>在特定的时间或环境下，如何判断哪些活动、资源、子过程和模型类型最有益于生产高质量产品</p>
<hr>
<h3 id="瀑布模型-Waterfall-Model"><a href="#瀑布模型-Waterfall-Model" class="headerlink" title="瀑布模型 Waterfall Model"></a>瀑布模型 <em>Waterfall Model</em></h3><p><strong><em>瀑布模型</em></strong>是将软件生存周期中的各个活动规定为依<strong>线性顺序连接</strong>的若干阶段的模型，包括<em>需求分析、设计、编码、测试、运行与维护</em>。它规定了由前至后、相互衔接的<strong>固定次序</strong>，如同瀑布流水逐级下落。</p>
<p>以<strong>文档</strong>为驱动，适合于<strong>软件需求很明确</strong>的软件项目的模型</p>
<p><strong>优点：</strong></p>
<p>容<strong>易理解</strong>，<strong>管理成本低</strong>；强调开发的阶段性早期计划及需求调查和产品测试</p>
<p><strong>不足：</strong></p>
<p>客户必须完整、正确、清晰地<strong>表达</strong>他们的<strong>需要</strong>；在开始的两个或三个阶段中，很<strong>难评估</strong>真正的进度状态；当<strong>接近项目结束时</strong>，出现了<strong>大量的集成和测试</strong>工作；直到项目结束之前，都<strong>不能演示系统的能力</strong>；对于项目风险的控制能力较弱</p>
<hr>
<h4 id="变体：V模型"><a href="#变体：V模型" class="headerlink" title="变体：V模型"></a>变体：V模型</h4><p>V模型<strong>左侧步骤向下推进</strong>，基本问题需求<strong>逐步细化</strong>，形成问题及解决方案的技术描述。一旦编码结束，沿着V模型<strong>右侧的步骤向上推进</strong>工作，其实际上是执行了一系列的<strong>测试（质量保证活动）</strong></p>
<p>瀑布模型关注<strong>文档和制品</strong>，而V模型关注<strong>活动和正确性</strong></p>
<hr>
<h3 id="阶段化开发"><a href="#阶段化开发" class="headerlink" title="阶段化开发"></a>阶段化开发</h3><p>阶段化开发：增量和迭代</p>
<p>通常会有两个系统在并行运行：产品系统和开发系统</p>
<p><strong>运行系统</strong>或<strong>产品系统</strong>是当前正在被客户和用户使用的系统；而<strong>开发系统</strong>是准备用来替换现行产品系统的下一个版本</p>
<h4 id="增量模型-Incremental-Model"><a href="#增量模型-Incremental-Model" class="headerlink" title="增量模型 Incremental Model"></a>增量模型 <em>Incremental Model</em></h4><p>将需求分段成<strong>一系列增量产品</strong>，每一增量<strong>分别开发</strong>。该模型采用随着日程时间的进展而<strong>交错的线性序列</strong>，每一线性序列产生软件的一个可发布的增量。客户对每个增量的使用和评估都作为下一个增量发布的<strong>新特征和功能</strong>。</p>
<p><strong>优点：</strong>（除具有瀑布模型的优点之外）</p>
<p>第一个可交付版本所需要的<strong>成本和时间很少</strong>；开发由增量表示的小系统所承担的<strong>风险不大</strong>；由于很快发布了第一个版本，因此可以<strong>减少用户需求的变更</strong>；运行<strong>增量投资</strong>，即在项目开始可以仅对一个或两个增量投资。</p>
<p><strong>不足：</strong></p>
<p>如果没有对用户的变更要求规划，那么产生的初始增量可能会造成后来增量的不稳定；如果需求不像早期思考的那样稳定和完整，那么一些增量需要重新开发，重新发布；管理发生的成本、进度和配置的复杂性可能会超出组织的能力。</p>
<h4 id="迭代模型"><a href="#迭代模型" class="headerlink" title="迭代模型"></a>迭代模型</h4><p>增量模型是<strong>增加</strong>功能，而迭代模型是在一开始就提交一个完整的系统，然后在每一个新的发布中<strong>改变</strong>每个子系统的功能。</p>
<h3 id="演化模型-Evolutionary-Model"><a href="#演化模型-Evolutionary-Model" class="headerlink" title="演化模型 Evolutionary Model"></a>演化模型 <em>Evolutionary Model</em></h3><p>演化模型是<strong>迭代</strong>的过程模型，特别适用于对<strong>软件需求缺乏准确认识</strong>的情况</p>
<h4 id="原型模型-Prototype-Model"><a href="#原型模型-Prototype-Model" class="headerlink" title="原型模型 Prototype Model"></a>原型模型 <em>Prototype Model</em></h4><p><strong>原型</strong>是预期系统的一个可执行版本，反映了系统性质的一个选定的子集。一个原型不必满足目标软件的所有约束，其目的是能<strong>快速、低成本</strong>地构建原型。</p>
<p>原型模型开始于沟通，<strong>其目的是定义软件的总体目标，标识需求</strong>，然后快速制定原型开发的计划，确定原型的目标和范围，采用快速设计的方式对其进行建模，并构建原型。被开发的原型应交付给客户使用，并收集客户的反馈意见，这些反馈意见在<strong>下一轮</strong>中对原型进行改进。（一轮完成后，下一轮才开始，和增量的交错线性不同）</p>
<p>根据原型的目的不同，原型可以分为：</p>
<ul>
<li><p>探索型原型</p>
<p>弄清<strong>目标的要求</strong>，确定所希望的特性，并探讨多种方案的可行性</p>
</li>
<li><p>实验型原型<br><strong>验证方案或算法的合理性</strong>，是在大规模开发和实现前，用于考查方案是否合适、规格说明是否可靠</p>
</li>
<li><p>演化型原型<br><strong>将原型作为目标系统的一部分</strong>，通过对原型的多次改进，逐步将原型演化成最终的目标系统</p>
</li>
</ul>
<p>系统测试阶段会确认，<strong>确认</strong>（<em>validation</em>）确保系统实现了所有的需求；也会对需求进行<strong>验证</strong>（<em>verification</em>），验证确保每一项功能都是正确的</p>
<h4 id="螺旋模型-Spiral-Model"><a href="#螺旋模型-Spiral-Model" class="headerlink" title="螺旋模型 Spiral Model"></a>螺旋模型 <em>Spiral Model</em></h4><p>螺旋模型将瀑布模型和原型模型合起来，加入了两种模型均忽略的<strong>风险分析</strong>，适用于<strong>庞大、复杂且具有高风险</strong>的系统</p>
<p>四个步骤：</p>
<ol>
<li>制定计划：决定目标、方案和限制</li>
<li>风险分析：评价方案、识别风险、消除风险</li>
<li>实施工程：开发、验证下一产品</li>
<li>用户评估</li>
</ol>
<p><strong>优点：</strong></p>
<p>支持<strong>用户需求的动态变化</strong>，为用户参与软件开发的所有关键决策提供了方便，有助于提高软件的适应能力，并且为项目管理人员及时调整管理决策提供了便利，从而降低了软件开发的风险。</p>
<p><strong>不足：</strong></p>
<p>开发人员需要具有丰富的风险评估经验和专门知识；过多的迭代次数会增加开发成本，延迟提交时间。</p>
<h4 id="喷泉模型-Water-Fountain-Model"><a href="#喷泉模型-Water-Fountain-Model" class="headerlink" title="喷泉模型 Water Fountain Model"></a>喷泉模型 <em>Water Fountain Model</em></h4><p>喷泉模型是一种以<strong>用户需求为动力</strong>，以对象作为驱动的模型，适合于<strong>面向对象的开发方法</strong>；开发过程具有迭代性和无间隙性（指在开发活动【如分析、设计、编码】之间不存在明显的边界）。</p>
<p>克服了瀑布模型不支持软件重用和多项开发活动集成的局限性</p>
<p><strong>优点：</strong></p>
<p>提高软件项目的开发效率，节省开发时间</p>
<p><strong>不足：</strong></p>
<p>需要大量开发人员，不利于项目的管理；需要严格管理文档，使得审核难度加大</p>
<h3 id="基于构件的开发模型-Component-based-Development-Model"><a href="#基于构件的开发模型-Component-based-Development-Model" class="headerlink" title="基于构件的开发模型 Component-based Development Model"></a>基于构件的开发模型 <em>Component-based Development Model</em></h3><p>利用<strong>预先包装的构件</strong>来构造应用系统。构件可以是组织<strong>内部开发</strong>的构件，也可以是<strong>商品化成品</strong>（Commercial Off-The-Self，COTS）软件构件。本质上是<strong>演化模型</strong>，需要以迭代方式构建构件。</p>
<p>包括<strong>领域工程</strong>和<strong>应用系统工程</strong>两部分</p>
<h3 id="形式化方法模型-Formal-Methods-Model"><a href="#形式化方法模型-Formal-Methods-Model" class="headerlink" title="形式化方法模型 Formal Methods Model"></a>形式化方法模型 <em>Formal Methods Model</em></h3><p>建立在<strong>严格数学基础上</strong>的一种软件开发方法，其主要活动是生成<strong>形式化的数学规格说明</strong></p>
<h3 id="其它模型"><a href="#其它模型" class="headerlink" title="其它模型"></a>其它模型</h3><h4 id="可操作规格说明模型"><a href="#可操作规格说明模型" class="headerlink" title="可操作规格说明模型"></a>可操作规格说明模型</h4><p><strong>可操作规格说明模型</strong>，通过演示系统行为的方式来评估或执行系统需求。即，一旦指定了需求，就可以用软件包进行演示。</p>
<p>瀑布模型把功能与设计分离，而可操作规格说明模型允许把功能和设计合并起来</p>
<h4 id="可转换模型"><a href="#可转换模型" class="headerlink" title="可转换模型"></a>可转换模型</h4><p>去除某些主要开发步骤来设法减少出错机会。利用自动化手段的支持，转换过程使用一系列转换把需求规格说明变为一个可支付使用的系统。</p>
<p>转换的样例有：</p>
<ul>
<li>改变数据表示</li>
<li>选择算法</li>
<li>优化</li>
<li>编译</li>
</ul>
<h1 id="软件开发方法"><a href="#软件开发方法" class="headerlink" title="软件开发方法"></a>软件开发方法</h1><h2 id="结构化方法"><a href="#结构化方法" class="headerlink" title="结构化方法"></a>结构化方法</h2><p>由结构化分析、结构化设计、结构化程序设计构成，是一种<strong>面向数据流</strong>的开发方法；总的指导思想是<strong>自顶向下、逐层分解</strong>，基本原则是<strong>功能的分解与抽象</strong>。适合于数据处理领域的问题。</p>
<p>结构化分析是根据<strong>分解与抽象</strong>的原则，按照系统中数据处理的流程，用<strong>数据流图</strong>来建立系统的功能模型，从而完成需求分析工作。</p>
<p>结构化设计是根据<strong>模块独立性准则</strong>，软件结构优化准则将数据流图转换为<strong>软件体系结构</strong>，用<strong>软件结构图</strong>来建立系统的物理模型，实现系统的概要设计。</p>
<p>结构化程序设计使用<strong>三种基本控制结构</strong>构造程序</p>
<h2 id="Jackson方法"><a href="#Jackson方法" class="headerlink" title="Jackson方法"></a>Jackson方法</h2><p><strong>面向数据结构</strong>的开发方法，适合于小规模的项目。</p>
<p>又发展了JSD（Jackson System Development）。首先建立现实世界的模型，再确定系统的功能需求，对需求的描述特别强调操作之间的时序性。它是以<strong>事件</strong>作为驱动的，是一种<strong>基于进程</strong>的开发方法。适用于<strong>时许特点较强的系统</strong>，包括数据处理系统和一些实时控制系统。</p>
<h2 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h2><p>开发原型系统首先确定用户需求，开发初始原型，然后征求用户对初始原型的改进意见，并根据意见修改原型。适合于<strong>用户需求不清、需求经常变化</strong>的情况。</p>
<h2 id="面向对象方法"><a href="#面向对象方法" class="headerlink" title="面向对象方法"></a>面向对象方法</h2><p>UML（Unified Modeling Language）同一建模语言是面向对象的标准建模语言。</p>
<h2 id="敏捷开发方法"><a href="#敏捷开发方法" class="headerlink" title="敏捷开发方法"></a>敏捷开发方法</h2><p>总体目标是通过”尽可能<strong>早地、持续地</strong>对有价值的软件的交付”使客户满意。</p>
<p>4条原则：</p>
<ol>
<li>相对于过程和工具，更强调个人和交互价值</li>
<li>更喜欢在生产运行的软件上花费时间，而不是将时间花费在编写各种文档上</li>
<li>将精力集中在与客户合作上，而不是合同谈判上</li>
<li>专注于对变化的反应，而不是创建一个计划而后遵循这个计划</li>
</ol>
<h3 id="极限编程XP"><a href="#极限编程XP" class="headerlink" title="极限编程XP"></a>极限编程XP</h3><p>XP是一种轻量级（敏捷）、高效、低风险、柔性、可预测的、科学的软件开发方式。</p>
<p>4个部分组成：</p>
<ul>
<li>4大价值观：沟通、简单性、反馈和勇气（尽早和经常交付功能的承诺）</li>
<li>5个原则：快速反馈、简单性假设、逐步修改、提倡更改和优质工作</li>
<li>12个最佳实践：规划游戏、小的发布、隐喻（对于系统将如何运行的设想取得一致意见）、简单设计（只处理当前的需求）、首先编写测试、重构（重新审视需求和设计，重新明确地描述它们以符合新的现有的需要）、结对编程、集体所有权、持续集成、可以忍受的步伐、在现场的客户、代码标准</li>
<li>行为</li>
</ul>
<h3 id="水晶法-Crystal"><a href="#水晶法-Crystal" class="headerlink" title="水晶法 Crystal"></a>水晶法 <em>Crystal</em></h3><p>水晶法认为每一个不同的项目都需要一套不同的策略、约定和方法论</p>
<p>它认为随着开发人员素质的提高，项目和过程的质量也随之提高。</p>
<h3 id="并列争球法-Scrum"><a href="#并列争球法-Scrum" class="headerlink" title="并列争球法 Scrum"></a>并列争球法 <em>Scrum</em></h3><p>使用迭代的方法，把每30天一次的迭代称为一个”冲刺”（sprint），并按优先级别来实现产品。多个自组织和自治的小组并行地递增实现产品。协调是通过简短的日常会议来进行。</p>
<h3 id="自适应软件开发-ASD"><a href="#自适应软件开发-ASD" class="headerlink" title="自适应软件开发 ASD"></a>自适应软件开发 <em>ASD</em></h3><h1 id="软件工具"><a href="#软件工具" class="headerlink" title="软件工具"></a>软件工具</h1><p>用来辅助软件开发、运行、维护、管理和支持等过程中的活动的软件称为软件工具</p>
<p>计算机辅助软件工程（<em>Computer-Aided Software Engineer，CASE</em>）工具</p>
<ul>
<li>软件开发工具<ul>
<li>需求分析工具</li>
<li>设计工具</li>
<li>编码与排错工具</li>
<li>测试工具</li>
</ul>
</li>
<li>软件维护工具<ul>
<li>版本控制工具</li>
<li>文档分析工具</li>
<li>开发信息库工具</li>
<li>逆向工程工具</li>
<li>再工程工具</li>
</ul>
</li>
<li>软件管理和软件支持工具<ul>
<li>项目管理工具</li>
<li>配置管理工具</li>
<li>软件评价工具</li>
</ul>
</li>
</ul>
<h1 id="软件开发环境"><a href="#软件开发环境" class="headerlink" title="软件开发环境"></a>软件开发环境</h1><p>指支持软件产品开发的软件系统，它由软件工具集和环境集成机制构成</p>
<h1 id="软件项目管理"><a href="#软件项目管理" class="headerlink" title="软件项目管理"></a>软件项目管理</h1><p>有效的软件项目管理集集中在4个P上，即</p>
<ul>
<li>人员（Person）：工作风格（外向/内向、理性/感性）<ul>
<li>项目管理人员</li>
<li>高级管理人员</li>
<li>研发人员</li>
<li>客户</li>
<li>最终用户</li>
</ul>
</li>
<li>产品（Product）</li>
<li>过程（Procedure）</li>
<li>项目（Project）</li>
</ul>
<hr>
<p>项目组织：</p>
<ul>
<li>主程序员负责制小组 <em>chief programmer team</em><ul>
<li>高度确定性、稳定性、一致性和重复性</li>
</ul>
</li>
<li>忘我方法 <em>egoless approach</em>：让每个人平等地承担责任，民主式投票产生结果<ul>
<li>大量的不确定性时</li>
</ul>
</li>
</ul>
<h2 id="软件项目估算"><a href="#软件项目估算" class="headerlink" title="软件项目估算"></a>软件项目估算</h2><p>方法：已完成类似项目、分解技术、经验</p>
<h3 id="成本估算方法"><a href="#成本估算方法" class="headerlink" title="成本估算方法"></a>成本估算方法</h3><p>自顶向下、自底向上、差别估算、专家估算法、类推估算法、算式估算法</p>
<p>悲观的预测x，乐观的预测y、最有可能的猜测z</p>
<p>则beta概率分布的平均值为$(x+4y+z)/6$</p>
<h3 id="COCOMO-估算模型"><a href="#COCOMO-估算模型" class="headerlink" title="COCOMO 估算模型"></a>COCOMO 估算模型</h3><ul>
<li><p>基本COCOMO模型（静态单变量）</p>
<p>$E=a(L)^b\\D=cE^d$</p>
<p>其中E工作量，D开发时间，L源代码行数</p>
</li>
<li><p>中级COCOMO模型（静态多变量，分为系统和部件）</p>
<p>$E=a(L)^bEAF$</p>
<p>其中EAF是工作量调节因子（15种影响软件工作量的因素）</p>
</li>
<li><p>详细COCOMO模型（分为系统、子系统、模块）</p>
</li>
</ul>
<p>演化成COCOMOII模型，包括应用组装模型、早期设计阶段模型、体系结构阶段模型</p>
<p>$E=bS^cm(X)$</p>
<p>其中，$bS^c$是初始的基于规模的估算，通过关于成本驱动因子信息的向量$m(X)$对它进行调整</p>
<h3 id="Putnam模型"><a href="#Putnam模型" class="headerlink" title="Putnam模型"></a>Putnam模型</h3><p>动态多变量模型，假设在软件开发的整个生存期种工作量有特定的分布</p>
<script type="math/tex; mode=display">
L=C_kE^{1/3}t_d^{1/3}</script><p>其中$t_d$表示开发持续时间，$C_k$表示技术状态常数，其值依赖于开发环境</p>
<h2 id="软件度量"><a href="#软件度量" class="headerlink" title="软件度量"></a>软件度量</h2><p>分类：</p>
<ol>
<li>面向规模的度量：通常用程序的代码行数LOC来衡量</li>
<li>面向功能的度量</li>
</ol>
<hr>
<ol>
<li>生产率度量</li>
<li>质量度量</li>
<li>技术度量</li>
</ol>
<p>复杂性度量：规模、难度、结构、智能度</p>
<h2 id="McCabe度量法"><a href="#McCabe度量法" class="headerlink" title="McCabe度量法"></a>McCabe度量法</h2><p>又称环路度量，是程序流程图的改变</p>
<p>度量值$V(G)=m-n+2p$</p>
<p>其中，m是弧的个数，n是结点数，p是强连通分量的个数</p>
<p>一般10是上限，要充分测试此模块变得很艰难</p>
<h2 id="进度管理"><a href="#进度管理" class="headerlink" title="进度管理"></a>进度管理</h2><p><strong>项目进度（Project schedule）</strong>通过列举项目的各个阶段，把每个阶段分解成离散的任务或活动，来描述特定项目的软件开发周期。</p>
<p><strong>可交付产品（deliverable）</strong>，即在项目开发的过程中客户希望看到的产品：</p>
<ul>
<li>文档</li>
<li>功能的演示</li>
<li>子系统的演示</li>
<li>精确性的演示</li>
<li>可靠性、安全性或性能的演示</li>
</ul>
<hr>
<p><strong>活动（actibity）</strong>：是项目的一部分，它在一段时间内发生</p>
<p>可以通过4个参数对活动进行描述：</p>
<ul>
<li>前驱（precursor）：活动的一组条件</li>
<li>工期（duration）</li>
<li>截止日期（due date）</li>
<li>终点（end point）：表示活动已经结束，通常是一个里程碑或可交付的产品</li>
</ul>
<p><strong>活动图：</strong>表示活动之间的依赖关系，虚线表示这些活动必须在后一个活动之前完成</p>
<p><strong>关键路径法（Critical Path Method， CPM）</strong>：是每个节点的时差都为零的路径</p>
<p><em>时差slack time/浮动时间float = 可用时间available time - 真实时间real time/实际时间actual time</em></p>
<p><em>时差=最晚开始时间 - 最早开始时间</em></p>
<p><strong>里程碑（milestone）</strong>是活动的完成——某一特定的时刻</p>
<p><strong>工作分解结构（work breakdown structure）</strong>：把项目描述为由若干离散部分构成的集合</p>
<hr>
<p>工具：</p>
<ul>
<li>Gantt甘特图<ul>
<li>水平条形图，以日历为基准</li>
<li>清晰地描述，每个任务从何时开始，到何时结束，任务的进展情况以及各个任务之间的并行性</li>
<li>但不能清楚地反映出各任务之间的依赖关系，难以确定整个项目的关键所在，也不能反映计划中有潜力的部分</li>
</ul>
</li>
<li>PERT（Program Evaluation &amp; Review Technique）项目计划评审技术图<ul>
<li>采用正态分布，对于实际时间的一个估计的窗口window/区间interval</li>
<li>有向图，箭头表示任务，结点表示事件</li>
<li>清晰地描述，每个任务从何时开始，到何时结束，给出各任务之间的关系，</li>
<li>但不能反映各个任务之间的并行性</li>
</ul>
</li>
</ul>
<h2 id="软件项目的组织"><a href="#软件项目的组织" class="headerlink" title="软件项目的组织"></a>软件项目的组织</h2><ul>
<li>主程序员制小组</li>
<li>民主制小组</li>
<li>层次式小组</li>
</ul>
<h2 id="软件质量管理"><a href="#软件质量管理" class="headerlink" title="软件质量管理"></a>软件质量管理</h2><p><strong>质量特性：</strong></p>
<ul>
<li>ISO/IEC 9126指标<ul>
<li>质量特性<ul>
<li>功能性</li>
<li>可靠性</li>
<li>易使用性</li>
</ul>
</li>
<li>质量子特性</li>
<li>度量指标</li>
</ul>
</li>
<li>Mc Call软件质量模型<ul>
<li>产品运行</li>
<li>产品修正</li>
<li>产品转移</li>
</ul>
</li>
</ul>
<p><strong>质量保证</strong></p>
<p><strong>软件评审</strong></p>
<p><strong>软件容错技术</strong></p>
<h2 id="软件配置管理"><a href="#软件配置管理" class="headerlink" title="软件配置管理"></a>软件配置管理</h2><p><em>Software Configure Management（SCM）</em>，用于整个软件工程过程，其目标是标识变更，控制变更，确保变更准确实现，报告有关变更</p>
<ul>
<li>基线：各开发阶段的一个特定点，使开发阶段的工作划分更明确</li>
<li>软件配置项 <em>Software Configure Item，SCI</em>，配置管理的基本单位</li>
<li>版本控制</li>
<li>变更控制</li>
</ul>
<h2 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h2><p><strong>风险类别</strong></p>
<p><strong>识别风险</strong></p>
<p><strong>风险预测/分析风险</strong></p>
<p><strong>评估风险/为每个风险分配优先级</strong></p>
<p>RE：风险显露度/风险暴露（risk exposure）</p>
<script type="math/tex; mode=display">
RE=P*C</script><p>其中，P是风险发生的概率，C是风险发生时带来的项目成本</p>
<p><strong>风险评估</strong></p>
<script type="math/tex; mode=display">
(r_i,l_i,x_i)</script><p>分别表示<strong>风险，概率，影响</strong></p>
<p><strong>风险杠杆</strong> = （降低前的风险暴露-降低后的风险暴露）/（降低风险的成本）</p>
<p><strong>风险控制</strong></p>
<hr>
<p>回归测试 <em>regression testing</em>：确保已有的功能仍能正常地工作</p>
<h1 id="获取需求"><a href="#获取需求" class="headerlink" title="获取需求"></a>获取需求</h1><p>关注于<strong>问题</strong></p>
<h2 id="需求过程"><a href="#需求过程" class="headerlink" title="需求过程"></a>需求过程</h2><p>寻找需求：标识关键实体、限定实体、定义实体之间的关系</p>
<p>特定于实现的描述不被认为是需求（除非是客户强行规定的），需求阶段的目标是理解客户的问题和需要，集中于<strong>客户和问题</strong>，而不是解决方案和实现</p>
<p><strong>规格说明（specification）</strong>阶段，将决定我们的软件系统将完成哪些需求；在<strong>设计（design）</strong>阶段，制定关于将如何实现指定行为的计划</p>
<p>需求过程的最终结果是<strong>软件需求规格说明SRS</strong>，它用于与其他软件开发人员（设计人员、测试人员、维护人员）交流，探讨最终产品行为</p>
<h2 id="需求引发"><a href="#需求引发" class="headerlink" title="需求引发"></a>需求引发</h2><h3 id="风险承担者"><a href="#风险承担者" class="headerlink" title="风险承担者"></a>风险承担者</h3><p>委托人：为要开发的软件支付费用的人</p>
<p>客户：在软件开发后购买软件的人</p>
<p>用户：熟悉当前系统，并将使用最终系统的人</p>
<p>领域专家：对软件必须自动化问题很熟悉的那些人</p>
<p>市场研究人员：进行调查，以确定将来的趋势以及潜在客户的需要的那些人</p>
<p>律师或审计人员：对政府、安全性以及法律的需求熟悉的那些人</p>
<p>软件工程师或其他技术专家：确保在技术上和经济上是可行的</p>
<h2 id="需求的类型"><a href="#需求的类型" class="headerlink" title="需求的类型"></a>需求的类型</h2><p><strong>功能需求（functional requirement）</strong>根据要求的活动来描述需要的行为。</p>
<p><strong>质量需求（quality requirement）/非功能性需求（nonfunctional requirement）</strong>描述一些软件解决方案必须拥有的质量属性：如快速的响应时间、易使用性、高可靠性或低维护代价</p>
<p><strong>设计约束（design constraint）</strong>是已经做出的设计决策或限制问题解决方案的设计决策：如平台或构件接口的选择</p>
<p><strong>过程约束（process constraint）</strong>是对用于构建系统的技术和资源的限制</p>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>需求可分为：必须的、值得要的、可选的</p>
<h3 id="两种需求文档"><a href="#两种需求文档" class="headerlink" title="两种需求文档"></a>两种需求文档</h3><p><strong>需求定义</strong> <em>requirement definition</em>：面向业务相关的人员</p>
<p><strong>需求规格说明</strong> <em>requirement specification</em>：面向技术性人员</p>
<h2 id="需求的特性"><a href="#需求的特性" class="headerlink" title="需求的特性"></a>需求的特性</h2><ul>
<li>正确</li>
<li>一致性</li>
<li>无二义性</li>
<li>完备</li>
<li>可行</li>
<li>相关</li>
<li>可测试</li>
<li>可跟踪</li>
</ul>
<h2 id="建模表示法"><a href="#建模表示法" class="headerlink" title="建模表示法"></a>建模表示法</h2><h3 id="实体-联系图"><a href="#实体-联系图" class="headerlink" title="实体-联系图"></a>实体-联系图</h3><p><em>entity-relationship diagram，ER diagram</em></p>
<p>3个核心结构：<strong>实体、属性和联系</strong></p>
<p>实体<em>entity</em>：矩形，代表具有共同性质和行为的现实世界对象构成的集合（有时也称为类）</p>
<p>联系<em>relationship</em>：表示为两个实体之间的边，边的中间有一个菱形，说明联系的类型</p>
<p>属性<em>attribute</em>：是实体上的注释，描述实体相关的数据或性质</p>
<h3 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h3><p>统一建模语言是用于文档化软件规格说明和设计的一组表示法</p>
<p>每一个方框是一个<strong>类</strong>，表示一组相似类型的实体。一个类具有<strong>名称（name）</strong>、<strong>属性（attribute）</strong>集和类的属性上的<strong>操作（operation）</strong>集</p>
<p>属性是简单数据变量（即它的值太简单，本身不足以成为一个类），其值可以随着时间和类实体的不同而发生变化</p>
<p><strong>类范围属性（class-scope attribute）</strong>用带下划线的属性表示，是被类的所有实例共享的数据值</p>
<p><strong>类范围操作（class-scope operation）</strong>书写为带下划线的操作，是由抽象类执行的操作，而不是由类的实例执行的操作</p>
<p>两个类之间的连线称为<strong>关联</strong>，表示类的实体之间的关系</p>
<p><strong>聚合关联（aggregate association）</strong>：<code>has-a</code>关系，用空心菱形的关联来表示</p>
<p><strong>组装（composition）</strong>关联是一种特殊类型的聚合，用实心菱形的聚合来表示</p>
<p>一端带有三角形的关联表示<strong>概化（generalization）</strong>关联，也称为子类型或<code>is-a</code>关系</p>
<p><strong>关联类（association class）</strong>，将属性和操作联系到关联上</p>
<h3 id="事件踪迹"><a href="#事件踪迹" class="headerlink" title="事件踪迹"></a>事件踪迹</h3><p><em>event trace</em></p>
<p>事件踪迹是关于现实世界实体之间交换的事件序列的图形描述</p>
<p>每一条竖线表示不同实体的时间线，其名字出现在线的顶部。每一条水平线表示两个实体之间的一个事件或交互，通常理解为从一个实体到另一个实体的消息传递。时间按从顶到下踪迹进展。每一个图描述一个<strong>踪迹（trace）</strong>，表示的是若干可能行为中的一个</p>
<h3 id="消息时序图"><a href="#消息时序图" class="headerlink" title="消息时序图"></a>消息时序图</h3><p><em>Message Sequence Chart</em></p>
<p>是扩充的事件踪迹表示法。具有创建和撤销实体、指定动作和计时器，以及组合事件踪迹的能力；一般只用于描述关键的场景，而不是说明整个问题。</p>
<p>每一条竖线表示一个参与的<strong>实体</strong>，而将一个<strong>消息</strong>描述为从发送实体到接收实体的箭头，箭头上的标记制定该消息的名称和数据参数。一个消息箭头可以向下斜，体现了消息发送时间和消息接受时间之间的时间段。虚线的箭头表示创建事件，产生新的实体。实体线底部的交叉符号表示实体执行的终结。<strong>动作（action）</strong>为位于实体执行线上的带标记的矩形。<strong>条件（condition）</strong>带标记的六边形。</p>
<h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p><em>state machine</em></p>
<p>用于在单个模型中表示一组事件踪迹，是一种图形描述，描述了系统与其环境之间的所有对话。每一个节点称为<strong>状态</strong>，表示存在于事件发生之间的一个稳定的条件集合。每一个边称为<strong>转移（transition）</strong>，表示由一个事件的发生而产生的行为或条件的变化。每一个转移都标记有触发事件，还可能有输出事件</p>
<h3 id="UML-状态图"><a href="#UML-状态图" class="headerlink" title="UML 状态图"></a>UML 状态图</h3><p>用于描述一个UML类中对象的动态行为。根据涉及的实体与实体之间的关系，刻画出了一个问题的静态的、总体的视图。<strong>没有说明实体是如何运转的，或对于输入事件，行为是如何变化的。</strong>而是说明的是，<strong>一个类的实例</strong>应该如何改变其状态，以及在这些对象彼此交互时，它们的属性值是如何改变的，即单个实体是如何响应输入事件以及产生输出事件的。</p>
<p>通常与MSC（消息时序图）【两个实体之间的消息传递】相辅相成。</p>
<p>具有<strong>公共转移</strong>的状态合并进<strong>超状态（superstate）</strong>，可以将超状态看作是子状态机，具有自己的状态和转移集。</p>
<hr>
<p>转移标记的语法：<code>event(args) [condition] \ action* ^Object.event(args)*</code></p>
<p><strong>触发事件</strong>是一个可能携带参数的消息；<strong>激活条件</strong>由方括弧括起来，是关于对象属性的谓词。如果一个转移发生，其动作（每一个的前面带有斜杠<code>&quot;/&quot;</code>）表示对象属性的赋值；星号<code>&quot;*&quot;</code>表明一个转移可能含有任意多个<strong>动作</strong>。如果该转移发生，它可能生成多个<strong>输出事件</strong>，表示为<code>/^对象.事件</code>(<code>/^Object.event</code>)。一个输出事件可能携带参数，或者指定目标对象，或者广播到所有对象。</p>
<p>可以没有触发事件、条件等，表示总是被激活的</p>
<hr>
<p><strong>动作&amp;活动：</strong></p>
<p>动作是一个相对没有时间花费的计算，并且是不可中断的；活动是更为重要复杂的计算，它执行一段时间，并且可以被中断。</p>
<h3 id="Petri图"><a href="#Petri图" class="headerlink" title="Petri图"></a>Petri图</h3><p>是<strong>状态-转移表示法</strong>的一种形式，用于建模并发活动以及它们之间的交互；Petri网中的圆圈称为<strong>位置</strong>，表示活动或条件；条表示<strong>变迁</strong>；有向的箭头称为弧，将变迁与其输入位置和输出位置连接在一起。位置中放置的是令牌（token），作为变迁的启动条件。当一个变迁被触发时，就清楚每一个输入位置中的令牌，并将令牌插入每一个输出位置。为每一条弧分配一个权重，指出在变迁触发的时候，在弧的输入位置清除了多少令牌，或者在弧的输出位置插入了多少令牌。</p>
<h3 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h3><p><em>data-flow diagram，DFD</em></p>
<p>建模功能以及从一个功能到另一个功能的数据流；一个泡泡表示一个<strong>加工（process）</strong>或功能，它转换数据。箭头表示<strong>数据流（data flow）</strong>。单个计算使用之外的持久数据保存在<strong>数据存储（data store）</strong>，它是一个正式的库或信息库，表示为两个平行的条。数据源或数据接收器表示为矩形，称为<strong>参与者（actor）</strong></p>
<p>优势：提供了两种直观的模型：一种是关于被提议系统的高层功能的，一种是各种加工之间的数据依赖关系。</p>
<p>最好作为问题的早期模型使用，因为此时细节并不是很重要。</p>
<h3 id="UML用例图"><a href="#UML用例图" class="headerlink" title="UML用例图"></a>UML用例图</h3><p><em>use-case diagram</em></p>
<p>类似于顶层的数据流图，它根据系统和系统的环境之间的交互，描述可观察到的、用户发起的功能。大的方框表示系统的边界；方框外的小人描绘的是参与者，包括人或系统；方框之内的椭圆是用例，表示<strong>必需的主要功能及其变种</strong>；参与者和用例之间的线表明参与者参与了该用例。用例不一定建模系统应该提供的所有任务，而是用于说明用户对重要系统行为的观察。</p>
<p>虚线箭头，标注构造型<code>&lt;&lt;include&gt;&gt;</code>或者<code>&lt;extend&gt;</code>，分别表示调用和扩展</p>
<h3 id="函数与关系"><a href="#函数与关系" class="headerlink" title="函数与关系"></a>函数与关系</h3><p>基于数学的规格说明和设计技术称为<strong>形式化方法</strong></p>
<p>当一个输入值映射到多个输出值的时候，就使用<strong>关系</strong></p>
<p>每一个输入都映射到单个输出，则这个函数定义上是<strong>一致的</strong>；如果一个函数为每一个不同的输入指定一个输出，则称为全函数，并且定义上是<strong>完备的</strong>。</p>
<h3 id="判定表"><a href="#判定表" class="headerlink" title="判定表"></a>判定表</h3><p><em>decision table</em></p>
<p>是函数规格说明的表格式表示，将事件和条件映射到适当的反应或动作上。</p>
<p>该规格说明是非形式化的，因为输入（事件和条件）和输出（动作）可以用自然语言表示，也可以用数学表达式表示，或者同时使用两者。</p>
<p>如果有$n$个输入条件，就可能会有$2^n$个条件的组合。</p>
<h3 id="Parnas表"><a href="#Parnas表" class="headerlink" title="Parnas表"></a>Parnas表</h3><p>是数学函数和关系的表格式表示；与判定表不同的是，Parnas表的输入和输出是纯数学表达式。</p>
<h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><p><strong>描述性的表示法</strong>是，根据问题或提议的解决方案的性质或者不变行为来对它进行描述的表示法，更适合于表达全局性质或约束</p>
<p><strong>逻辑</strong>由一种表述性质的语言加上一组推理规则组成，这些推理规则用于规定的性质导出新的、合乎逻辑的性质。</p>
<h3 id="对象约束语言"><a href="#对象约束语言" class="headerlink" title="对象约束语言"></a>对象约束语言</h3><p><em>Object control language</em></p>
<p>具有数学精确性，又对非数学专业人员易读、易写、易理解的约束语言</p>
<p>（感觉像是类似于数据库的E-R图+类图）</p>
<h3 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h3><p>发音为<em>zed</em></p>
<p><strong>形式化</strong>的需求规格说明语言，将<strong>集合论</strong>的变量定义组织到一个问题的完整的抽象数据类型模型当中，并使用逻辑来表示每一个操作的前置条件和后置条件。</p>
<p>Z利用软件工程的抽象方法将规格说明分解为可管理的模块，称为<strong>模式（schema）</strong></p>
<h3 id="SDL数据"><a href="#SDL数据" class="headerlink" title="SDL数据"></a>SDL数据</h3><p>SDL数据用于创建<strong>规格说明和描述语言（SDL）</strong>中的用户定义数据类型以及参数化的数据类型</p>
<p>操作：生成操作（构建定义数据类型的规范表示）、操纵操作（返回值）、查询</p>
<h2 id="需求和规格说明语言"><a href="#需求和规格说明语言" class="headerlink" title="需求和规格说明语言"></a>需求和规格说明语言</h2><p>一个完整的规格说明可能包含若干种模型，其中每一种说明系统的一个不同的方面</p>
<h3 id="统一建模语言UML"><a href="#统一建模语言UML" class="headerlink" title="统一建模语言UML"></a>统一建模语言UML</h3><p>UML标准包含8种图形建模表示法，再加上OCL约束语言：</p>
<ul>
<li>用例图<ul>
<li>一种高层的DFD（数据流图）</li>
<li>用在新项目的开始阶段，记录基本顶层功能</li>
</ul>
</li>
<li>类图<ul>
<li>一种ER图</li>
<li>UML规格说明中最重要的模型，强调问题的实体以及实体之间的相互关系</li>
</ul>
</li>
<li>时序图<ul>
<li>一种事件踪迹</li>
<li>开发阶段早期的行为模型</li>
<li>强调时间顺序</li>
</ul>
</li>
<li>合作图<ul>
<li>一种事件踪迹</li>
<li>强调类之间的关系</li>
</ul>
</li>
<li>状态图<ul>
<li>一种状态机模型</li>
</ul>
</li>
<li>OCL特性<ul>
<li>逻辑</li>
<li>描述建模元素的特性</li>
</ul>
</li>
</ul>
<h3 id="规格说明和描述语言SDL"><a href="#规格说明和描述语言SDL" class="headerlink" title="规格说明和描述语言SDL"></a>规格说明和描述语言SDL</h3><p>用于精确说明通过<strong>无限的消息队列通信</strong>的<strong>实时、并发、分布</strong>处理行为</p>
<p>包含3个主要的图，外加定义复杂数据类型的代数规格说明</p>
<ul>
<li>SDL系统图<ul>
<li>一种DFD</li>
<li>描述规格说明的<strong>高层</strong>块和连接各个块的通信信道。信道是有向的。</li>
<li>信道的消息传递是异步的，意味着不能对消息将被接收的时间做任何假设</li>
</ul>
</li>
<li>SDL方框图<ul>
<li>一种DFD</li>
<li>建模<strong>低层</strong>的一组块以及连接它们的消息延迟信道</li>
<li>同一模块中的进程之间的消息传送是即时接收的（高度耦合的进程，并行同步的进程应该处于同一模块中）</li>
</ul>
</li>
<li>SDL进程图<ul>
<li>一种状态机模型</li>
<li>其转移是语言构成成分的序列（输入、决策、任务、输出），起始或终止于状态的构成成分</li>
</ul>
</li>
<li>SDL数据类型（代数规格说明）<ul>
<li>用于声明复杂的、用户定义的变量类型</li>
</ul>
</li>
</ul>
<h4 id="软件成本降低SCR"><a href="#软件成本降低SCR" class="headerlink" title="软件成本降低SCR"></a>软件成本降低SCR</h4><p>鼓励采用好的<strong>软件工程设计原则</strong>而设计的一组技术，将软件需求建模为数学函数，该函数将<strong>监测变量</strong>映射为<strong>控制变量</strong>。每一个函数都负责设置一个控制变量的值或一个项的值。</p>
<h2 id="原型化需求"><a href="#原型化需求" class="headerlink" title="原型化需求"></a>原型化需求</h2><p>两种方法：（均称为快速化原型）</p>
<ul>
<li>抛弃型原型<ul>
<li>快速不考虑质量，确定问题的答案后抛弃</li>
</ul>
</li>
<li>演化型模型<ul>
<li>会演变成最终的产品</li>
</ul>
</li>
</ul>
<h2 id="需求文档"><a href="#需求文档" class="headerlink" title="需求文档"></a>需求文档</h2><p><strong>需求定义：</strong>（客户的术语记录需求）</p>
<ol>
<li>概述系统的总体目的和范围，并列出任何可能有用的术语、指称和缩写</li>
<li>描述系统的开发的背景和理由</li>
<li>描述可接受解决方案的基本特性</li>
<li>描述系统将运转的环境</li>
<li>描述客户对解决问题的提议</li>
<li>列出对环境行为所做的一切假设</li>
</ol>
<p><strong>需求规格说明</strong>：（开发人员的角度编写的，按照系统的接口）</p>
<ol>
<li>详细描述所有的输入和输出（包括源、目的地、值的范围、数据格式、协议等等）</li>
<li>根据接口的输入和输出陈述要求的功能</li>
<li>对每一个客户的质量需求，设计适配标准</li>
</ol>
<p><strong>过程管理（它跟踪）：</strong></p>
<ul>
<li>定义系统应该做什么的需求</li>
<li>需求生成的设计模块</li>
<li>实现设计的程序代码</li>
<li>验证系统功能的测试</li>
<li>描述系统的文档</li>
</ul>
<h2 id="确认和验证"><a href="#确认和验证" class="headerlink" title="确认和验证"></a>确认和验证</h2><p><strong>需求确认（requirements validation）</strong>，检查<em>需求定义</em>是否<em>准确地</em>反映了客户（风险承担者）的需要，通过<strong>走查</strong>、<strong>正式审查</strong>、<strong>需求评审</strong></p>
<p><strong>验证（verification）</strong>，检查一个文档或制品是否<em>符合</em>另一个文档或制品【在这一阶段，验证需求规格说明是否符合需求定义）</p>
<h2 id="测量需求"><a href="#测量需求" class="headerlink" title="测量需求"></a>测量需求</h2><p>对需求理解进行评分</p>
<h2 id="选择规格说明技术"><a href="#选择规格说明技术" class="headerlink" title="选择规格说明技术"></a>选择规格说明技术</h2><p>选择合适的标准，用标准来判断哪一个技术是最适合它的</p>
<h1 id="设计体系结构"><a href="#设计体系结构" class="headerlink" title="设计体系结构"></a>设计体系结构</h1><p>将系统<strong>分解</strong>为规模可管理的单元</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>客户及相应的开发人员，会经常在最初的需求分析完成后适当地修改需求</p>
<p><strong>体系结构风格：</strong>软件体系结构一般性的解决方案</p>
<p><strong>设计模式<em>design pattern</em></strong>：是一种针对单个软件模块或少量模块而给出的一般性解决方案，它提供相对较低层次的设计决策</p>
<p><strong>设计公约<em>design convention/idiom</em></strong>：是一系列设计决策和建议的集合，采用这些设计决策和建议，能够提高系统某方面的设计质量</p>
<p><strong>创新设计：</strong>基于基本的<em>设计原则</em>，创造全新的解决方案；与<strong>例程设计</strong>（评估更加严格、困难，且评估侧重于专家评估而不是客观标准，不太准确）相反</p>
<p>每个计划用来描述体系结构的一个方面或<strong>视图</strong></p>
<h2 id="体系结构建模"><a href="#体系结构建模" class="headerlink" title="体系结构建模"></a>体系结构建模</h2><p>使用体系结构模型的方式有以下6种：</p>
<ul>
<li>理解系统：它将做什么，以及如何做</li>
<li>确定该系统的哪部分将<strong>复用</strong>前面已经构建的系统中的元素，以及系统哪些部分将会被复用</li>
<li>展示构建系统的蓝图，包括系统可能的”承重”部分</li>
<li>推测系统将会如何演变，包括性能、成本以及原型开发的问题</li>
<li>分析依赖关系，选择合适的设计、实现和测试技术</li>
<li>为管理决策提供支持，了解实现和维护时系统固有的风险</li>
</ul>
<h2 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h2><p>“自顶向下”的方法</p>
<ul>
<li>功能性分解（根据功能或需求）</li>
<li>面向特征的设计（为每个模块指定了各自的特征）<ul>
<li>高层：描述了具有某个服务和特征集的系统</li>
<li>低层：描述了各个特征如何扩展服务，以及确定特征之间如何进行交互</li>
</ul>
</li>
<li>面向数据的分解<ul>
<li>高层：概念上的数据结构</li>
<li>低层：提供细节</li>
</ul>
</li>
<li>面向进程的分解<ul>
<li>高层：确定系统的主要任务，为进程指派任务；解释任务之间是如何协调工作的</li>
<li>低层：过程的实现细节</li>
</ul>
</li>
<li>面向事件的分解<ul>
<li>高层：将系统预期的输入编成目录</li>
<li>低层：将系统分解为状态，并描述事件是如何触发状态转移的</li>
</ul>
</li>
<li>面向对象的设计<ul>
<li>高层：定义了系统对象的类型，解释了对象之间是如何关联的</li>
<li>低层：细化了对象的属性和操作</li>
</ul>
</li>
</ul>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>不仅可以展示构件间如何交互，而且能够描述这个系统的分布，或者它能够展示系统提供的所有服务以及这些服务间如何协调操作的视图</p>
<p>体系结构视图一般包括：</p>
<ul>
<li>分解视图<ul>
<li>将系统描述为若干个可编程的单元</li>
</ul>
</li>
<li>依赖视图<ul>
<li>展示了软件单元之间的依赖关系</li>
</ul>
</li>
<li>泛化视图<ul>
<li>展示了一个软件单元是否是另一个单元的泛化或特化</li>
</ul>
</li>
<li>执行视图<ul>
<li>方框-箭头图</li>
<li>构件可能会拥有自己的程序栈</li>
<li>连接器是一种构件之间的通信机制</li>
</ul>
</li>
<li>实现视图<ul>
<li>代码单元和源文件之间建立映射</li>
</ul>
</li>
<li>部署视图<ul>
<li>运行时实体和计算机资源之间建立映射</li>
</ul>
</li>
<li>工作分配视图<ul>
<li>将系统分解成可以分配给各项目团队的工作任务</li>
</ul>
</li>
</ul>
<h2 id="体系结构风格和策略"><a href="#体系结构风格和策略" class="headerlink" title="体系结构风格和策略"></a>体系结构风格和策略</h2><p>体系结构风格是已建立的、大规模的系统结构模式</p>
<p>可以组合，有若干种组合方式：</p>
<ul>
<li>在系统分解的不同级别使用不同的风格</li>
<li>体系结构可以使用一个混合的风格来为不同的构件或者构件间不同类型的交互建模</li>
<li>当体系结构风格之间可以互相兼容时，风格的集成将会更加容易</li>
</ul>
<h3 id="管道和过滤器"><a href="#管道和过滤器" class="headerlink" title="管道和过滤器"></a>管道和过滤器</h3><p>管道不对数据进行处理，只是简单地将数据从一个过滤器到另一个过滤器；每个过滤器都是独立的</p>
<h3 id="客户-服务器"><a href="#客户-服务器" class="headerlink" title="客户-服务器"></a>客户-服务器</h3><p>服务器提供服务；客户通过<strong>请求/应答协议</strong>访问服务</p>
<p><strong><em>回调callback</em></strong>：客户向服务器发送一个可执行的函数</p>
<p>支持构件重用</p>
<h3 id="对等网络"><a href="#对等网络" class="headerlink" title="对等网络"></a>对等网络</h3><p><em>peer to peer, P2P</em></p>
<p>规模已扩展，但增加了系统的容量，对故障具有较好的容错性</p>
<p>每个构件本身既是客户端又是服务端</p>
<p>适合于文件是静态的、文件内容和性质并不是关键、共享速度和可靠性不是很重要的时候</p>
<h3 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布-订阅"></a>发布-订阅</h3><p>构件对其他构件的存在一无所知</p>
<p><strong>隐含调用：</strong>订阅者将自己的某个过程与感兴趣的事件建立关联</p>
<p>不利于单独测试，若需要共享固定不变的数据增加的信息库会减弱系统的可扩展性和可复用性</p>
<p>不影响其他的构件，轻松复用</p>
<h3 id="信息库"><a href="#信息库" class="headerlink" title="信息库"></a>信息库</h3><p><em>repository</em></p>
<p>由中心数据存储以及与其相关联的访问构件组成</p>
<p>对系统关键数据的中心式的管理</p>
<p><strong>黑板：</strong>知识源（数据存取器）</p>
<h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>只可以访问同层中的其他单元和相邻低层的接口所提供的服务；但是有时也会跨越（层次桥接）</p>
<p><em>在任何情况下任何层都不能访问它上面的层次</em></p>
<h2 id="质量属性的策略tatic"><a href="#质量属性的策略tatic" class="headerlink" title="质量属性的策略tatic"></a>质量属性的策略<em>tatic</em></h2><h3 id="可修改性"><a href="#可修改性" class="headerlink" title="可修改性"></a>可修改性</h3><p>策略：</p>
<ul>
<li>预测预期改变</li>
<li>高内聚性</li>
<li>低耦合</li>
<li>通用性</li>
<li>通过接口进行交互</li>
<li>多重接口</li>
</ul>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>描述了系统速度和容量上的特点，包括：</p>
<ul>
<li>响应时间：对请求的反应有多迅速</li>
<li>吞吐量：每分钟可以处理多少请求</li>
<li>负载：在响应时间和吞吐量变糟糕之前，可以支持多少用户使用</li>
</ul>
<p>策略：</p>
<ul>
<li>提高资源的利用率（并行、复制以及分布共享数据）</li>
<li>有效地管理资源分配</li>
<li>降低对资源的需求</li>
</ul>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>策略：</p>
<ul>
<li><p>能够阻挡<strong>攻击</strong>企图，就是具有高<strong>免疫力</strong>的；</p>
<ul>
<li>在设计中保证包含了所有的安全性特征</li>
<li>将可能被攻击者利用的安全性弱点最小化</li>
</ul>
</li>
<li><p>能够快速容易地从成功的<strong>攻击</strong>中恢复，就是具有高<strong>弹性</strong>的</p>
<ul>
<li>把功能分段，这样攻击造成的影响只会存在于系统的很小一部分之中</li>
<li>使系统能够在一小段时间里快速恢复功能和性能</li>
</ul>
</li>
</ul>
<h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><p>如果一个软件系统可以在假设的环境下正确地实现所要求的功能，则称这个软件系统是<strong>可靠的</strong></p>
<p>如果在”不正确的输入或意外的环境条件下”还能正常地工作，则称它是<strong>健壮的</strong></p>
<p><strong>故障：</strong>不可见的错误，只有开发人员可以看到的错误</p>
<p><strong>失效：</strong>可见的错误，是客户和用户所看到的问题</p>
<p><em>不是每个故障都会引起失效</em></p>
<p>策略：</p>
<ul>
<li>主动故障检测<ul>
<li>加入异常处理</li>
<li>加入某种形式的冗余<ul>
<li>n版本编程：如果两个功能相同的系统是由两个不同团队、在不同时间、使用不同的技术开发而成，那么这两种实现出现同样的故障的几率十分小</li>
</ul>
</li>
</ul>
</li>
<li>故障恢复<ul>
<li>需要立即处理，减少破坏性</li>
<li>随时做好恢复的准备的同时也会带来额外的开销</li>
<li>撤销事务</li>
<li>检验点/回退</li>
<li>备份</li>
<li>服务降级</li>
<li>修正和继续</li>
<li>报告</li>
</ul>
</li>
</ul>
<h3 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h3><p><strong>互相怀疑策略：</strong>每个软件单元都假设其他软件单元中含有故障</p>
<p>策略与可靠性相同，但是健壮性的问题来源在于软件环境中，而不是软件本身之中</p>
<h3 id="易使用性"><a href="#易使用性" class="headerlink" title="易使用性"></a>易使用性</h3><p>策略：</p>
<ul>
<li>用户界面需要放置于自己的软件单元中，或者是自己的体系结构层次中<ul>
<li>为不同国籍、不同能力的用户定制不同的界面</li>
</ul>
</li>
<li>一些用户发起的命令需要体系结构的支持</li>
<li>一些系统发起的活动要求系统维护一个环境模型</li>
</ul>
<h3 id="商业目标"><a href="#商业目标" class="headerlink" title="商业目标"></a>商业目标</h3><p>开发成本和产品上市时间最小化</p>
<p>策略：</p>
<ul>
<li>购买 or 开发</li>
<li>最初的开发成本 or 维护成本（提早交付 or 易于维护）</li>
<li>新的技术 or 已知的技术</li>
</ul>
<h2 id="体系结构的评估和改进"><a href="#体系结构的评估和改进" class="headerlink" title="体系结构的评估和改进"></a>体系结构的评估和改进</h2><h3 id="故障树分析"><a href="#故障树分析" class="headerlink" title="故障树分析"></a>故障树分析</h3><p>构造故障树（倒置的树），列出从结果到原因的逻辑路径，然后并根据选择的设计策略，将这些树用于故障改正或容错【和数字电路相同，有与门、或门】</p>
<p>每个节点代表一个<strong>独立</strong>的事件</p>
<h3 id="割集树"><a href="#割集树" class="headerlink" title="割集树"></a>割集树</h3><p>当故障树过于复杂或难以视觉分析的情况下，割集树就非常有用。它揭示了哪些事件的组合可以引起失效。</p>
<p><strong>构造割集树的规则</strong>：</p>
<ol>
<li>给割集树的顶点分配节点，使得该节点与故障树顶部的第一个逻辑门相对应</li>
<li>自顶向下地进行，按以下步骤扩展割集树<ul>
<li>扩展或门节点得到两个子节点，分别是或门的两个子节点</li>
<li>扩展与门节点得到一个合成的节点，由与门的两个子节点组合而成</li>
<li>扩展组合节点中的一个逻辑门产生节点，并把该组合节点中的其他逻辑门传播到各子节点中去</li>
</ul>
</li>
<li>持续进行，直到所有的子节点都是基本事件节点或者基本事件的合成节点</li>
</ol>
<p><strong>割集</strong>是割集树中子节点的集合，表示了引起树顶失效所需的事件的最小集合</p>
<h3 id="安全性分析"><a href="#安全性分析" class="headerlink" title="安全性分析"></a>安全性分析</h3><p>六个步骤：</p>
<ol>
<li>软件特征化<br>对系统的目标以及实现方式有了比较完整的理解</li>
<li>威胁分析<br>寻找威胁的来源、威胁活动</li>
<li>漏洞评估<br>漏洞的原因不仅仅是错误，也可能是由多义性、依赖性或者拙劣的错误处理引起的</li>
<li>风险可能性决策<br>对每个漏洞都要检查它暴露的可能性大小，需要考虑四个问题：动机（即某人或系统为什么具有威胁性）；威胁利用漏洞的能力；漏洞暴露的影响（即破坏性有多大，破坏遗留的时间会持续多久，以及是通过谁）；当前控制可以抵制漏洞暴露的程度</li>
<li>风险影响决策<br>级别最高的是业务终止性的；低一级别的是损害性的；再下一级别是可恢复的；最低级别的影响是妨碍</li>
<li>风险缓解计划<br>为降低最严重的风险的可能性和后果做计划</li>
</ol>
<h3 id="权衡分析"><a href="#权衡分析" class="headerlink" title="权衡分析"></a>权衡分析</h3><ul>
<li>一个规格说明，多个设计</li>
<li>比较表<ul>
<li>包含重要质量属性的表</li>
<li>表的每一行表示一个质量属性</li>
<li>表的每一列表示一种设计风格</li>
<li><code>-</code>表示没有该特性，<code>+</code>表示有该特性</li>
<li>接着为质量属性排优先级，然后每个设计标记满意度，相乘后相加</li>
</ul>
</li>
</ul>
<h3 id="成本效益分析"><a href="#成本效益分析" class="headerlink" title="成本效益分析"></a>成本效益分析</h3><p>用来估计和比较提议的改变所带来的成本和效益</p>
<ol>
<li><p>计算效益</p>
<p>限定在一段时间内</p>
</li>
<li><p>计算投资回报 ROI<br>ROI = 效益 / 成本</p>
<p>投资回收期：在累积的效益抵消实现时消耗成本之前的时间长度</p>
</li>
</ol>
<h3 id="原型化"><a href="#原型化" class="headerlink" title="原型化"></a>原型化</h3><h2 id="文档化软件体系结构"><a href="#文档化软件体系结构" class="headerlink" title="文档化软件体系结构"></a>文档化软件体系结构</h2><p>SAD需包含以下信息：</p>
<ul>
<li>系统综述：系统的主要功能和用途</li>
<li>视图：每个视图都从某个特定的角度传达了关于系统整体设计结构的信息；还应当包括视图之间的联系</li>
<li>软件单元：还应该包括它们的接口的精确规格说明</li>
<li>分析数据和结果：关于系统体系结构、计算资源和执行环境的充分信息</li>
<li>设计合理性</li>
<li>定义、术语表</li>
</ul>
<p>并且必须定义文档的版本号或者发行日期（确定使用了同一版本，并且是最新的）</p>
<p><strong>建立视图间的映射</strong></p>
<p><strong>文档化设计合理性</strong>，概述在构建设计的过程中所考虑的关键问题以及做出的权衡</p>
<h2 id="体系结构设计评审"><a href="#体系结构设计评审" class="headerlink" title="体系结构设计评审"></a>体系结构设计评审</h2><p><strong>确认（validating）：</strong>确认设计是否符合客户指定的所有需求</p>
<p><strong>验证（verification）：</strong>涉及保证设计是否遵循了良好的设计原则，且该设计的文档是否适合用户的需要；又分为<strong>主动设计评审</strong>（在SAD中发现问题）和<strong>被动评审过程</strong>（在阅读文档时发现问题）重点是发现错误而不是改正错误</p>
<h2 id="软件产品线"><a href="#软件产品线" class="headerlink" title="软件产品线"></a>软件产品线</h2><p>开发一系列相关产品的成本和工作量会远远小于单独开发这些产品的总和</p>
<p><strong>产品线</strong></p>
<p><strong>产品系列</strong></p>
<p><strong>核心资产库：</strong>一个系列的共性（可复用资源的集合【需求、设计、代码和测试用例等】）</p>
<p><strong>战略范围</strong></p>
<h1 id="设计模块"><a href="#设计模块" class="headerlink" title="设计模块"></a>设计模块</h1><h2 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h2><ol>
<li>使用自顶向下或者由外向内的方法，以关注系统的输入和期望的输出</li>
<li>首先探究设计中最难最不明确的一部分，因为隐蔽问题所引发的异常可能会迫使整个设计做出改变</li>
<li>按垂直切片的方式推进开发过程，每次都迭代地设计和完成各个功能子集（敏捷开发中）</li>
<li>使用自底向上的方法，尝试使用和调整已有的方案去解决该部分的设计</li>
</ol>
<p><strong>重构：</strong>为了简化过度复杂的方案，或者出于某特殊性能的考虑而对设计进行优化，会周期性地重审和修改设计决策</p>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p><strong>设计原则：</strong>把系统功能和行为分解成模块的指导方针</p>
<p>六个主要的原则：</p>
<ul>
<li>模块化/关注点分离<ul>
<li>耦合度<ul>
<li>当两个模块之间有大量依赖关系时，则说这两个模块是<strong>紧密耦合的</strong></li>
<li><strong>松散耦合的</strong>模块之间具有某种程度的依赖性，但是它们之间的相互连接比较弱</li>
<li><strong>非耦合的</strong>模块之间没有任何相互连接，它们之间是完全独立的</li>
<li>耦合类型：（越后面耦合程度越低）<ul>
<li>内容耦合：被修改的模块完全依赖于修改它的模块</li>
<li>公共耦合：对公共数据的改变意味着需要通过反向跟踪所有访问过该数据的模块来评估该改变的影响</li>
<li>控制耦合：某个模块通过传递参数或返回代码来控制另一个模块的活动</li>
<li>标记耦合：使用一个复杂的数据结构来从一个模块到另一个模块传送消息，并且传递的是该数据结构本身</li>
<li>数据耦合：传送的只是数据值，而不是结构数据时【理想的】</li>
<li>非耦合</li>
</ul>
</li>
</ul>
</li>
<li>内聚度：模块的内部元素的”粘合”程度（越后面内聚程度越高）<ul>
<li>巧合内聚：模块的各个部分互不相关</li>
<li>逻辑内聚：模块的各个部分只通过代码的逻辑结构相关联</li>
<li>时态内聚：设计被划分为几个用来表示不同执行状态的模块</li>
<li>过程内聚：组合在一起只是为了确保执行顺序</li>
<li>通信内聚：围绕数据集构造的模块</li>
<li>功能内聚：在一个模块中包含了所有必需的元素，并且每一个处理元素对于执行单个功能来说都是必需的（某个功能内聚的模块不仅执行设计的功能，而且只执行该功能，不执行其他功能）【理想的】</li>
<li>信息内聚：在功能内聚的基础上，将其调整为数据抽象化和基于对象的设计</li>
</ul>
</li>
</ul>
</li>
<li>接口：为系统其余部分定义了该软件单元提供的服务，以及如何获取这些服务<ul>
<li>一个对象的接口是该对象所有公共操作以及这些操作的<strong>签名</strong>的集合，指定了<em>操作名称、参数和可能的返回值</em></li>
<li>软件单元接口的<strong>规格说明</strong>描述了软件单元外部可见的性质<ul>
<li>目标：为每个访问函数的功能性建立充分详细的文档，以帮助其他开发人员找出最符合他们需要的访问函数</li>
<li>前置条件：所有的假设，以帮助其他开发人员了解在何种情况下，该软件单元才能正确工作</li>
<li>协议：协议的信息包括访问函数的顺序、两个构件交换消息的模式，比如，调用一个模块访问共享资源之前需要被授权允许</li>
<li>后置条件：可见的影响，为其编写文档，包括返回值、引发的异常以及公共变量的变化</li>
<li>质量属性：是对开发人员和用户可见的质量属性</li>
</ul>
</li>
</ul>
</li>
<li>信息隐藏：目标是使得软件系统更加易于维护；单元的设计决策被隐藏了</li>
<li>增量式开发<ul>
<li>使用关系：为各个软件单元和它依赖的单元之间建立关联</li>
<li>使用图：节点代表软件单元，有向边从使用其他单元的软件单元A出发指向被使用的单元B【表示需要一个正确的B，才能保证A也能正确地工作】良好的使用图应具有树型结构或者树型结构的森林</li>
<li>扇入<em>fan-in</em>：使用某个软件单元的软件单元数量</li>
<li>扇出<em>fan-out</em>：某个软件单元使用其他软件单元的数量</li>
<li>最终目的是创建高扇入、低扇出的软件单元</li>
<li>夹层法：消除循环，将循环中的一个单元被分解成两个单元</li>
<li>依赖倒置<em>dependency inversion</em></li>
</ul>
</li>
<li>抽象：忽略一些细节来关注其他细节的模型或表示</li>
<li>通用性：在开发软件单元时，使它尽可能地能够成为通用的软件，来加强它在将来某个系统中能够被使用的可能性<ul>
<li>软件工程原则之一就是<strong>可复用性</strong>：构造在将来的软件产品中仍可使用的软件单元，旨在通过复用来<strong>分摊</strong>开发的成本（分摊<em>amortization</em>是指，在计算软件单元的成本时，考虑每次使用的成本，而不是开发项目时的整个成本）</li>
<li>实现规则：<ul>
<li>将特定的上下文环境信息参数化</li>
<li>去除前置条件</li>
<li>简化后置条件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="面向对象的设计"><a href="#面向对象的设计" class="headerlink" title="面向对象的设计"></a>面向对象的设计</h2><p>如果一个设计将系统分解成若干个封装了数据和函数的运行时构件，即所谓的对象，那么该设计是面向对象的<em>object oriented</em></p>
<p>对象区别于其他构件的特征：</p>
<ul>
<li>对象是唯一<strong>可标识的</strong>运行时实体，它们可以设计为消息或请求的目标</li>
<li>对象是<strong>可组合的</strong>，因为它的数据变量本身可能也是对象，因而封装了对象的内部变量的实现</li>
<li>对象的实现可以通过<strong>继承</strong>的方式被复用和扩展，用来定义其他对象的实现</li>
<li>面向对象的代码可以是<strong>多态的</strong>：可以对多个不同但类型相关的对象都起作用的通用代码。相关类型的对象会对一些相同消息或请求做出响应，但不同类型的对象会有不同的响应</li>
</ul>
<p>对象的数据称作<strong>属性</strong>，而对象的操作称作<strong>方法</strong>；对象之间通过发送消息、调用彼此的方法进行交互。</p>
<p>对象是运行时实体；面向对象设计往往是由对象的<strong>类</strong>和<strong>接口</strong>构成的。接口声明了外部可访问的属性和方法。通常，这些信息是指公共方法，同时包含了这些方法的签名、前置条件、后置条件、协议要求以及可见的质量属性</p>
<p>若一个接口所提供的服务是另一个接口所提供的服务的严格子集，那么我们称前者是后者的<strong>子类型</strong>，<strong>后者称为前者的超类型</strong></p>
<hr>
<p><strong>抽象类</strong>    <strong>动态绑定</strong>    <strong>对象组合</strong>    <strong>继承</strong></p>
<p>类继承和对象组合之间的选择是一种涉及设计一致性、行为可预测性、设计决策的封装性、运行时性能和运行时可配置性的权衡</p>
<p>组合方法在保持被复用的封装性方面优于继承，因为组合的对象仅能通过它声明的接口来访问构件</p>
<p>组合的最大优点，在于它允许动态替换对象构件；缺点：很难仅通过研究代码，就能够想清楚或推理出程序的运行时结构，也并不能搞清楚一个对象到底引用了哪些对象，同时对象的引入了一层间接性，一个构件的方法的每一访问都必须先访问这个构件对象，可能会影响到程序运行时的性能</p>
<p>继承最大的好处就是，通过选择性地覆盖被继承的定义，可以改变和特化继承方法的行为，可以帮助我们快速创建具有新行为的、新的类型的对象。</p>
<hr>
<p><strong>可替换性：</strong>但是不是强制的，在很多设计中，不能满足</p>
<p>依赖父类的客户端代码在传送一个子类实例时，可能不能正常工作。</p>
<p><strong>利斯科夫替换原则</strong> <em>Liskov Substitutability Principle</em>描述了一下原则：（根据该原则，当同时满足以下条件时，一个子类对于其父类就是可替换的）</p>
<ol>
<li><p>子类支持父类的所有方法，并且他们的签名是兼容的。即子类的方法的参数和返回类型对于父类方法的对应的参数和返回类型，是可替代的。</p>
</li>
<li><p>子类的方法必须满足父类方法的规格说明。即这两个类的方法行为不一定要完全相同，但是子类必须不违反父类方法的前置条件以及后置条件<br>$pre_{\text{parent}} = pre_{\text{sub}} $</p>
<p>子类的前置条件必须和父类的前置条件相同或弱于父类的前置条件</p>
<p>$pre_{\text{parent}}\to (Post_{\text{sub}}\to Post_{\text{parent}})$</p>
<p>子类方法所做的和父类一样多，甚至比父类的还多</p>
</li>
<li><p>子类必须保留父类中声明了的所有性质</p>
</li>
</ol>
<hr>
<p>组合可能会导致类之间形成大量的依赖关系</p>
<p><strong>德米特法则</strong> <em>law of Demeter</em>（不要和陌生人说话）:通过把组合类中作用在类构件上的每个方法都包含进来，可以降低他们的依赖程度</p>
<p>比如：</p>
<ul>
<li>generateBill()方法调用CustomerAccount中的printSaleItems();</li>
<li>printSaleItems()调用合适的Sale对象中的printItemList()</li>
<li>printItemList()调用合适的Item对象中的打印方法</li>
</ul>
<p>往往会使用<strong>包装类</strong> <em>wrapper class</em>，以在不改变现有类的实现的前提下增加新功能。</p>
<p>尽管包装类使得向组合类中增加操作的任务变得轻松了，但同时也会使得设计更加复杂以及降低运行时的性能。</p>
<p>因此，在决定是否遵循德米特法则的时候，要在设计复杂度、开发时间、运行时性能、防止故障和易维护性之间进行权衡。</p>
<hr>
<p><strong>依赖倒置：</strong>消除类形成的依赖循环</p>
<p>客户端依赖于服务器</p>
<p>将依赖类（客户端）增加接口，然后打包成一个新的模块；再将被依赖类（服务器类）创建包装类，将两者连接起来；这样当服务器类改变接口时，不会影响客户端</p>
<hr>
<p>4种面向对象的结构（类、对象、 接口和实例变量）以及结构之间的关系，用箭头指示，箭头的末端的注释表明了关系的<strong>多重性</strong>（有时也称为”<strong>元数</strong>”）（几对几的关系）</p>
<h2 id="在UML中体现面向对象设计"><a href="#在UML中体现面向对象设计" class="headerlink" title="在UML中体现面向对象设计"></a>在UML中体现面向对象设计</h2><p>UML图包括了系统的动态视图、静态视图、约束和形式化</p>
<p>动态视图：</p>
<ul>
<li>用例图<em>use case diagram</em><ul>
<li>通过描述系统必须执行的一般过程对系统进行描述</li>
<li>活动图、领域模型对其进行补充</li>
<li>展示系统必要的功能，以及与系统交互的主要<strong>参与者 </strong> <em>actor</em></li>
</ul>
</li>
<li>活动列表</li>
<li>表示顺序和通信的交互图</li>
<li>表明状态及其变化的状态机</li>
</ul>
<p>静态视图：</p>
<ul>
<li><p>类图</p>
<ul>
<li>用来表示关系【关联、泛化、依赖和实现】和可扩展性【约束、标记值和构造性】）</li>
<li>关系类型<ul>
<li>直线 关联</li>
<li>组合 黑菱形</li>
<li>聚合 白菱形</li>
<li>泛化 空心三角形</li>
<li>依赖 虚线 实心三角形</li>
<li>导航 实心三角形</li>
</ul>
</li>
</ul>
</li>
<li><p>包图</p>
<ul>
<li>虚线表示包的依赖关系</li>
</ul>
</li>
<li>部署图<ul>
<li>如何为构件分配计算资源</li>
</ul>
</li>
</ul>
<p>约束和形式化：</p>
<ul>
<li>对象约束语言（OCL）</li>
</ul>
<p>模块设计首先从类图开始；接下来，将对系统的动态方面进行设计，交互图：顺序图（垂直线表示该对象的生命线）和通信图、活动图、状态图；最后将这些类打包，使得设计更加层次化、更便于理解。最终的模型是包图。</p>
<p>可以首先提取名词，寻找可以作为类的元素。</p>
<h2 id="面向对象设计模式"><a href="#面向对象设计模式" class="headerlink" title="面向对象设计模式"></a>面向对象设计模式</h2><p>见<a href="http://mrsempress.top/2019/02/27/设计模式/#more">设计模式</a></p>
<h2 id="面向对象的度量"><a href="#面向对象的度量" class="headerlink" title="面向对象的度量"></a>面向对象的度量</h2><p><strong>系统规模：</strong></p>
<ol>
<li>COCOMO</li>
<li>专化指数 <strong>SI=（NOO*深度） / 类的方法的总数</strong></li>
</ol>
<p>NOO：子类覆载override的操作数目</p>
<p><strong>设计质量：</strong></p>
<ol>
<li>每个类的加权</li>
<li>LCOM</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>数据管理</li>
<li>异常处理：用来消除易检查的前置条件的最有效的方法</li>
<li>用户界面设计</li>
<li>框架：设计复用</li>
</ol>
<h2 id="设计文档"><a href="#设计文档" class="headerlink" title="设计文档"></a>设计文档</h2><p><strong>按合同设计</strong></p>
<p>接口规格说明：</p>
<ul>
<li>需要</li>
<li>前置条件</li>
<li>协议</li>
<li>提供</li>
<li>后置条件</li>
<li>协议</li>
<li>质量属性</li>
</ul>
<h1 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h1><p>编程应该具有<strong>标准</strong>，不仅方便自己的修改，查找故障，之后返回工作等等；同时也助于小组工作</p>
<p>每个程序构件都至少包括3个主要方面：</p>
<ol>
<li>控制结构<br>通用化但又不影响其性能<br>文件开头列出构件之间传递的参数信息</li>
<li>算法<br>执行时间与设计质量、标准和客户需求之间平衡考虑<br>对于速度，需要了解编译器是如何优化代码的</li>
<li>数据结构：通常是为了适合于整体方案：促进信息隐藏和对构件接口的控制<br>保持程序简单</li>
</ol>
<p><strong>通用性指导原则：</strong></p>
<ol>
<li>局部化输入输出</li>
<li>包含伪代码</li>
<li>改正和重写，而不是打补丁</li>
<li>复用</li>
</ol>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><h3 id="程序文档"><a href="#程序文档" class="headerlink" title="程序文档"></a>程序文档</h3><p>解释程序做什么以及如何做的书面描述</p>
<h3 id="内部文档"><a href="#内部文档" class="headerlink" title="内部文档"></a>内部文档</h3><p>直接书写在代码中的描述性素材</p>
<p><strong>头注释块</strong>：提供概要信息以识别程序，描述数据结构、算法和控制流；通常以一组注释的形式放在每个构件的开始部分</p>
<p>必须包含：</p>
<ol>
<li>构件名字</li>
<li>谁编写了这个构件</li>
<li>构件应该装配在整个系统设计的哪个地方</li>
<li>构件是在何时编写和修改的</li>
<li>为什么要有这个构件</li>
<li>构件是如何使用数据结构、算法和控制的</li>
</ol>
<p><strong>其他注释块：</strong>对代码的解释，增加的是新信息而不是从标记和变量名中显而易见的部分</p>
<p><strong>有意义的变量名和语句标记</strong></p>
<p><strong>安排格式以增强理解：</strong>例如缩进</p>
<p><strong>文档化数据</strong></p>
<h3 id="外部文档"><a href="#外部文档" class="headerlink" title="外部文档"></a>外部文档</h3><p>设计人员不看代码，就评审外部文档</p>
<p>从系统的角度回答：who, what, where, when, how and why</p>
<p><strong>描述问题：</strong>不是重复需求文档，而是对背景的概要讨论，解释什么时候调用构件以及为什么需要它</p>
<p><strong>描述算法</strong></p>
<p><strong>描述数据</strong></p>
<h2 id="编程过程"><a href="#编程过程" class="headerlink" title="编程过程"></a>编程过程</h2><ul>
<li>将编程作为问题求解</li>
<li>极限编程</li>
<li>结对编程</li>
</ul>
<h1 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h1><p>测试并不是发现故障的第一事件，需求和设计评审也会帮助我们在开发的早期检查出存在的问题</p>
<p>测试的重点是<strong>发现故障</strong></p>
<h2 id="软件故障和失效"><a href="#软件故障和失效" class="headerlink" title="软件故障和失效"></a>软件故障和失效</h2><p>软件失效，意味着该软件没有做需求描述的事情</p>
<p>失效是系统某些方面的一个或多个故障造成的</p>
<p>故障不一定会产生失效</p>
<p>可能的原因：</p>
<ul>
<li>规格说明可能是错误的，或者遗漏了某个需求</li>
<li>对于指定的硬件和软件，规格说明可能包含不可能实现的需求</li>
<li>系统设计中可能包含故障</li>
<li>程序设计中可能包含故障</li>
<li>程序代码是错误</li>
</ul>
<p>测试的目标是发现错误，<em>只有当发现了错误或者由于测试过程而使得失效发生，一个测试才被认为是成功的</em></p>
<p><strong>故障识别</strong> <em>fault identification</em>是确定由哪一个故障或哪些故障引起失效的过程</p>
<p><strong>故障改正</strong> <em>fault correction</em>或<strong>故障去除</strong> <em>fault removal</em>则是修改系统使得故障得以去除的过程</p>
<p>故障的类型</p>
<ol>
<li><p>算法故障<em>Algorithmic fault</em>：由于处理步骤中的某些错误，使得对于给定的输入，构件的算法或逻辑没有产生适当的输出。这些故障有时仅通过通读程序（称为<strong>桌上检查</strong>）或者通过提交我们期望程序在其平常工作过程中接收的、来自于每一个不同类别数据的输入数据，就能很容易地找出来。</p>
<p>典型的算法故障包括：</p>
<ul>
<li>分支太早</li>
<li>分支太迟</li>
<li>对错误的条件进行了测试</li>
<li>忘记了初始化变量或忘记了设置循环不变量</li>
<li>忘记针对特定的条件进行测试</li>
<li>对不合适的数据类型变量进行比较</li>
</ul>
</li>
<li><p>语法故障<em>syntax fault</em></p>
</li>
<li><p>计算故障<em>computation fault</em>：一个公式的实现是错误的</p>
</li>
<li><p>精度故障<em>precision fault</em>：计算结果没有达到要求的精度</p>
</li>
<li><p>文档故障<em>documentation fault</em>：文档与程序实际做的事情不一致</p>
</li>
<li><p>压力故障或过载故障：队列长度、缓冲区大小、表的维度等的限制</p>
</li>
<li><p>能力故障或边界故障：系统活动到达指定的极限时，系统性能会变得不可接受</p>
</li>
<li><p>计时故障或协调故障：几个同事执行的或按仔细定义的顺序执行的进程之间的协调问题</p>
</li>
<li><p>吞吐量故障或性能故障：系统不能以需求规定的速度执行</p>
</li>
<li><p>硬件和系统软件故障</p>
</li>
<li><p>标准和过程故障</p>
</li>
</ol>
<p><strong>恢复故障</strong> <em>recovery fault</em></p>
<p>如果被分类的任何一项都只属于多个类别，则分类方案是正交的</p>
<h2 id="测试的组织"><a href="#测试的组织" class="headerlink" title="测试的组织"></a>测试的组织</h2><p><strong>模块测试</strong></p>
<p><strong>构件测试</strong></p>
<p><strong>单元测试</strong></p>
<p><strong>集成测试</strong>：是验证系统构件是否能够按照系统和程序设计规格说明中描述的那样<strong>共同</strong>工作的过程</p>
<p><strong>功能测试</strong></p>
<p><strong>验收测试</strong></p>
<p><strong>安装测试</strong></p>
<p><strong>系统测试</strong></p>
<p><strong>忘我编程</strong> <em>egoless programming</em>的态度，当发现一个故障或出现一次失效时，忘我开发团队关注的是修改故障，而不是谴责某个开发人员</p>
<p><strong>黑（闭）盒测试/白（开）盒测试</strong></p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ul>
<li><strong>代码评审</strong> <em>code review</em> 客观的是专家小组来评审代码及其文档<ul>
<li><strong>代码走查</strong> <em>code walkthrough</em> ：程序员向评审小组提交代码及其相关文档，然后评价它们的正确性，发现故障，不必修改它们</li>
<li><strong>代码审查</strong> <em>code inspection</em>：正式点，事前准备好的关注问题清单来检查代码和文档</li>
</ul>
</li>
</ul>
<ol>
<li>形式化证明技术（用逻辑变量说明，画出流程图，证明定理以及程序可终止）</li>
<li>符号执行，用符号代替变量执行</li>
<li>自动定理证明</li>
</ol>
<p><strong>测试</strong>是<strong>测试点/测试用例</strong>的集合</p>
<ul>
<li>语句测试：构件中的每条语句至少执行一次</li>
<li>分支测试</li>
<li>路径测试</li>
<li>定义使用的路径测试</li>
<li>所有使用的测试</li>
<li>所有谓词使用/部分计算使用的测试</li>
<li>所有计算使用/部分谓词使用的测试</li>
</ul>
<p><strong>事务流测试</strong></p>
<h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>集成策略的选择不仅依赖于系统特性，而且依赖于客户的期望<br>无论选择什么样的策略，测试的每个构件都只合并一次。而且，绝不要为了简化测试而修改构件。桩和驱动程序是单独的、新的程序，而不是现有程序的临时修改</p>
<ol>
<li><strong>自底向上集成</strong><br>合并构件来测试较大型系统的流行方法<br>每一个处于系统层次中最底层的构件首先被测试。接着要测试的是那些调用了前面已经测试构件的构件。反复地采用此方法，直到所有的构件都被测试完毕。<br>当很多底层构件是常被其他构件调用的通用实用例程的时候，当设计是面向对象的时候，或者当系统及集成大量独立的复用构件的时候，自底向上的方法是很有用的。<br>需要<strong>构件驱动程序</strong>，调用特定构件并向其传递测试用例的程序<br>顶层构件是最重要的，却是最后测试的构件。顶层指导主要的系统活动，而底层通常执行更为普遍的任务。顶层更概括，而较低层次更为具体。主要故障的发现会推迟到测试的后期（有时顶层的故障反映的是设计中的故障）顶层构件通常控制或影响计时，当系统的大部分处理都依赖于计时的时候，就很难自底向上地测试系统<br>对于<strong>面向对象</strong>的程序来说，自底向上的测试通常是最明智的选择。</li>
<li><strong>自顶向下集成</strong><br>顶层构件，通常是一个控制构件，是独立测试的。然后将被测构件调用的所有构件组合起来，作为一个更大的单元进行测试。重复执行这种方法，直到所有的构件都被测试。<br>正在测试的构件可能会调用还没有经过测试的别的构件，因此我们需要<strong>编写一个桩</strong> <em>stub</em>，这是一种专用程序，用于模拟缺少构件时的活动。但是编写桩比较困难，必须允许测试的所有可能的情况。并且测试中可能需要大量的桩<br><strong>不需要驱动程序</strong><br>修改以后：可以在合并之前单独测试构件，比如原来是(A) -&gt; (A,B,C)；修改后是(A) -&gt; (B) (C) -&gt; (A,B,C)</li>
<li><strong>一次性集成</strong><br>当所有构件都分别经过测试，再将它们合在一起作为最终系统进行测试，看看这个系统是否能一次运行成功<br>同时需要桩和驱动程序；所有的构件是一次性地进行合并，很难发现引起失效的原因；很难将接口故障与其他故障区分开来</li>
<li><strong>三明治集成</strong><br>将自底向上和自顶向下结合起来<br>将系统看成三层：目标层在中间<br>在顶层使用自顶向下的方法，而在较低层次使用自底向上方法<br>修改：和2一样，在合并之前单独测试较上层的构件</li>
</ol>
<h2 id="测试面向对象系统"><a href="#测试面向对象系统" class="headerlink" title="测试面向对象系统"></a>测试面向对象系统</h2><p>测试应该处理多个不同的层次：功能、类、聚集（协作对象的多组交互）和整个系统</p>
<p>和传统测试来说，在源代码分析、覆盖分析、测试用例生成、需求分析和验证方面不同</p>
<h2 id="测试计划"><a href="#测试计划" class="headerlink" title="测试计划"></a>测试计划</h2><p>测试计划：描述我们将以何种方式向客户证明软件运转正确（即软件没有故障并且执行需求中指定的功能）</p>
<p>不仅强调单元测试、集成测试，还包括系统测试<br>Who、Why、How、When</p>
<ol>
<li>制定测试目标</li>
<li>设计测试用例</li>
<li>编写测试用例</li>
<li>测试测试用例</li>
<li>执行测试</li>
<li>评估测试结果</li>
</ol>
<h2 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h2><h3 id="代码分析工具"><a href="#代码分析工具" class="headerlink" title="代码分析工具"></a>代码分析工具</h3><p>报告代码本身和正在运行的测试用例的相关信息</p>
<ul>
<li>静态分析：在程序没有实际执行时使用的分析工具<ul>
<li>代码分析器：语法错误/概念易出现故障或者未定义；产生符号表</li>
<li>结构检查器：将提交的构件作为输入，生成一张描述构件逻辑流的图。该工具检查结构方面的缺陷；确定循环的位置，标记永远不会执行的语句等</li>
<li>数据分析器：检查数据结构、数据声明和构件接口，然后指出构件间不合适的链接、冲突的构件定义以及不合法的数据使用；当分母为零的时候，进行通知</li>
<li>序列检查器：检查事件序列</li>
</ul>
</li>
<li>动态分析：当程序运行时进行的，称为程序监控器（监视并报告程序的行为）</li>
</ul>
<h3 id="测试执行工具"><a href="#测试执行工具" class="headerlink" title="测试执行工具"></a>测试执行工具</h3><ul>
<li>获取和重放： 在测试运行时获取键击、输入和响应，并且将期望的输出与实际的输出进行比较</li>
<li>桩和驱动程序</li>
<li>自动化的测试环境</li>
</ul>
<h3 id="测试用例生成器"><a href="#测试用例生成器" class="headerlink" title="测试用例生成器"></a>测试用例生成器</h3><p>结构化测试用例生成器</p>
<h2 id="停止测试"><a href="#停止测试" class="headerlink" title="停止测试"></a>停止测试</h2><p>刚开始发现的错误多的话，说明之后的错误也很多；因此估算剩余故障是一个重要的环节</p>
<h3 id="故障播种-错误播种"><a href="#故障播种-错误播种" class="headerlink" title="故障播种/错误播种"></a>故障播种/错误播种</h3><p>测试小组的一名成员在程序中有意地插入（播种）一定已知数目的故障，其他小组成员则尽可能多地查找故障</p>
<script type="math/tex; mode=display">
\frac{检测到的播种故障的数目s}{总的播种故障的数目S}=\frac{检测到的非播种故障的数目n}{总的非播种故障的数目N}</script><p>但是播种故障与程序中的实际故障难以保证时同种类型的而且复杂性相同；因此此方法，仅在以前构建过类似的系统时才有用。</p>
<p>通常情况下，我们会使用两个小组来查找，然后计算他们的有效性是多少，然后再计算出剩余的故障（有效性也要算进去）</p>
<h3 id="可信度"><a href="#可信度" class="headerlink" title="可信度"></a>可信度</h3><p>通常用一个百分数表示，它说明软件无故障的可能性</p>
<p>直到发现了s个故障后</p>
<script type="math/tex; mode=display">
c=\begin{cases}1\ \ \ n>N\\S(S-N+1)\ \ \ n\leq N\end{cases}</script><p>更改后，不用发现全部s个故障</p>
<script type="math/tex; mode=display">
c=\begin{cases}1\ \ \ n>N\\\left(\begin{matrix}S\\s-1\end{matrix}\right)\left(\begin{matrix}S+N+1\\N+s\end{matrix}\right)\ \ \ n\leq N\end{cases}</script><p>这些估算假定所有故障被检测到的概率相同</p>
<h3 id="其他标准"><a href="#其他标准" class="headerlink" title="其他标准"></a>其他标准</h3><p>通过计算代码的覆盖值</p>
<h3 id="识别出易出故障的代码"><a href="#识别出易出故障的代码" class="headerlink" title="识别出易出故障的代码"></a>识别出易出故障的代码</h3><p>通过分析树进行判断</p>
<h1 id="测试系统"><a href="#测试系统" class="headerlink" title="测试系统"></a>测试系统</h1><p>目标：确保系统能做客户想要它做的事情</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li>功能测试</li>
<li>性能测试</li>
<li>验收测试：由客户进行的测试，判断是否满足他们的需求（从客户的角度考虑）</li>
<li>安装测试</li>
</ol>
<p>递增测试需要仔细的计划，测试小组必须创建一个构建计划或集成计划来定义要测试的子系统，并且描述如何、何处、何时和由谁进行测试。构建计划的一个层次或子系统被称为一次旋转。旋转有编号，最低的层次称为旋转0</p>
<h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><p>系统配置：是向特定客户交付的一组系统构件</p>
<p>配置管理控制<strong>不同系统</strong>配置之间的差别，将风险和错误减少到最低程度</p>
<ol>
<li>版本发布</li>
<li>回归测试</li>
<li>delta、单独文件和条件编译</li>
<li>变化（变更）控制</li>
</ol>
<h2 id="测试小组"><a href="#测试小组" class="headerlink" title="测试小组"></a>测试小组</h2><ul>
<li>专业测试人员：组织并运行测试</li>
<li>分析员：参与最初需求定义和规格说明</li>
<li>系统设计人员：使测试小组的工作更具目的性</li>
<li>配置管理代表：当出现失效或变化请求的时候，配置管理专家安排该变动，使其反映在文档、需求、设计、代码或其他开发制品中</li>
<li>用户：最具资格来评价</li>
</ul>
<h3 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h3><p>有时候也称为”线程测试”</p>
<h4 id="因果图"><a href="#因果图" class="headerlink" title="因果图"></a>因果图</h4><p>该过程对需求的语义进行检查，并将输入和输出之间或输入和转换之间的关系重新表述为逻辑关系。</p>
<p>输入称为<strong>原因</strong>，输出和转换称为<strong>结果</strong>。其结果是一张反映这些关系的布尔图，称为因果图。</p>
<h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><ul>
<li>压力测试：当系统在短时间内到达其压力极限时，对系统进行的测试</li>
<li>容量测试：强调的是处理系统中的大量数据</li>
<li>配置测试：分析需求中指定的各种软件和硬件配置</li>
<li>兼容性测试：当一个系统与其他系统交互时，需要进行兼容性测试</li>
<li>回归测试：当正在测试的系统要代替一个现有系统的时候，必须进行回归测试</li>
<li>安全性测试：确保安全性需求得到满足</li>
<li>计时测试：评估涉及对用户的响应时间和一个功能的执行时间的相关需求</li>
<li>环境测试：考察系统在安装场所的执行能力</li>
<li>质量测试：评估系统的可靠性、可维护性和可用性；计算平均无故障时间和平均修复时间以及发现和修复一个故障的平均时间</li>
<li>恢复测试：强调的是系统对出现故障或丢失数据、电源、设备或服务时的反应</li>
<li>维护测试：为了帮助人们发现问题的根源提供诊断工具和过程的需要</li>
<li>文档测试：确保我们已经编写了必需的文档</li>
<li>人为因素测试：检查涉及系统用户界面的需求；也称为”可使用性测试”</li>
</ul>
<h3 id="可靠性、可用性以及可维护性"><a href="#可靠性、可用性以及可维护性" class="headerlink" title="可靠性、可用性以及可维护性"></a>可靠性、可用性以及可维护性</h3><p>可靠性指的是一段时期内的行为，而可用性指的是一段时间内某一特定时刻的事物</p>
<p>失效严重性级别：</p>
<ol>
<li>灾难性的</li>
<li>危机的</li>
<li>边缘性的</li>
<li>轻微的</li>
</ol>
<p>第一类不确定性：不能预测哪个故障将触发下一个失效</p>
<p>第二类不确定性：对去除故障的效果缺乏了解</p>
<hr>
<p>平均无故障时间：MTTF</p>
<p>平均修复时间：MTTR</p>
<p>平均失效间隔时间：$MTBF=MTTF+MTTR$</p>
<p>可靠性：$R=MTTF/(1+MTTF)$</p>
<p>可用性：$A=MTBF/(1+MTBF)$</p>
<p>可维护性：$M=(1+MTTR)$</p>
<p>随着发现和修复故障，如果失效间隔时间保持不变，则称其具有<strong>可靠性稳定性</strong>；如果失效间隔时间增加了，则称其具有<strong>可靠性增长</strong></p>
<hr>
<p>可靠性模型：</p>
<ol>
<li>Jelinski-Moranda</li>
<li>Musa</li>
<li>Littlewood</li>
</ol>
<h2 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h2><p>种类：</p>
<ol>
<li>基准测试：客户准备一组代表在实际安装后系统运作的典型情况的测试用例</li>
<li>试验性测试：在试验的环境中安装系统</li>
<li>并行测试：新的与旧系统一起并行运转</li>
</ol>
<ol>
<li>$\alpha$测试：内部测试</li>
<li>$\beta$测试：客户的试验</li>
</ol>
<h2 id="测试文档"><a href="#测试文档" class="headerlink" title="测试文档"></a>测试文档</h2><p>为了控制测试的复杂性和难度，我们使用完整的、详细设计的测试文档</p>
<ul>
<li><p>测试计划</p>
<p>描述系统本身以及测试所有功能及特性的计划</p>
</li>
<li><p>测试规格说明和评估</p>
<p>详细描述每一个测试，以及为测试针对的每一个特征定义评估标准</p>
</li>
<li><p>测试描述</p>
<p>为每一个单独的测试提供测试数据和过程</p>
<p>测试过程又称为测试脚本</p>
</li>
<li><p>测试分析报告</p>
<p>描述每一个测试的结果</p>
</li>
<li><p>问题报告表</p>
<p>来比较故障和失效的相关数据</p>
</li>
<li><p>差异报告表</p>
<p>是描述实际系统的行为和属性与我们预期的不相符的这类情况的问题报告</p>
</li>
<li><p>故障报告表</p>
<p>说明故障是如何发现和修复的</p>
</li>
</ul>
<h2 id="测试安全攸关的系统"><a href="#测试安全攸关的系统" class="headerlink" title="测试安全攸关的系统"></a>测试安全攸关的系统</h2><p>当一个系统在$10^9$小时内最多出现一次失效时，这个系统具有极端高可靠性</p>
<p>可以对设计的每一个构件分配失效率或约束，先达到每一个较低层的目标，将这些目标”积累起来”，最终达到整个系统的安全性目标。通过这种方式，我们为系统做出安全性案例，明确软件要达到的安全攸关系统的性能目标的方式</p>
<h2 id="故障树分析-1"><a href="#故障树分析-1" class="headerlink" title="故障树分析"></a>故障树分析</h2><p>帮助我们检查可能的后果、跟踪故障以回溯到其根源</p>
<p><strong>失效模式和后果分析FMEA</strong>是对故障树的补充，从已知的失效模式推出未知的系统后果</p>
<p><strong>危险</strong>是一个系统状态，与正好满足的条件一起，将导致一个事故</p>
<p><strong>失效模式</strong>是一种情形，使得危险发生</p>
<hr>
<p><strong>净室方法</strong></p>
<p>两个基本原理：</p>
<ol>
<li>根据规格说明证明软件，而不是等待单元测试发现故障</li>
<li>产生零故障或接近零故障的软件</li>
</ol>
<h2 id="交付系统"><a href="#交付系统" class="headerlink" title="交付系统"></a>交付系统</h2><p>从开发人员转向用户的两个关键问题：培训和文档</p>
<h2 id="培训"><a href="#培训" class="headerlink" title="培训"></a>培训</h2><p><strong>用户</strong>执行系统的主要功能，以帮助解决需求定义文档中描述的问题。因而，用户是客户的问题解决者</p>
<p><strong>操作员</strong>执行辅助任务功能的目的是支持主要的工作</p>
<p>分为：</p>
<ol>
<li><p>用户培训</p>
<p>主要是基于系统的主要功能以及用户使用它们的需要对用户进行的培训</p>
<p>不必了解系统的内部操作</p>
</li>
<li><p>操作员培训</p>
<p>熟悉系统支持功能。该培训针对的是系统是如何工作的，而不是系统做些什么。</p>
<p>如何启动和运行新系统；如何支持用户。首先操作员学习如何配置系统，如何授权或拒绝对系统的访问，如何分配任务大小或磁盘空间，以及如何监控和改进系统性能等诸如此类的事情。然后，操作员集中于开发的系统的细节：如何恢复丢失的文件或文档，如何与其他系统通信，以及如何调用各种支持过程</p>
</li>
<li><p>特殊培训需求</p>
<p>用户更换，系统更新</p>
</li>
</ol>
<p><strong>培训助手：</strong></p>
<ol>
<li>文档</li>
<li>图元和联机帮助</li>
<li>演示和上课</li>
<li>专家用户</li>
</ol>
<h2 id="文档-1"><a href="#文档-1" class="headerlink" title="文档"></a>文档</h2><p>在需求分析一完成，就开始计划培训和文档了</p>
<p><strong>种类：</strong></p>
<ol>
<li>考虑读者</li>
<li>用户手册（系统的目的或目标；系统的能力和功能；系统的特征、特性和优点，包括对系统所做工作的清晰展示</li>
<li>操作员手册（硬件和软件配置）</li>
<li>系统概况指南（针对客户）</li>
<li>教学软件和自动化系统的概述</li>
<li>其他的系统文档</li>
</ol>
<p><strong>用户帮助和疑难解答</strong></p>
<ol>
<li>失效消息参考指南</li>
<li>联机帮助</li>
<li>快速参考指南</li>
</ol>
<h1 id="维护系统"><a href="#维护系统" class="headerlink" title="维护系统"></a>维护系统</h1><p>任何针对系统改变所做的工作，都被认为是<strong>维护</strong></p>
<p><strong>种类：</strong></p>
<ol>
<li><p>S系统</p>
<p>由规格说明形式化定义的，并且是由规格说明导出的。</p>
<p>静态的，不容易适应问题中产生的变化</p>
</li>
<li><p>P系统</p>
<p>先抽象描述问题，然后根据抽象编写系统的需求规格说明</p>
</li>
<li><p>E系统</p>
<p>融入在现实世界中的系统，并随着现实世界的变化而改变</p>
</li>
</ol>
<p><strong>维护：</strong></p>
<ol>
<li>改正性维护：立即作出反应</li>
<li>适应性维护：对系统的一部分进行的改变会要求改系统的其他部分</li>
<li>完善性维护：利用基于规则的方法进行重新设计，可以增强将来的可维护性，以及使我们在将来更易于增加新的功能</li>
<li>预防性维护：预防失效的发生</li>
</ol>
<p><strong>维护问题：</strong></p>
<ol>
<li><p>有限的理解力</p>
<p>共m个构件，改变k个构件</p>
<p>则需要评估的数目：$k(m-k)+k(k-1)/2$</p>
</li>
<li><p>管理的优先级：超过技术优先级</p>
</li>
<li><p>士气</p>
</li>
</ol>
<h2 id="软件再生"><a href="#软件再生" class="headerlink" title="软件再生"></a>软件再生</h2><p>需要考虑：文档重构（静态分析）、重组（结构改变）、逆向工程（根据代码重新创建设计和规格说明信息）、再工程（先进行逆向工程，再进行再工程）</p>
<h1 id="评估产品、过程和资源"><a href="#评估产品、过程和资源" class="headerlink" title="评估产品、过程和资源"></a>评估产品、过程和资源</h1><h2 id="评估方法"><a href="#评估方法" class="headerlink" title="评估方法"></a>评估方法</h2><ol>
<li><p>特征分析</p>
<p>各属性进行评分和排列</p>
</li>
<li><p>调查</p>
</li>
<li><p>案例研究</p>
<p>确定影响结果的关键因素，随后记录下输入、约束、资源以及输出</p>
<p>用姐妹项目、基线、随机选择来避免偏见</p>
</li>
<li><p>正式的试验</p>
<p>严格的、受控的研究，他确定并操纵活动的关键因素，记录它们对结果的影响</p>
<p>自变量、因变量</p>
</li>
</ol>
<h2 id="评价与预测"><a href="#评价与预测" class="headerlink" title="评价与预测"></a>评价与预测</h2><p>评价：现有实体</p>
<p>预测：预测将来实体的某些属性</p>
<h2 id="评估产品"><a href="#评估产品" class="headerlink" title="评估产品"></a>评估产品</h2><p><strong>产品质量模型：</strong></p>
<ol>
<li><p>Boehm</p>
<p>可移植性、可靠性、完整性、一致性、可测试性、可理解性、可修改性、人类工程、效率、可维护性</p>
</li>
<li><p>ISO 9126</p>
<p>功能性、可用性、效率、可维护性、可移植性、可靠性</p>
</li>
<li><p>Dromey</p>
<p>正确性、内部的、上下文的、描述性的</p>
</li>
</ol>
<p><strong>基线：</strong>一般的/典型的结果</p>
<p><strong>目标：</strong>最小可接受行为的方式</p>
<h2 id="软件可复用性"><a href="#软件可复用性" class="headerlink" title="软件可复用性"></a>软件可复用性</h2><p>软件复用：指重复使用软件系统的任何部分，包括文档、代码、设计、需求、测试用例和测试数据等</p>
<p>从复用者来看有两种复用：</p>
<ul>
<li><p>生产者复用</p>
<p>创建可复用的构件</p>
</li>
<li><p>消费者复用</p>
<p>是在以后的系统中使用它们</p>
<ul>
<li>黑盒复用：我们可以使用整个产品，而<strong>不用对它进行修改</strong></li>
<li>透明盒/白盒复用：<strong>对其进行修改</strong>，使之符合特殊需要</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>组合式复用</p>
<p>将复用的代码看作是一组构造块，自底向上进行开发；它围绕可用的复用构件来构造系统的其他部分</p>
</li>
<li><p>生成式复用</p>
<p>针对于具体的应用领域</p>
</li>
</ul>
<p>其根本的活动是领域分析</p>
<hr>
<ul>
<li><p>水平复用</p>
<p>跨多个领域的复用</p>
</li>
<li><p>垂直复用</p>
<p>同一个应用领域中的复用</p>
</li>
</ul>
<hr>
<p>复用的一个最大障碍是需要在大量的软件产品中进行搜索，以找出最适合于具体需求的软件产品</p>
<p>解决方案是：<strong>构件分类</strong></p>
<ul>
<li><p>刻面分类</p>
<p>每个构件是通过称为”刻面”的特性的一个有序列表来描述，而不是使用层次方案</p>
<p><strong>刻面</strong>是一个描述符，有助于标识构件</p>
</li>
<li><p>分类系统由一个<strong>检索系统或库</strong>作为支撑</p>
</li>
</ul>
<h2 id="评估过程"><a href="#评估过程" class="headerlink" title="评估过程"></a>评估过程</h2><ul>
<li><p>事后分析</p>
<p>其目的是识别在将来的项目中可以改进的方面</p>
</li>
<li><p>过程成熟度模型</p>
<ul>
<li><p>能力成熟度模型CMM</p>
<p>​        初始级<code>-&gt;</code>可重复级<code>-&gt;</code>定义级<code>-&gt;</code>管理级<code>-&gt;</code>优化级</p>
<p>分别通过 过程制度化<code>-</code>过程定义<code>-</code>过程控制<code>-</code>持续的过程改进</p>
<p>以及通过 项目管理<code>-</code>工程化管理<code>-</code>量化的管理<code>-</code>变更管理</p>
<p>接下来分别对每一个等级说明关键过程域</p>
<ul>
<li>初始级：无</li>
<li>可重复级：需求管理、软件项目计划、软件项目跟踪及监督、软件分包合同管理、软件质量保证、软件配置管理；SADT图：左端输入、右端输出、约束在顶部、资源在底部</li>
<li>定义级：组织机构过程的焦点、组织机构过程的定义、培训计划、集成软件管理、软件产品工程、小组间协作、同行的评审；文档化的、标准化的和集成的</li>
<li>管理级：量化的过程管理、软件质量管理；重点是提高产品质量</li>
<li>优化级：故障预防、技术变更管理、过程变更管理；融入了量化的反馈以得到持续的过程改进</li>
</ul>
</li>
<li><p>SPICE：旨在协调并扩充现有的方法；既用于过程改进，也用于能力确定</p>
<ul>
<li>未执行级</li>
<li>非正式执行级</li>
<li>计划和跟踪级</li>
<li>定义明确级</li>
<li>量化控制级</li>
<li>持续改进级</li>
</ul>
</li>
<li><p>ISO 9000</p>
</li>
</ul>
</li>
</ul>
<h2 id="评估资源"><a href="#评估资源" class="headerlink" title="评估资源"></a>评估资源</h2><h3 id="人员成熟度模型"><a href="#人员成熟度模型" class="headerlink" title="人员成熟度模型"></a>人员成熟度模型</h3><p>等级表示一样</p>
<ul>
<li>初始级</li>
<li>可重复级：管理层负责管理其人员</li>
<li>定义级：基于能力的劳动力实践</li>
<li>管理级：测量和管理有效性，发展高绩效团队</li>
<li>优化级：持续的知识和技能提高</li>
</ul>
<h3 id="投资回报"><a href="#投资回报" class="headerlink" title="投资回报"></a>投资回报</h3><p><strong>净现值NVP</strong>：对评估软件相关的投资最有意义，用总的项目生命周期的形式表述经济价值，不考虑等级或时间限制；是收益的现值减去最初投资的值</p>
<p><strong>现值：</strong>预测的将来现金流量在今天的值</p>
<p><strong>贴现率</strong></p>
<p><strong>机会成本</strong></p>
<h1 id="改进预测、产品、过程和资源"><a href="#改进预测、产品、过程和资源" class="headerlink" title="改进预测、产品、过程和资源"></a>改进预测、产品、过程和资源</h1><h2 id="改进预测"><a href="#改进预测" class="headerlink" title="改进预测"></a>改进预测</h2><p>预测可能是不精确的，体现在两个不同的方面：</p>
<ol>
<li>当预测与产品实际可靠性<strong>始终不一致</strong>时，称预测时<strong>有偏误的</strong></li>
<li>当对一种测量的连续预测比实际可靠性具有更剧烈的波动时，称预测是<strong>有噪声的</strong></li>
</ol>
<p>处理<strong>偏误：U曲线</strong>：通过预测下一次失效的时间，然后测量，比较</p>
<p>预测和实际观察之间存在偏差：Kolmogorov距离</p>
<p>处理<strong>噪声：prequential似然度</strong></p>
<p><strong>重新校准预测</strong>：模型比以前更趋近于一致；与初始模型相比，新模型的偏误更少</p>
<h2 id="改进产品"><a href="#改进产品" class="headerlink" title="改进产品"></a>改进产品</h2><ol>
<li><strong>审查</strong></li>
<li><strong>复用</strong></li>
</ol>
<h2 id="改进过程"><a href="#改进过程" class="headerlink" title="改进过程"></a>改进过程</h2><ol>
<li>过程和能力成熟度</li>
<li>维护</li>
<li>净室方法</li>
</ol>
<h2 id="改进资源"><a href="#改进资源" class="headerlink" title="改进资源"></a>改进资源</h2><ol>
<li>工作环境</li>
<li>成本和进度的权衡</li>
</ol>
<h2 id="指导原则"><a href="#指导原则" class="headerlink" title="指导原则"></a>指导原则</h2><ol>
<li>目标是相同的吗？</li>
<li>目标的优先级是相同的吗？</li>
<li>问题是相同的吗？</li>
<li>测度是相同的吗？</li>
<li>成熟度是相同的吗？</li>
<li>过程是相同的吗？</li>
<li>受众是相同的吗？</li>
</ol>
<h1 id="软件工程的未来"><a href="#软件工程的未来" class="headerlink" title="软件工程的未来"></a>软件工程的未来</h1><p>一些回顾和难题</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>2019.05.07</p>
<p>终于看完了，完成了ANTLR的解释器，感觉还ok</p>
<p>完成了stereo的第一部分</p>
<p>接下来还有</p>
<ul>
<li>程序分析设计、project management、系统分析与设计的presentation</li>
<li>stereo的剩下两个部分</li>
<li>算法两次上机作业</li>
<li>100个政治知识点（领导晚点来检查，我好像只看了第一个</li>
<li>B类实验测试</li>
<li>……奇奇怪怪得事情，比如：我好久没练字了！！！！！！！！！！！</li>
</ul>
<p>转载请注明出处，谢谢。<br><blockquote class="blockquote-center"><p>愿 我是你的小太阳</p>
</blockquote></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=2931596&auto=1&height=66"></iframe>

<!-- UY BEGIN -->
<p><div id="uyan_frame"></div></p>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2142537"></script>

<!-- UY END -->

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>买糖果去喽</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechat.jpg" alt="Mrs_empress WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/软件工程/" rel="tag"><i class="fa fa-tag"></i> 软件工程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/24/随想小记2019-03-24/" rel="next" title="随想小记2019-03-24">
                <i class="fa fa-chevron-left"></i> 随想小记2019-03-24
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/02/CS231A/" rel="prev" title="CS231A">
                CS231A <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="/images/avatar.jpg"
              alt="Mrs_empress" />
          
            <p class="site-author-name" itemprop="name">Mrs_empress</p>
            <p class="site-description motion-element" itemprop="description">Hope be better and better, wish be happy and happy!</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives">
            
                <span class="site-state-item-count">108</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">44</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">74</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/mrsempress" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.facebook.com/chenxi.huang.56211" target="_blank" title="FB Page">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      FB Page
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/3309079767?refer_flag=1001030001_&nick=Mrs_empress_阡沫昕&is_hot=1" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      微博
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://tobiaslee.top" title="TobiasLee" target="_blank">TobiasLee</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://abcml.xin/" title="ZeZe" target="_blank">ZeZe</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://notes-hongbo.top" title="Bob" target="_blank">Bob</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://undefinedf.github.io/" title="Fjh" target="_blank">Fjh</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#概念"><span class="nav-number">1.</span> <span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本原理"><span class="nav-number">1.1.</span> <span class="nav-text">基本原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件生存周期"><span class="nav-number">1.2.</span> <span class="nav-text">软件生存周期</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#软件过程"><span class="nav-number">2.</span> <span class="nav-text">软件过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#评价模型"><span class="nav-number">2.1.</span> <span class="nav-text">评价模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CMM（Capability-Maturity-Model-of-Software）"><span class="nav-number">2.1.1.</span> <span class="nav-text">CMM（Capability Maturity Model of Software）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMMI"><span class="nav-number">2.1.2.</span> <span class="nav-text">CMMI</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UP-统一过程"><span class="nav-number">2.2.</span> <span class="nav-text">UP 统一过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件过程模型"><span class="nav-number">2.3.</span> <span class="nav-text">软件过程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#瀑布模型-Waterfall-Model"><span class="nav-number">2.3.1.</span> <span class="nav-text">瀑布模型 Waterfall Model</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#变体：V模型"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">变体：V模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#阶段化开发"><span class="nav-number">2.3.2.</span> <span class="nav-text">阶段化开发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#增量模型-Incremental-Model"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">增量模型 Incremental Model</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代模型"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">迭代模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#演化模型-Evolutionary-Model"><span class="nav-number">2.3.3.</span> <span class="nav-text">演化模型 Evolutionary Model</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原型模型-Prototype-Model"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">原型模型 Prototype Model</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#螺旋模型-Spiral-Model"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">螺旋模型 Spiral Model</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#喷泉模型-Water-Fountain-Model"><span class="nav-number">2.3.3.3.</span> <span class="nav-text">喷泉模型 Water Fountain Model</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于构件的开发模型-Component-based-Development-Model"><span class="nav-number">2.3.4.</span> <span class="nav-text">基于构件的开发模型 Component-based Development Model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#形式化方法模型-Formal-Methods-Model"><span class="nav-number">2.3.5.</span> <span class="nav-text">形式化方法模型 Formal Methods Model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其它模型"><span class="nav-number">2.3.6.</span> <span class="nav-text">其它模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#可操作规格说明模型"><span class="nav-number">2.3.6.1.</span> <span class="nav-text">可操作规格说明模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可转换模型"><span class="nav-number">2.3.6.2.</span> <span class="nav-text">可转换模型</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#软件开发方法"><span class="nav-number">3.</span> <span class="nav-text">软件开发方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#结构化方法"><span class="nav-number">3.1.</span> <span class="nav-text">结构化方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Jackson方法"><span class="nav-number">3.2.</span> <span class="nav-text">Jackson方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型方法"><span class="nav-number">3.3.</span> <span class="nav-text">原型方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象方法"><span class="nav-number">3.4.</span> <span class="nav-text">面向对象方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#敏捷开发方法"><span class="nav-number">3.5.</span> <span class="nav-text">敏捷开发方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#极限编程XP"><span class="nav-number">3.5.1.</span> <span class="nav-text">极限编程XP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#水晶法-Crystal"><span class="nav-number">3.5.2.</span> <span class="nav-text">水晶法 Crystal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并列争球法-Scrum"><span class="nav-number">3.5.3.</span> <span class="nav-text">并列争球法 Scrum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自适应软件开发-ASD"><span class="nav-number">3.5.4.</span> <span class="nav-text">自适应软件开发 ASD</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#软件工具"><span class="nav-number">4.</span> <span class="nav-text">软件工具</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#软件开发环境"><span class="nav-number">5.</span> <span class="nav-text">软件开发环境</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#软件项目管理"><span class="nav-number">6.</span> <span class="nav-text">软件项目管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#软件项目估算"><span class="nav-number">6.1.</span> <span class="nav-text">软件项目估算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#成本估算方法"><span class="nav-number">6.1.1.</span> <span class="nav-text">成本估算方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#COCOMO-估算模型"><span class="nav-number">6.1.2.</span> <span class="nav-text">COCOMO 估算模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Putnam模型"><span class="nav-number">6.1.3.</span> <span class="nav-text">Putnam模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件度量"><span class="nav-number">6.2.</span> <span class="nav-text">软件度量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#McCabe度量法"><span class="nav-number">6.3.</span> <span class="nav-text">McCabe度量法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进度管理"><span class="nav-number">6.4.</span> <span class="nav-text">进度管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件项目的组织"><span class="nav-number">6.5.</span> <span class="nav-text">软件项目的组织</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件质量管理"><span class="nav-number">6.6.</span> <span class="nav-text">软件质量管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件配置管理"><span class="nav-number">6.7.</span> <span class="nav-text">软件配置管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#风险管理"><span class="nav-number">6.8.</span> <span class="nav-text">风险管理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#获取需求"><span class="nav-number">7.</span> <span class="nav-text">获取需求</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#需求过程"><span class="nav-number">7.1.</span> <span class="nav-text">需求过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#需求引发"><span class="nav-number">7.2.</span> <span class="nav-text">需求引发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#风险承担者"><span class="nav-number">7.2.1.</span> <span class="nav-text">风险承担者</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#需求的类型"><span class="nav-number">7.3.</span> <span class="nav-text">需求的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解决冲突"><span class="nav-number">7.3.1.</span> <span class="nav-text">解决冲突</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两种需求文档"><span class="nav-number">7.3.2.</span> <span class="nav-text">两种需求文档</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#需求的特性"><span class="nav-number">7.4.</span> <span class="nav-text">需求的特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#建模表示法"><span class="nav-number">7.5.</span> <span class="nav-text">建模表示法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实体-联系图"><span class="nav-number">7.5.1.</span> <span class="nav-text">实体-联系图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UML-类图"><span class="nav-number">7.5.2.</span> <span class="nav-text">UML 类图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件踪迹"><span class="nav-number">7.5.3.</span> <span class="nav-text">事件踪迹</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息时序图"><span class="nav-number">7.5.4.</span> <span class="nav-text">消息时序图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#状态机"><span class="nav-number">7.5.5.</span> <span class="nav-text">状态机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UML-状态图"><span class="nav-number">7.5.6.</span> <span class="nav-text">UML 状态图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Petri图"><span class="nav-number">7.5.7.</span> <span class="nav-text">Petri图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据流图"><span class="nav-number">7.5.8.</span> <span class="nav-text">数据流图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UML用例图"><span class="nav-number">7.5.9.</span> <span class="nav-text">UML用例图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数与关系"><span class="nav-number">7.5.10.</span> <span class="nav-text">函数与关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判定表"><span class="nav-number">7.5.11.</span> <span class="nav-text">判定表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parnas表"><span class="nav-number">7.5.12.</span> <span class="nav-text">Parnas表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逻辑"><span class="nav-number">7.5.13.</span> <span class="nav-text">逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象约束语言"><span class="nav-number">7.5.14.</span> <span class="nav-text">对象约束语言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Z"><span class="nav-number">7.5.15.</span> <span class="nav-text">Z</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SDL数据"><span class="nav-number">7.5.16.</span> <span class="nav-text">SDL数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#需求和规格说明语言"><span class="nav-number">7.6.</span> <span class="nav-text">需求和规格说明语言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#统一建模语言UML"><span class="nav-number">7.6.1.</span> <span class="nav-text">统一建模语言UML</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#规格说明和描述语言SDL"><span class="nav-number">7.6.2.</span> <span class="nav-text">规格说明和描述语言SDL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#软件成本降低SCR"><span class="nav-number">7.6.2.1.</span> <span class="nav-text">软件成本降低SCR</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型化需求"><span class="nav-number">7.7.</span> <span class="nav-text">原型化需求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#需求文档"><span class="nav-number">7.8.</span> <span class="nav-text">需求文档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#确认和验证"><span class="nav-number">7.9.</span> <span class="nav-text">确认和验证</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测量需求"><span class="nav-number">7.10.</span> <span class="nav-text">测量需求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择规格说明技术"><span class="nav-number">7.11.</span> <span class="nav-text">选择规格说明技术</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#设计体系结构"><span class="nav-number">8.</span> <span class="nav-text">设计体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#设计"><span class="nav-number">8.1.</span> <span class="nav-text">设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#体系结构建模"><span class="nav-number">8.2.</span> <span class="nav-text">体系结构建模</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分解"><span class="nav-number">8.3.</span> <span class="nav-text">分解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#视图"><span class="nav-number">8.4.</span> <span class="nav-text">视图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#体系结构风格和策略"><span class="nav-number">8.5.</span> <span class="nav-text">体系结构风格和策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#管道和过滤器"><span class="nav-number">8.5.1.</span> <span class="nav-text">管道和过滤器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#客户-服务器"><span class="nav-number">8.5.2.</span> <span class="nav-text">客户-服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对等网络"><span class="nav-number">8.5.3.</span> <span class="nav-text">对等网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发布-订阅"><span class="nav-number">8.5.4.</span> <span class="nav-text">发布-订阅</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信息库"><span class="nav-number">8.5.5.</span> <span class="nav-text">信息库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分层"><span class="nav-number">8.5.6.</span> <span class="nav-text">分层</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#质量属性的策略tatic"><span class="nav-number">8.6.</span> <span class="nav-text">质量属性的策略tatic</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#可修改性"><span class="nav-number">8.6.1.</span> <span class="nav-text">可修改性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#性能"><span class="nav-number">8.6.2.</span> <span class="nav-text">性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全性"><span class="nav-number">8.6.3.</span> <span class="nav-text">安全性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可靠性"><span class="nav-number">8.6.4.</span> <span class="nav-text">可靠性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#健壮性"><span class="nav-number">8.6.5.</span> <span class="nav-text">健壮性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#易使用性"><span class="nav-number">8.6.6.</span> <span class="nav-text">易使用性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#商业目标"><span class="nav-number">8.6.7.</span> <span class="nav-text">商业目标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#体系结构的评估和改进"><span class="nav-number">8.7.</span> <span class="nav-text">体系结构的评估和改进</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#故障树分析"><span class="nav-number">8.7.1.</span> <span class="nav-text">故障树分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#割集树"><span class="nav-number">8.7.2.</span> <span class="nav-text">割集树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全性分析"><span class="nav-number">8.7.3.</span> <span class="nav-text">安全性分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#权衡分析"><span class="nav-number">8.7.4.</span> <span class="nav-text">权衡分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#成本效益分析"><span class="nav-number">8.7.5.</span> <span class="nav-text">成本效益分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型化"><span class="nav-number">8.7.6.</span> <span class="nav-text">原型化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文档化软件体系结构"><span class="nav-number">8.8.</span> <span class="nav-text">文档化软件体系结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#体系结构设计评审"><span class="nav-number">8.9.</span> <span class="nav-text">体系结构设计评审</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件产品线"><span class="nav-number">8.10.</span> <span class="nav-text">软件产品线</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#设计模块"><span class="nav-number">9.</span> <span class="nav-text">设计模块</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#设计方法"><span class="nav-number">9.1.</span> <span class="nav-text">设计方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计原则"><span class="nav-number">9.2.</span> <span class="nav-text">设计原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象的设计"><span class="nav-number">9.3.</span> <span class="nav-text">面向对象的设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在UML中体现面向对象设计"><span class="nav-number">9.4.</span> <span class="nav-text">在UML中体现面向对象设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象设计模式"><span class="nav-number">9.5.</span> <span class="nav-text">面向对象设计模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象的度量"><span class="nav-number">9.6.</span> <span class="nav-text">面向对象的度量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">9.7.</span> <span class="nav-text">其他</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计文档"><span class="nav-number">9.8.</span> <span class="nav-text">设计文档</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#编写程序"><span class="nav-number">10.</span> <span class="nav-text">编写程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#文档"><span class="nav-number">10.1.</span> <span class="nav-text">文档</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#程序文档"><span class="nav-number">10.1.1.</span> <span class="nav-text">程序文档</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部文档"><span class="nav-number">10.1.2.</span> <span class="nav-text">内部文档</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#外部文档"><span class="nav-number">10.1.3.</span> <span class="nav-text">外部文档</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编程过程"><span class="nav-number">10.2.</span> <span class="nav-text">编程过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#测试程序"><span class="nav-number">11.</span> <span class="nav-text">测试程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#软件故障和失效"><span class="nav-number">11.1.</span> <span class="nav-text">软件故障和失效</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试的组织"><span class="nav-number">11.2.</span> <span class="nav-text">测试的组织</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单元测试"><span class="nav-number">11.3.</span> <span class="nav-text">单元测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集成测试"><span class="nav-number">11.4.</span> <span class="nav-text">集成测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试面向对象系统"><span class="nav-number">11.5.</span> <span class="nav-text">测试面向对象系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试计划"><span class="nav-number">11.6.</span> <span class="nav-text">测试计划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试工具"><span class="nav-number">11.7.</span> <span class="nav-text">测试工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#代码分析工具"><span class="nav-number">11.7.1.</span> <span class="nav-text">代码分析工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试执行工具"><span class="nav-number">11.7.2.</span> <span class="nav-text">测试执行工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试用例生成器"><span class="nav-number">11.7.3.</span> <span class="nav-text">测试用例生成器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#停止测试"><span class="nav-number">11.8.</span> <span class="nav-text">停止测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#故障播种-错误播种"><span class="nav-number">11.8.1.</span> <span class="nav-text">故障播种/错误播种</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可信度"><span class="nav-number">11.8.2.</span> <span class="nav-text">可信度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他标准"><span class="nav-number">11.8.3.</span> <span class="nav-text">其他标准</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#识别出易出故障的代码"><span class="nav-number">11.8.4.</span> <span class="nav-text">识别出易出故障的代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#测试系统"><span class="nav-number">12.</span> <span class="nav-text">测试系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#过程"><span class="nav-number">12.1.</span> <span class="nav-text">过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置管理"><span class="nav-number">12.2.</span> <span class="nav-text">配置管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试小组"><span class="nav-number">12.3.</span> <span class="nav-text">测试小组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#功能测试"><span class="nav-number">12.3.1.</span> <span class="nav-text">功能测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#因果图"><span class="nav-number">12.3.1.1.</span> <span class="nav-text">因果图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#性能测试"><span class="nav-number">12.3.2.</span> <span class="nav-text">性能测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可靠性、可用性以及可维护性"><span class="nav-number">12.3.3.</span> <span class="nav-text">可靠性、可用性以及可维护性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#验收测试"><span class="nav-number">12.4.</span> <span class="nav-text">验收测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试文档"><span class="nav-number">12.5.</span> <span class="nav-text">测试文档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试安全攸关的系统"><span class="nav-number">12.6.</span> <span class="nav-text">测试安全攸关的系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#故障树分析-1"><span class="nav-number">12.7.</span> <span class="nav-text">故障树分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#交付系统"><span class="nav-number">12.8.</span> <span class="nav-text">交付系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#培训"><span class="nav-number">12.9.</span> <span class="nav-text">培训</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文档-1"><span class="nav-number">12.10.</span> <span class="nav-text">文档</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#维护系统"><span class="nav-number">13.</span> <span class="nav-text">维护系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#软件再生"><span class="nav-number">13.1.</span> <span class="nav-text">软件再生</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#评估产品、过程和资源"><span class="nav-number">14.</span> <span class="nav-text">评估产品、过程和资源</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#评估方法"><span class="nav-number">14.1.</span> <span class="nav-text">评估方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#评价与预测"><span class="nav-number">14.2.</span> <span class="nav-text">评价与预测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#评估产品"><span class="nav-number">14.3.</span> <span class="nav-text">评估产品</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件可复用性"><span class="nav-number">14.4.</span> <span class="nav-text">软件可复用性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#评估过程"><span class="nav-number">14.5.</span> <span class="nav-text">评估过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#评估资源"><span class="nav-number">14.6.</span> <span class="nav-text">评估资源</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#人员成熟度模型"><span class="nav-number">14.6.1.</span> <span class="nav-text">人员成熟度模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#投资回报"><span class="nav-number">14.6.2.</span> <span class="nav-text">投资回报</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#改进预测、产品、过程和资源"><span class="nav-number">15.</span> <span class="nav-text">改进预测、产品、过程和资源</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#改进预测"><span class="nav-number">15.1.</span> <span class="nav-text">改进预测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#改进产品"><span class="nav-number">15.2.</span> <span class="nav-text">改进产品</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#改进过程"><span class="nav-number">15.3.</span> <span class="nav-text">改进过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#改进资源"><span class="nav-number">15.4.</span> <span class="nav-text">改进资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指导原则"><span class="nav-number">15.5.</span> <span class="nav-text">指导原则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#软件工程的未来"><span class="nav-number">16.</span> <span class="nav-text">软件工程的未来</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#后记"><span class="nav-number">17.</span> <span class="nav-text">后记</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2017 &mdash; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mrs_empress</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" href="https://hexo.io">Hexo</a></div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">Theme &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("73XX9zwrQOBeD6S0LGJO26Ac-gzGzoHsz", "92PFBxqwUfTSuVqrflFGaf5G");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
