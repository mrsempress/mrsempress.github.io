<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">


  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Notes," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="编译原理 笔记">
<meta name="keywords" content="Notes">
<meta property="og:type" content="article">
<meta property="og:title" content="编译原理-笔记">
<meta property="og:url" content="http://mrsempress.top/2019/01/09/编译原理-笔记/index.html">
<meta property="og:site_name" content="Mrs_empress">
<meta property="og:description" content="编译原理 笔记">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://mrsempress.top/2019/01/09/编译原理-笔记/%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BF%BB%E8%AF%91.png">
<meta property="og:image" content="http://mrsempress.top/2019/01/09/编译原理-笔记/%E7%BC%96%E8%AF%91%E5%99%A8.png">
<meta property="og:image" content="http://mrsempress.top/2019/01/09/编译原理-笔记/%E8%A7%A3%E9%87%8A%E5%99%A8.png">
<meta property="og:image" content="http://mrsempress.top/2019/01/09/编译原理-笔记/%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="http://mrsempress.top/2019/01/09/编译原理-笔记/Thompson%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="http://mrsempress.top/2019/01/09/编译原理-笔记/Thompson%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="http://mrsempress.top/2019/01/09/编译原理-笔记/%E6%A8%A1%E6%8B%9FNFA.png">
<meta property="og:image" content="http://mrsempress.top/2019/01/09/编译原理-笔记/%E5%AD%90%E9%9B%86%E6%B3%95%E6%9E%84%E9%80%A0DFA.png">
<meta property="og:image" content="http://mrsempress.top/2019/01/09/编译原理-笔记/%E5%8C%96%E7%AE%80DFA.png">
<meta property="og:image" content="http://mrsempress.top/2019/01/09/编译原理-笔记/%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E5%99%A8%E6%A8%A1%E5%9E%8B.png">
<meta property="og:image" content="http://mrsempress.top/2019/01/09/编译原理-笔记/%E7%9F%AD%E8%AF%AD.png">
<meta property="og:image" content="http://mrsempress.top/2019/01/09/编译原理-笔记/%E7%A7%BB%E8%BF%9B%E5%BD%92%E7%BA%A6%E5%88%86%E6%9E%90%E5%99%A8.png">
<meta property="og:image" content="http://mrsempress.top/2019/01/09/编译原理-笔记/%E6%9E%84%E9%80%A0SLR(1">
<meta property="og:image" content="http://mrsempress.top/2019/01/09/编译原理-笔记/%E6%B4%BB%E5%89%8D%E7%BC%80.png">
<meta property="og:image" content="http://mrsempress.top/2019/01/09/编译原理-笔记/SLR%E5%88%86%E6%9E%90%E8%A1%A8.png">
<meta property="og:image" content="http://mrsempress.top/2019/01/09/编译原理-笔记/%E6%96%87%E6%B3%95%E8%BD%AC%E6%8D%A2%E5%9B%BE.png">
<meta property="og:image" content="http://mrsempress.top/2019/01/09/编译原理-笔记/%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E8%A1%A8.png">
<meta property="og:image" content="http://mrsempress.top/2019/01/09/编译原理-笔记/%E9%A9%B1%E5%8A%A8%E5%99%A8.png">
<meta property="og:image" content="http://mrsempress.top/2019/01/09/编译原理-笔记/%E7%A7%BB%E8%BF%9B-%E5%BD%92%E7%BA%A6%E8%A1%A8.png">
<meta property="og:image" content="http://mrsempress.top/2019/01/09/编译原理-笔记/%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91%E8%BF%87%E7%A8%8B%E5%A3%B0%E6%98%8E.png">
<meta property="og:updated_time" content="2019-04-11T08:54:23.801Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="编译原理-笔记">
<meta name="twitter:description" content="编译原理 笔记">
<meta name="twitter:image" content="http://mrsempress.top/2019/01/09/编译原理-笔记/%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BF%BB%E8%AF%91.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://mrsempress.top/2019/01/09/编译原理-笔记/"/>





  <title>编译原理-笔记 | Mrs_empress</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0b0957531a34243a173c768258ed03c4";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <a href="https://mrsempress.github.io/" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#fff; color:#151513; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mrs_empress</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Your bright sun</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-poem">
          <a href="/poem" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />
            
            poem
          </a>
        </li>
      
        
        <li class="menu-item menu-item-resume">
          <a href="http://mrsempress-certificate.oss-cn-beijing.aliyuncs.com/%E9%BB%84%E6%99%A8%E6%99%B0.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            resume
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mrsempress.top/2019/01/09/编译原理-笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mrs_empress">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mrs_empress">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">编译原理-笔记</h1>
        

        <div class="post-meta">
	  
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-09T10:30:13+08:00">
                2019-01-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/软件工程/" itemprop="url" rel="index">
                    <span itemprop="name">软件工程</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/软件工程/编译原理/" itemprop="url" rel="index">
                    <span itemprop="name">编译原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/09/编译原理-笔记/" class="leancloud_visitors" data-flag-title="编译原理-笔记">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>编译原理 笔记</p>
<a id="more"></a>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>面向机器<ul>
<li>机器语言：最基本的计算机语言</li>
<li>汇编语言：用符号表示的指令的集合</li>
</ul>
</li>
<li>面向人类<ul>
<li>通用程序设计语言<ul>
<li>演变：<strong>过程-&gt;模块（抽象数据类型、ADT）-&gt;类</strong></li>
<li>共同特点：声明+操作<ul>
<li>声明：提供所操作对象的性质，生成相应的环境，一般是配置存储空间</li>
<li>操作：确定操作的计算次序【过程头+过程体】，生成可执行的代码序列</li>
</ul>
</li>
</ul>
</li>
<li>数据查询语言</li>
<li>形式化描述语言<code>E:E&#39;+&#39;E|E&#39;*&#39;E|id</code>，核心部分是基于数学基础的产生式，例如：YACC</li>
</ul>
</li>
</ul>
<p>按照范型划分的程序设计语言</p>
<ul>
<li>过程式语言、面向对象语言</li>
<li>函数语言：递归特性，如Lisp</li>
<li>说明性、非算法式语言：浓厚的数学特征，如：LEX/YACC、SQL</li>
<li>脚本式语言：仅是一种安排，没有复杂的逻辑关系，如：shell语言</li>
</ul>
<h3 id="语言之间的翻译"><a href="#语言之间的翻译" class="headerlink" title="语言之间的翻译"></a>语言之间的翻译</h3><p><img src="/2019/01/09/编译原理-笔记/%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BF%BB%E8%AF%91.png" alt=""></p>
<p>汇编语言<code>-&gt;</code>机器语言：汇编（如果是A2到M1这种叫交叉汇编）</p>
<p>程序设计语言<code>-&gt;</code>汇编语言或机器指令：编译（或解释）</p>
<p>高级语言之间：转换（或预编译）</p>
<p>逆向：反汇编、反编译</p>
<h3 id="编译器与解释器"><a href="#编译器与解释器" class="headerlink" title="编译器与解释器"></a>编译器与解释器</h3><p>编译器：<img src="/2019/01/09/编译原理-笔记/%E7%BC%96%E8%AF%91%E5%99%A8.png" alt=""></p>
<p>解释器：</p>
<p><img src="/2019/01/09/编译原理-笔记/%E8%A7%A3%E9%87%8A%E5%99%A8.png" alt=""></p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>编译器：</p>
<ul>
<li>工作效率高（目标程序运行效率高），即时间快，空间省</li>
<li>交互性与动态性差、可移植性差</li>
</ul>
<p><strong>解释器：</strong></p>
<ul>
<li><strong>工作效率低</strong>，即<strong>时间慢</strong>（但是执行时间快，总时间慢）、<strong>空间费</strong></li>
<li><strong>交互性与动态性好</strong>、<strong>可移植性好</strong><ul>
<li>数据对象的类型可以动态改变，并允许用户对源程序进行修改，且提供较好的出错诊断，从而为用户提供了交互式的跟踪调试功能【数据库中的动态查询语句】</li>
<li>解释器也是用某种程序语言编写的，因此，只要对解释器进行重新编译，就可使解释器执行在不同环境中，如Java虚拟机</li>
</ul>
</li>
</ul>
<p>主要区别：</p>
<p>运行目标程序时的控制权在解释器而不在目标程序</p>
<h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p><img src="/2019/01/09/编译原理-笔记/%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png" alt=""></p>
<h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><p>输入是源程序，输出是记号流</p>
<p>根据<strong>词法规则</strong>识别出源程序中的各个<strong>记号</strong>；每个记号代表一个<strong>单词</strong>；<strong>线性</strong></p>
<ul>
<li>关键字/保留字</li>
<li>标识符：即类型名、变量名、过程名、常量名等</li>
<li>字面量<ul>
<li>数字字面量</li>
<li>字符串字面量</li>
</ul>
</li>
<li>特殊符号<ul>
<li>运算符</li>
<li>分隔符，<code>&quot;</code>, <code>&#39;</code></li>
</ul>
</li>
</ul>
<h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><p>输入是词法器返回的记号流，输出语法树</p>
<p>根据<strong>语法规则</strong>识别出记号流中的<strong>结构</strong>，并构造出一颗能够正确反映该结构的语法树（一般采用二叉树）</p>
<h4 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h4><p>根据语法分析器构造的语法树，进行适当的语义处理</p>
<p>例如：类型检查和转换等，其目的在于保证语法正确的结构在语义上也是合法的</p>
<p><strong>声明性语句：</strong>将相应的环境信息记录在符号表中</p>
<p><strong>操作性语句：</strong>提供符号表中的信息判断各操作数是否合法</p>
<h4 id="中间代码生成（可选）"><a href="#中间代码生成（可选）" class="headerlink" title="中间代码生成（可选）"></a>中间代码生成（可选）</h4><p>对语法树进行遍历，并生成可以顺序执行的中间代码序列</p>
<p>最常用的形式是四元式<code>(序号)(op操作符/算符, arg1左操作数, arg2右操作数, result结果)</code>，也是三地址码</p>
<p>操作数：算子</p>
<p>在此之前，解释器和编译器仍然是相同的</p>
<h4 id="中间代码优化（可选）"><a href="#中间代码优化（可选）" class="headerlink" title="中间代码优化（可选）"></a>中间代码优化（可选）</h4><p>局部优化、循环优化、全局优化等；</p>
<p>等价变换：变换前后的指令序列完成同样的功能，但在占用的空间上和程序执行的时间上都更省、更有效</p>
<h4 id="目标代码生成"><a href="#目标代码生成" class="headerlink" title="目标代码生成"></a>目标代码生成</h4><p>不同形式：汇编语言形式（还需要再进行一次汇编）、可重定位二进制代码形式【相对寻址】、内存形式（Load-and-Go，编译后马上运行，运行一次就需要编译一次）;</p>
<h4 id="符号表管理"><a href="#符号表管理" class="headerlink" title="符号表管理"></a>符号表管理</h4><p>甚至要保留到程序的运行阶段</p>
<h4 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h4><p>动态错误：逻辑错误/动态语义错误，如除以0，数组下标越界等</p>
<p>静态错误：又分为语法错误和静态语义错误</p>
<p>​            语法错误：语言结构上的错误，如单词拼错、缺少操作数，begin和end不匹配等</p>
<p>​            静态语义错误：语言意义上的错误，如前后类型不一致，参数不匹配</p>
<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>前端：语言结构和意义的<strong>分析</strong>，输出与机器无关</p>
<p>后端：<strong>综合</strong>；语言意义处理</p>
<p>中间代码：前端与后端的分界</p>
<p>划分有利于编译器的开发、维护与移植</p>
<h3 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h3><p><strong>每个阶段</strong>将程序<strong>完整</strong>分析<strong>一遍</strong>的工作模式称为<strong>一遍扫描</strong></p>
<p>原理上希望扫描的遍数越少越好，则需要</p>
<ul>
<li>编译器具有足够大的空间</li>
<li>语言的设计上和编译技术上提供支持</li>
</ul>
<h1 id="词法分析-1"><a href="#词法分析-1" class="headerlink" title="词法分析"></a>词法分析</h1><p>编译器中唯一与源程序打交道的部分；<strong>规定</strong>所有合法输入+<strong>识别</strong>合法输入</p>
<p><strong>任务：</strong></p>
<ol>
<li><strong>滤掉</strong>源程序中的<strong>无用成分</strong>，如注释、空格、回车等</li>
<li>处理与<strong>具体平台</strong>有关的输入，如文件结束符的不同表示等</li>
<li>根据模式<strong>识别记号</strong>，并交给语法分析器【主要任务】</li>
<li>调用<strong>符号表管理器</strong>或<strong>出错处理器</strong>，进行相关处理</li>
</ol>
<p><strong>工作方式：</strong></p>
<ol>
<li><strong>单独一遍扫描</strong>，<strong>输出记号流</strong></li>
<li>作为语法分析器的<strong>子程序</strong>，通过词法分析器的<strong>调用</strong>，然后<strong>返回</strong>记号</li>
<li>与语法分析器<strong>并行工作</strong>的模式，以生产/消费的形式并行工作，通过<strong>队列</strong>存放已生产的“记号”</li>
</ol>
<h3 id="词法"><a href="#词法" class="headerlink" title="词法"></a>词法</h3><p>词法的双重含义：</p>
<ul>
<li>规定单词形成的规则，也被称为构词规则或词法规则<ul>
<li>作用相当于<strong>立法</strong>，规定什么样的输入序列是语言所允许的合法单词</li>
</ul>
</li>
<li>根据构词规则识别输入序列，也被称为词法序列<ul>
<li>作用相当于<strong>执法</strong>，根据规则识别出合法的单词和指出非法的输入序列</li>
</ul>
</li>
</ul>
<p>模式pattern：产生和识别元素的<strong>规则</strong></p>
<p>记号token：按照某个模式（或规则）识别出的<strong>元素（一组）</strong>，包含记号的类别和记号的值</p>
<p>单词lexeme：被识别出的<strong>元素自身的值（一个）</strong>，也称为词值</p>
<p>字典：预先定义且内容不变的记号表</p>
<h4 id="基本分类"><a href="#基本分类" class="headerlink" title="基本分类"></a>基本分类</h4><ul>
<li>关键字/保留字kw(key word/reserved word)</li>
<li>标识符id(identifier)</li>
<li>字面量literal<ul>
<li>常数字面量<ul>
<li>整型、实型、枚举</li>
</ul>
</li>
<li>字符串字面量</li>
</ul>
</li>
<li>特殊符号ks(key symbol/special symbol)<ul>
<li>运算符</li>
<li>分隔符，例如<code>&quot;</code>，<code>&#39;</code></li>
</ul>
</li>
</ul>
<h3 id="模式的形式化描述"><a href="#模式的形式化描述" class="headerlink" title="模式的形式化描述"></a>模式的形式化描述</h3><blockquote>
<p>语言L是<strong>有限</strong>字母表∑上<strong>有限</strong>长度字符串的集合     </p>
</blockquote>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>基本概念：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>表示/术语</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\</td>
<td>S\</td>
<td>$</td>
<td>字符串的长度</td>
</tr>
<tr>
<td>$ε$</td>
<td>$\</td>
<td>ε\</td>
<td>=0$</td>
</tr>
<tr>
<td>S1S2</td>
<td>字符串的连接</td>
</tr>
<tr>
<td>$S^n$</td>
<td>连续n个S的连接</td>
</tr>
<tr>
<td>S的前缀X</td>
<td>“abc”的前缀可以是：$ε, a, ab, abc$</td>
</tr>
<tr>
<td>S的后缀X</td>
<td>“abc”的后缀可以是：$ε, c, bc, abc$</td>
</tr>
<tr>
<td>S的子串X</td>
<td>“abc”的子串可以是：$ε, a, b, c, …$</td>
</tr>
<tr>
<td>S的真前缀</td>
<td>X是S的前缀，并且具有性质：$X!=S\ and\ \</td>
<td>X\</td>
<td>&gt;0$</td>
</tr>
<tr>
<td>S的真后缀</td>
<td>X是S的后缀，并且具有性质：$X!=S\ and\ \</td>
<td>X\</td>
<td>&gt;0$</td>
</tr>
<tr>
<td>S的真子串</td>
<td>X是S的真子串，并且具有性质：$X!=S\ and\ \</td>
<td>X\</td>
<td>&gt;0$</td>
</tr>
<tr>
<td>S的子序列X</td>
<td>S中去掉0或若干个不一定连续的字符后形成的字符串</td>
</tr>
</tbody>
</table>
</div>
<p>集合操作：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>表示、术语</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\phi$</td>
<td>空集合，即元素个数为0的集合</td>
</tr>
<tr>
<td>$\{ε\}$</td>
<td>空串作为唯一元素的集合</td>
</tr>
<tr>
<td>$X=L∪M$</td>
<td>X是集合L和M的并:   $X={s\</td>
<td>s∈L or s∈M }$</td>
</tr>
<tr>
<td>$X=L∩M$</td>
<td>X是集合L和M的交:   $X={s\</td>
<td>s∈L and s∈M}$</td>
</tr>
<tr>
<td>$X=LM$</td>
<td>X是集合L和M的<strong>连接</strong>: $X={st\</td>
<td>s∈L and t∈M}$</td>
</tr>
<tr>
<td>$X=L-M$</td>
<td>X是集合L和M的差:  $X={s\</td>
<td>s∈L and s not∈ M}$</td>
</tr>
<tr>
<td>$X=L^*$</td>
<td>X是集合L和M的(星)闭包: $X=L^0∪L^1∪L^2∪…$，其中$L^0=\{ε\}​$</td>
</tr>
<tr>
<td>$X=L^+$</td>
<td>X是集合L和M的正闭包:  $X=L^1∪L^2∪L^3∪…$</td>
</tr>
</tbody>
</table>
</div>
<h4 id="正规式"><a href="#正规式" class="headerlink" title="正规式"></a>正规式</h4><p>$记号=正规式$，读作：记号定义为正规式或者记号是正规式</p>
<blockquote>
<p>令Σ是一个有限字母表，则Σ上的正规式及其表示的集合递归定义如下:</p>
<ol>
<li>ε是正规式，它表示集合$L(ε)={ε}$</li>
<li></li>
<li></li>
<li>若a是Σ上的字符，则a是正规式，它表示集合L(a)=${a}$</li>
<li>若正规式r和s分别表示集合L(r)和L(s)，则</li>
</ol>
<p>（a） $r|s$是正规式，表示集合$L(r)∪L(s)$</p>
<p>（b） $rs$是正规式，表示集合$L(r)L(s)$</p>
<p>（c） $r^<em>$是正规式，表示集合$(L(r))^</em>$，</p>
<p>（d）$(r)$是正规式，表示的集合仍然是$L(r)$【加括弧改变优先级、结合性】</p>
<p>可用正规式描述的语言称为正规语言或正规集</p>
</blockquote>
<p><strong>优先级：</strong>（从高到低顺序排列为）闭包运算、连接运算、或运算</p>
<p><strong>结合性：</strong>三种运算均具有左结合性质</p>
<p>正规集是一个集合，而正规式是表示正规集的一种方法</p>
<p>不同正规式也可以表示同一个正规集，即正规式与正规集之间是<strong>多对一的关系</strong></p>
<blockquote>
<p>若正规式P和Q表示了同一个正规集，则称P和Q是等价的，记为P=Q</p>
</blockquote>
<p><strong>代数性质：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$r</th>
<th>s=s</th>
<th>r$</th>
<th>$(rs)t=r(st)$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$r</td>
<td>(s</td>
<td>t)=(r</td>
<td>s)</td>
<td>t$</td>
<td>$εr=rε=r$</td>
</tr>
<tr>
<td>$r(s</td>
<td>t)=rs</td>
<td>rt$</td>
<td>$r^*=(r^+</td>
<td>ε)$</td>
</tr>
<tr>
<td>$(s</td>
<td>t)r=sr</td>
<td>tr$</td>
<td>$r^{<em>*}=r^</em>$</td>
</tr>
</tbody>
</table>
</div>
<p>其它：</p>
<ul>
<li>可缺省，$r?=r|ε​$，因为ε不可以用键盘直接键入，？与*具有相同的运算优先级</li>
<li>字符组[r]，有两种形式<ul>
<li>枚举，如$[abc]=a|b|c$</li>
<li>分段，如$[0-9a-z]$，注意左边界小于右边界</li>
</ul>
</li>
<li>非字符组$[$^$r]=\sum-L(r)$</li>
<li>串，”r”，用来避免与正规式中运算符的冲突</li>
<li>辅助定义式：名字=正规式，是为复杂的或重复出现的正规式命名，并在以后的使用中用名字代替正规式</li>
</ul>
<blockquote>
<p>char                 = [a-zA-Z]</p>
<p>digit                =[0-9]<br>digits                =$digit^+$</p>
<p>optional_fraction        =(.digits)?</p>
<p>optional_exponent    =(E(+|-)?digits)?</p>
<p>id                    =char(char|digit)*</p>
<p>num                =digits optional_fraction optional_exponent</p>
</blockquote>
<h3 id="有限自动机"><a href="#有限自动机" class="headerlink" title="有限自动机"></a>有限自动机</h3><p>所谓有限，是指自动机的<strong>状态数</strong>是<strong>有限的</strong></p>
<h4 id="NFA"><a href="#NFA" class="headerlink" title="NFA"></a>NFA</h4><p>NFA: Nondeterministic Finite Automaton不确定的有限自动机</p>
<blockquote>
<p>NFA是一个五元组（5-tuple）：<br>        M =（S，∑，move，$s_0$，F），其中<br>（1） S是有限个<strong>状态</strong>（state）的集合；<br>（2） ∑是有限个<strong>输入字符</strong>（<strong>包括ε</strong>）的集合；<br>（3） move是一个<strong>状态转移函数</strong>，move($s_i$，ch)=$s_j$表示，当前状态$s_i$下若遇到输入字符ch，则转移到状态$s_j$；<br>（4）$s_0$是<strong>唯一的初态</strong>（也称开始状态）；<br>（5） F是<strong>终态集</strong>（也称接受状态集），<strong>它是S的子集</strong>，包含了所有的终态    </p>
</blockquote>
<h5 id="表示方式"><a href="#表示方式" class="headerlink" title="表示方式"></a>表示方式</h5><h6 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h6><p>用一个有向图来直观表示NFA</p>
<ul>
<li>NFA中的每个<strong>状态</strong>，对应转换图中的一个<strong>节点</strong></li>
<li>NFA中的每个<code>move(si, a)=sj</code>，对应转换图中的一条<strong>有向边</strong></li>
<li>需满足<strong>最长匹配原则</strong></li>
</ul>
<p>初态：除去环后没有前驱的节点</p>
<h6 id="状态转换矩阵"><a href="#状态转换矩阵" class="headerlink" title="状态转换矩阵"></a>状态转换矩阵</h6><p>用一个矩阵来直观表示NFA</p>
<p>矩阵中，<strong>状态</strong>对应<strong>行</strong>，<strong>字符</strong>对应<strong>列</strong></p>
<p>一般矩阵第一行所对应的状态为初态，而终态需要特别指出</p>
<h5 id="识别记号的特点"><a href="#识别记号的特点" class="headerlink" title="识别记号的特点"></a>识别记号的特点</h5><p>具有<strong>不确定性</strong>，即在当前状态下对同一字符有多于一个的下一状态转移</p>
<p><strong>具体体现：</strong></p>
<ul>
<li>（定义）move函数是1对多的</li>
<li>（状态转移图）同一状态有多于一条边标记相同字符转移到不同的状态</li>
<li>（状态转移矩阵）M[si, a]是一个状态的集合</li>
</ul>
<h5 id="方法与问题"><a href="#方法与问题" class="headerlink" title="方法与问题"></a>方法与问题</h5><p>方法：反复<strong>试探所有</strong>路径，直到到达终态，或者到达不了终态</p>
<p>问题：</p>
<ol>
<li><strong>只有尝试了全部可能的路径，才能确定</strong>一个输入序列不被接受，而这些路径的条数随着路径长度的增长成指数增长</li>
<li>识别过程中需要大量<strong>回溯</strong>，时间复杂度升高且算法趋于复杂</li>
</ol>
<h4 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h4><p>DFA: Deterministic Finite Automaton确定的有限自动机</p>
<blockquote>
<p><strong><em>DFA是NFA的一个特例，其中：</em></strong><br>（1）<strong>没有状态</strong>具有<strong>ε状态转移</strong>(ε_transition)，即状态转换图中没有标记ε的边；<br>（2）对每个状态s和每个<strong>字符</strong>a，<strong>最多</strong>有<strong>一个</strong>下一状态。</p>
</blockquote>
<h5 id="识别记号的特点-1"><a href="#识别记号的特点-1" class="headerlink" title="识别记号的特点"></a>识别记号的特点</h5><p>具有<strong>确定性</strong>，即在当前状态下对同一字符最多只有一个的下一状态转移</p>
<p><strong>具体体现：</strong></p>
<ul>
<li>（定义）move函数是1对<strong>1</strong>的</li>
<li>（状态转移图）从一个节点出发的边上标记<strong>均不相同</strong></li>
<li>（状态转移矩阵）M[si, a]是<strong>一个状态</strong></li>
<li>且字母表不包括$\varepsilon$</li>
</ul>
<blockquote>
<p>将在DFA上识别输入序列的过程形式化为算法，该算法被称为模拟器（模拟DFA的行为）或驱动器（用DFA的数据驱动分析动作）;<br>算法与DFA一起，即构成识别记号的词法分析器的核心。它的最大特点是算法与模式无关，仅DFA与模式相关。</p>
</blockquote>
<h5 id="有限自动机的等价"><a href="#有限自动机的等价" class="headerlink" title="有限自动机的等价"></a>有限自动机的等价</h5><blockquote>
<p>若有限自动机M和M’识别同一正规集，则称M和M’是等价的，记为M=M’。</p>
</blockquote>
<p>模拟DFA</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">s:=s0； ch:=nextchar； 	 -- 初值</div><div class="line">while  ch≠eof		 -- 循环</div><div class="line">	loop s:=move(s,ch);  </div><div class="line">	ch:=nextchar;</div><div class="line">end loop;</div><div class="line">if s is in F then return “yes”;	 -- 返回</div><div class="line">else return “no”;</div><div class="line">end if;</div></pre></td></tr></table></figure>
<h4 id="NFA与DFA"><a href="#NFA与DFA" class="headerlink" title="NFA与DFA"></a>NFA与DFA</h4><p>NFA：与正规式有对应关系，易于构造，状态数少</p>
<p>DFA：确定性便于记号识别，不易构造，状态数可能多</p>
<p><strong>对于任何一个NFA，均可以找到一个与它等价的DFA</strong></p>
<h4 id="词法分析器的构造"><a href="#词法分析器的构造" class="headerlink" title="*词法分析器的构造"></a>*词法分析器的构造</h4><h5 id="方法和步骤"><a href="#方法和步骤" class="headerlink" title="方法和步骤"></a>方法和步骤</h5><p><code>正规式－NFA－DFA－最小化DFA－词法分析器</code></p>
<ol>
<li>用正规式描述模式（为记号设计正规式）</li>
<li>为每个正规式构造一个NFA，它识别正规式所表示的正规集</li>
<li>将构造的NFA转换成等价的DFA，这一过程也被称为<strong>确定化</strong></li>
<li>优化DFA，使其状态数最少，这一过程也被称为<strong>最小化</strong></li>
<li>根据优化后的DFA构造词法分析器</li>
</ol>
<p>由正规式构造NFA而不是DFA的原因是正规式到NFA有<strong>规范的一对一的构造算法</strong></p>
<p>由DFA而不是由NFA构造词法分析器的原因是DFA识别记号的方法<strong>优于</strong>NFA识别记号的方法</p>
<p>词法分析器返回的完整记号包括<strong>属性和类别</strong></p>
<h5 id="从正规式到NFA"><a href="#从正规式到NFA" class="headerlink" title="从正规式到NFA"></a>从正规式到NFA</h5><p>首先有个箭头然后一个0，同时注意<code>*</code>，所存在经过ε的边</p>
<h6 id="Thompson算法"><a href="#Thompson算法" class="headerlink" title="Thompson算法"></a>Thompson算法</h6><p>输入：字母表∑上的正规式r<br>输出：接受L(r)的NFA N<br>方法：首先分解r，然后根据下述步骤构造NFA：</p>
<p><em>然后看Thompson算法中，对于第三种，(a)分类的时候会有两个分开的ε，然后合上的ε，(c)星闭包的时候，起始和中间，中间和最后，起始和最后，中间和中间都有ε；(b)的意思是，P的终态和Q的初态进行合并</em></p>
<p><img src="/2019/01/09/编译原理-笔记/Thompson%E7%AE%97%E6%B3%95.png" alt=""></p>
<h5 id="从NFA到DFA"><a href="#从NFA到DFA" class="headerlink" title="从NFA到DFA"></a>从NFA到DFA</h5><p>注意从这里开始都是<code>smove</code>，因为算的都是集合<code>(set)</code>的了</p>
<h6 id="“并行”模拟NFA"><a href="#“并行”模拟NFA" class="headerlink" title="“并行”模拟NFA"></a>“并行”模拟NFA</h6><p> <1> 消除<strong>ε 状态</strong>转移：$ε_闭包(T)$<br> <2> 消除<strong>多于一个的下一状态</strong>转移：smove(S, a)</2></1></p>
<p>用状态集代替状态</p>
<blockquote>
<p>状态集T的ε_闭包(T)是一个状态集，且满足：<br>（1） T中所有状态属于ε_闭包(T)；<br>（2） 任何smove(ε_闭包(T)，ε)属于ε_闭包(T)；<br>（3） 再无其他状态属于ε_闭包(T)。</p>
</blockquote>
<p>求ε_闭包</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> ε_闭包<span class="params">(T)</span> <span class="title">is</span></span></div><div class="line"><span class="function"><span class="title">begin</span></span></div><div class="line"><span class="function">  <span class="title">for</span> <span class="title">T</span>中每个状态<span class="title">t</span> </span></div><div class="line"><span class="function">  	<span class="title">loop</span> 加入<span class="title">t</span>到<span class="title">U</span>;</span> push(t);</div><div class="line">  <span class="keyword">end</span> loop;</div><div class="line">  <span class="keyword">while</span>  栈不空</div><div class="line">  	loop pop(t); </div><div class="line">    	<span class="keyword">for</span> 每个u=move(t, ε)</div><div class="line">    	loop </div><div class="line">    		<span class="keyword">if</span> u不在U中 <span class="keyword">then</span> 加入u到U; push(u); <span class="keyword">end</span> <span class="keyword">if</span>; </div><div class="line">  		<span class="keyword">end</span> loop;</div><div class="line">  	<span class="keyword">end</span> loop; </div><div class="line">  return U;</div><div class="line"><span class="keyword">end</span> ε_闭包;</div></pre></td></tr></table></figure>
<p>模拟NFA</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">S := ε_闭包(<span class="comment">&#123;s0&#125;</span>);         -- 所有可能初态的集合</div><div class="line">ch := nextchar;</div><div class="line"><span class="keyword">while</span>  ch ≠ eof loop </div><div class="line">	 S:= ε_闭包(smove(S，ch))； </div><div class="line">	 ch:= nextchar;</div><div class="line"><span class="keyword">end</span> loop;</div><div class="line"><span class="keyword">if</span>  S∩F≠Φ <span class="keyword">then</span> return “yes”;  </div><div class="line"><span class="keyword">else</span> return “no”; </div><div class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</div></pre></td></tr></table></figure>
<p>缺点：每次<strong>动态计算</strong>下一状态转移集合，效率低</p>
<h6 id="“子集法”构造DFA"><a href="#“子集法”构造DFA" class="headerlink" title="“子集法”构造DFA"></a>“子集法”构造DFA</h6><p>将NFA的下一状态<strong>集合合并</strong>为一个状态</p>
<p>与模拟DFA相比，记录了所有状态与状态转移</p>
<p>但是在最坏的情况下，等价的DFA的状态数可能是$o(2^n)$级的，需要很大的存储空间，这时候往往采用模拟NFA</p>
<p><em>我的感觉就是模拟DFA是像解释器一样的，每一个序列都要按NFA走一次，重新计算集合；而子集法就是像编译器一样的，首先把所有情况都考虑到，只需要将序列根据新生成的状态生成图走一遍，看是否到了终态即可</em></p>
<p><em>首先要写个$ε_闭包({0})$，同时记为A，然后再算，每一个出现的都要对每个字符再算，每一个的格式是$ε_闭包(smove(A,a))$</em></p>
<p>子集法</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ε_闭包(<span class="comment">&#123;s0&#125;</span>)是Dstates仅有的状态，且尚未标记;</div><div class="line"><span class="keyword">while</span> Dstates有尚未标记的状态T </div><div class="line">loop  标记T;</div><div class="line">      <span class="keyword">for</span>  每一个字符a   -- T中向外转移边的标记</div><div class="line">      loop	U := ε_闭包(smove(T，a));</div><div class="line">        <span class="keyword">if</span> U非空 </div><div class="line">        <span class="keyword">then</span> Dtran[T，a] := U; 	--Dtran是一个状态转换矩阵</div><div class="line">             <span class="keyword">if</span>   U不在Dstates中 </div><div class="line">             <span class="keyword">then</span> U作为尚未标记的状态加入Dstates;</div><div class="line">             <span class="keyword">end</span> <span class="keyword">if</span>;</div><div class="line">        <span class="keyword">end</span> <span class="keyword">if</span>;</div><div class="line">      <span class="keyword">end</span> loop;</div><div class="line"><span class="keyword">end</span> loop;</div></pre></td></tr></table></figure>
<p>优点：</p>
<ol>
<li>消除了不确定性</li>
<li>无需动态计算状态集合（针对模拟NFA的算法）</li>
</ol>
<blockquote>
<p>对于任何两个状态t和s，若从一状态出发接受输入字符串ω，而从另一状态出发不接受ω，或者从t出发和从s出发到达不同的接受状态，则称ω对状态t和s是可区分的</p>
</blockquote>
<p>若任何输入序列$ω$对s和t均是不可区分的，则说明从s出发和从t出发，分析任何输入序列$ω$均得到相同结果；因此，s和t可以合并成一个状态</p>
<h6 id="最小化DFA"><a href="#最小化DFA" class="headerlink" title="最小化DFA"></a>最小化DFA</h6><p>将一个DFA<strong>等价变换</strong>为另一个状态数<strong>最少</strong>的DFA的过程被称为最小化DFA，相应的DFA称为最小DFA</p>
<p><em>首先可以通过划分组，看是否是最简的</em></p>
<ol>
<li>初始划分：终态与非终态</li>
<li>利用可区分的概念，反复分裂划分中的组Gi，直到不可再分裂<br>如果某一个组经过一个字符串达到的<strong>组</strong>和其它的都不一样，则它可以分割出来</li>
<li>由最终划分构造D’，关键是选代表和修改状态转移</li>
<li>消除可能的<strong>死状态</strong>（不是终态，且所有输入的字符均转向其自身）和（从初态）<strong>不可（到）达（的）状态</strong></li>
</ol>
<h5 id="由DFA构造词法分析器"><a href="#由DFA构造词法分析器" class="headerlink" title="由DFA构造词法分析器"></a><strong>由DFA构造词法分析器</strong></h5><p>需满足最长匹配原则</p>
<h6 id="表驱动型的词法分析器"><a href="#表驱动型的词法分析器" class="headerlink" title="表驱动型的词法分析器"></a>表驱动型的词法分析器</h6><p>数据与操作分离的工作模式</p>
<p><strong>转换矩阵</strong>是分析器的分析表，模拟DFA算法是分析器的驱动器</p>
<p>DFA是被动的，需要一个驱动器（如LEX）来模拟DFA的行为，以实现对输入序列的分析</p>
<h6 id="直接编码的词法分析器"><a href="#直接编码的词法分析器" class="headerlink" title="直接编码的词法分析器"></a>直接编码的词法分析器</h6><p>将DFA和DFA识别输入序列的过程合并在一起，直接用程序代码<strong>模拟DFA识别输入序列的过程</strong></p>
<p>适合<strong>转换图</strong>，适合词法比较简单的情况，可以直接根据正规式/转换图进行编码，而无需一步一步按上述方法来</p>
<p>① 初态→程序的开始<br>② 终态→程序的结束（不同终态return不同记号）；<br>③ 状态转移→分情况或者条件语句（case/if）<br>④ 环→循环语句（loop）<br>⑤ return满足<strong>最长匹配原则</strong></p>
<p>同时实际的词法分析器不但接受合法输入，也应指出<strong>非法输入</strong></p>
<h6 id="两者的比较"><a href="#两者的比较" class="headerlink" title="两者的比较"></a>两者的比较</h6><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">表驱动</th>
<th style="text-align:center">直接编码</th>
</tr>
</thead>
<tbody>
<tr>
<td>分析器的速度</td>
<td style="text-align:center">慢</td>
<td style="text-align:center">快</td>
</tr>
<tr>
<td>程序与模式的关系</td>
<td style="text-align:center">无关</td>
<td style="text-align:center"><strong>有关</strong></td>
</tr>
<tr>
<td>分析器的规模</td>
<td style="text-align:center">较大</td>
<td style="text-align:center">较小</td>
</tr>
<tr>
<td>适合的编写方法</td>
<td style="text-align:center">工具生成</td>
<td style="text-align:center">手工编写</td>
</tr>
</tbody>
</table>
</div>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol>
<li><p>识别abb和abab，同时构造$(a|b)^*abb$的DFA，并且简化DFA，最后设计“直接编码的词法分析器”</p>
<p>用Thompson算法构造正规式r=(a|b)*abb的NFA N(r) </p>
<p>首先分解正规式，然后自下而上构造NFA</p>
<p><img src="/2019/01/09/编译原理-笔记/Thompson%E7%AE%97%E6%B3%95.png" alt=""></p>
<p>然后如果用模拟NFA法的话</p>
<p>每次根据输入序列，确定下一个状态</p>
<p><img src="/2019/01/09/编译原理-笔记/%E6%A8%A1%E6%8B%9FNFA.png" alt=""></p>
<p>如果用子集法的话</p>
<p><img src="/2019/01/09/编译原理-笔记/%E5%AD%90%E9%9B%86%E6%B3%95%E6%9E%84%E9%80%A0DFA.png" alt=""></p>
<p>简化DFA</p>
<p><img src="/2019/01/09/编译原理-笔记/%E5%8C%96%E7%AE%80DFA.png" alt=""><br>可以看到ABCD通过b得到的分别是CDCE，而唯有E不在ABCD组，所以只可以划分出D</p>
<p>直接编码的词法分析器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123; 	<span class="keyword">char</span> buf[]=<span class="string">"abba#"</span>, *ptr=buf;</div><div class="line">  <span class="keyword">while</span> (*ptr!=<span class="string">'#'</span> )&#123;</div><div class="line">l0: <span class="keyword">while</span> (*ptr==<span class="string">'b'</span>) ptr++;			<span class="comment">// state 0</span></div><div class="line">    <span class="keyword">switch</span>(*ptr)</div><div class="line">    &#123; <span class="keyword">case</span> <span class="string">'a'</span>: ptr++; </div><div class="line">l1:             <span class="keyword">while</span> (*ptr==<span class="string">'a'</span>) ptr++;	<span class="comment">// state 1</span></div><div class="line">                <span class="keyword">switch</span> (*ptr)</div><div class="line">                &#123; <span class="keyword">case</span> <span class="string">'b'</span>: ptr++;</div><div class="line">	                     <span class="keyword">switch</span> (*ptr)	<span class="comment">// state 2</span></div><div class="line">		              &#123; <span class="keyword">case</span> <span class="string">'a'</span>: ptr++; <span class="keyword">goto</span> l1;</div><div class="line">		                <span class="keyword">case</span> <span class="string">'b'</span>: ptr++;</div><div class="line">			                   <span class="keyword">switch</span> (*ptr)	<span class="comment">// state3</span></div><div class="line">				            &#123; <span class="keyword">case</span> <span class="string">'a'</span>: ptr++; <span class="keyword">goto</span> l1;</div><div class="line">				              <span class="keyword">case</span> <span class="string">'b'</span>: ptr++; <span class="keyword">goto</span> l0;</div><div class="line">				              <span class="keyword">case</span> <span class="string">'#'</span>: <span class="built_in">cout</span>&lt;&lt;<span class="string">"yes\n"</span>;</div><div class="line">				 	                 <span class="keyword">return</span>;</div><div class="line">				              <span class="keyword">default</span>:  <span class="keyword">goto</span> le;						     &#125;</div><div class="line">		                <span class="keyword">default</span>: <span class="keyword">goto</span> le;</div><div class="line">		              &#125;</div><div class="line">                  <span class="keyword">default</span>: <span class="keyword">goto</span> le;</div><div class="line">                &#125;</div><div class="line">       <span class="keyword">default</span>: <span class="keyword">goto</span> le;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">le: <span class="built_in">cout</span> &lt;&lt; <span class="string">"no\n"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125; <span class="comment">// 看实例运行</span></div></pre></td></tr></table></figure>
</li>
<li><p>写出每个a后必跟b的<strong>ab串</strong></p>
<p>$(b|(ab)^<em>)^</em>$</p>
</li>
<li><p>不含011的01串</p>
<p>$1^<em>(01|0)^</em>$</p>
</li>
</ol>
<h1 id="语法分析-1"><a href="#语法分析-1" class="headerlink" title="语法分析"></a>语法分析</h1><p>词法分析：字母是元素，组成字符串，记号的集合，线性结构，以字符流为输入<br>语法分析：记号是元素，组成句子， 句子的集合，<strong>树结构</strong>，以记号流为输入</p>
<p>语法的双重含意：</p>
<ol>
<li>语法<strong>规则</strong>：上下文无关文法（子集－LL文法或LR文法）</li>
<li>语法<strong>分析</strong>：下推自动机（LL或LR分析器），<strong>自上而下</strong>和<strong>自下而上分析</strong> （这两种都只能处理上下文无关文法的子类）</li>
</ol>
<h2 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h2><p>语法分析器是编译器前端的重要组成部分，中心部件</p>
<p>语法分析器的两个重要作用：</p>
<ol>
<li>根据词法分析器提供的记号流，为语法正确的输入<strong>构造分析树（或语法树）</strong></li>
<li><strong>检查</strong>输入中的<strong>语法（可能包括词法）错误</strong>，并调用出错处理器进行<strong>适当处理</strong></li>
</ol>
<h3 id="语法错误的处理原则"><a href="#语法错误的处理原则" class="headerlink" title="语法错误的处理原则"></a>语法错误的处理原则</h3><p>源程序中可能出现的错误：</p>
<ul>
<li>语法（包括词法）错误<ul>
<li><strong>词法错误</strong>如<strong>非法字符</strong>或<strong>拼写错关键字、标识符</strong>等</li>
<li><strong>语法错误</strong>是指<strong>语法结构出错</strong>，如少分号、begin/end不配对等</li>
</ul>
</li>
<li>语义错误<ul>
<li><strong>静态语义错误</strong>（涉及的是<strong>编译时</strong>可检查出来的错误）：如类型不一致、参数不匹配等</li>
<li><strong>动态语义错误</strong>（程序<strong>运行时的</strong>逻辑错误）：如死循环、变量为零时作除数等</li>
</ul>
</li>
</ul>
<p>目标：</p>
<ul>
<li>清楚而准确地<strong>报告错误的出现</strong>（地点正确，不漏报、不错报也不多报</li>
<li>迅速从每个错误中<strong>恢复</strong>过来（以便分析继续进行）</li>
<li>不应对语法正确源程序的<strong>分析速度</strong>降低太多</li>
</ul>
<p>基本恢复策略</p>
<ol>
<li>紧急方式恢复：<strong>抛弃若干输入</strong>，直到遇到某个指定的合法记号（称为同步记号）集合为止同步记号一般是定界符，如分号或end等【最简单，但最容易造成错报、漏报和多报语法错误的现象】</li>
<li>短语级恢复：采用<strong>串替换</strong>的方式对剩余输入进行<strong>局部纠正</strong>（抛弃+插入）</li>
<li>出错产生式：用<strong>出错产生式</strong>捕捉错误（<strong>预测错误</strong>），<strong>预置型的短语级恢复方式</strong>（YACC采用的方式）</li>
<li>全局纠正：对错误输入序列x，找相近序列y，使得x变换成y<strong>所需的修改、插入、删除次数最少</strong>【代价太大】</li>
</ol>
<h2 id="上下文无关文法CFG"><a href="#上下文无关文法CFG" class="headerlink" title="上下文无关文法CFG"></a>上下文无关文法CFG</h2><p>CFG：Context Free Grammar</p>
<blockquote>
<p>CFG是一个四元组G =（N，T，P，S），其中<br>（1） N是<strong>非终结符</strong>（Nonterminals）的<strong>有限集合</strong>；<br>（2） T是<strong>终结符</strong>（Terminals）的有限集合，且N∩T=Φ；<br>（3） P是<strong>产生式</strong>（Productions）的有限集合，<br>     A→α，其中<strong>A∈N（左部）</strong>，α∈(N∪T)<em>（右部），<br>     若α=ε，则称A→ε为空产生式（也可以记为A →）；<br>（4） S是非终结符，称为文法的<em>*开始符号</em></em>（Start symbol）</p>
</blockquote>
<p>可以将产生式中的记号→读作<strong>“定义为”</strong>或者<strong>“可导出”</strong>，如：“E → E + E”可用自然语言表述为“算术表达式定义为两个算术表达式相加”， 或者“一个算术表达式加上另一个算术表达式，仍然是一个算术表达式”</p>
<p>文法开始符号S是第一个产生式的左部；N是可以出现在产生式左边符号的集合；<strong>T</strong>是<strong>绝不出现</strong>在<strong>产生式左边符号的集合（记号）</strong>【所以T不一定是一个句子的那种终结符，也可以是一个短语的终结符，如+、-、(、)等等</p>
<p><strong>CFG的产生式</strong>表示也被称为<strong>巴克斯范式BNF</strong>，规范的BNF中，<code>-&gt;</code>用<code>::=</code>来表示</p>
<p>约定：<strong>大写</strong>英文字母A、B、C表示<strong>非终结符</strong>；<strong>小写</strong>英文字母a、b、c表示<strong>终结符</strong>；小写<strong>希腊</strong>字母α、β、δ表示<strong>任意文法符号序列</strong></p>
<p>产生式中，用“|”连接的每个<strong>右部</strong>称为一个<strong>候选项</strong>，具有<strong>平等</strong>的权利</p>
<h3 id="CFG产生语言的基本方法——推导"><a href="#CFG产生语言的基本方法——推导" class="headerlink" title="CFG产生语言的基本方法——推导"></a>CFG产生语言的基本方法——推导</h3><p>推导：产生式产生语言的过程是<strong>从开始符号S开始，</strong>对产生式<strong>左部的非终结符反复地使用产生式</strong>：将产生式左部的非终结符替换为右部的文法符号序列(展开产生式，用标记=&gt;表示)，直到得到一个<strong>终结符序列</strong></p>
<blockquote>
<p>利用产生式产生句子的过程中，将产生式A→γ的右部<strong>代替</strong>文法符号序列αAβ中的A得到αγβ的过程，称αAβ<strong>直接推导</strong>出αγβ，记作：αAβ=&gt;αγβ</p>
<p>若对于任意文法符号序列α1，α2，…αn，均α1=&gt;α2=&gt;…=&gt;αn，则称此过程为零步或多步推导，记为：$α1=^<em>&gt;αn$，其中α1=αn的情况为<strong>零步推导</strong>；若α1≠αn，即推导过程中至少使用一次产生式，则称此过程为<em>*至少一步推导</em></em>，记为：$α1=^+&gt;αn$ </p>
<p>对于所有α，有$α=^<em>&gt;α$，即推导具有<strong>自反性</strong><br>若$α=^</em>&gt;β$，$β=^<em>&gt;γ$，则$α=^</em>&gt;γ$，即推导具有<strong>传递性</strong></p>
</blockquote>
<h4 id="CFL上下文无关语言"><a href="#CFL上下文无关语言" class="headerlink" title="CFL上下文无关语言"></a>CFL上下文无关语言</h4><blockquote>
<p>由CFG G所产生的语言L(G)被定义为:<br>    $L(G)=\{\omega|S=^+&gt;\omega\ and\ \omega\in T^*\}$    </p>
<p><strong>L(G)</strong>称为<strong>上下文无关语言</strong>(Context Free Language, CFL)，<strong>ω</strong>称为<strong>句子</strong>，若<strong>S=*&gt;α</strong>，<strong>α∈(N∪T)*</strong>，则称α为G的一个<strong>句型</strong></p>
</blockquote>
<p>第一个是文法开始符号，最后一个是句子，其他的都是句型，但广义来说，第一个和最后一个也是句型</p>
<blockquote>
<p>在推导过程中，若每次<strong>直接推导</strong>均替换句型中<strong>最左边的非终结符</strong>，则称为<strong>最左推导</strong>，由最左推导产生的句型被称为<strong>左句型</strong>；</p>
<p>类似的可以定义最右推导与右句型，<strong>最右推导</strong>也被称为<strong>规范推导</strong></p>
</blockquote>
<h4 id="分析树"><a href="#分析树" class="headerlink" title="分析树"></a>分析树</h4><p>分析树是推导的图形表示，直观并且同时反映语言结构的实质和推导过程</p>
<blockquote>
<p>对CFG G的句型，<strong>分析树</strong>被定义为具有下述性质的一棵树。<br> （1） <strong>根</strong>由<strong>开始符号</strong>所标记<br> （2） 每个<strong>叶子</strong>由一个<strong>终结符、非终结符、或ε</strong>标记<br> （3） 每个<strong>内部结点</strong>由一个<strong>非终结符</strong>标记<br> （4） 若A是某内部节点的标记，且X1，X2，…，Xn是该节点从左到右<strong>所有孩子</strong>的标记，则A→X1X2…Xn是一个<strong>产生式</strong>。若A→ε，则标记为A的结点可以仅有一个标记为ε的孩子</p>
</blockquote>
<p>分析树与语言和文法的关系：</p>
<ol>
<li>每一<strong>直接推导</strong>(每个产生式)，对应一棵仅有<strong>父子关系的子树</strong>，即产生式左部非终结符“长出”右部的孩子</li>
<li>分析树的<strong>叶子</strong>，从左到右构成G的一个<strong>句型</strong>；若叶子<strong>仅由终结符标记</strong>，则构成<strong>一个句子</strong></li>
</ol>
<h4 id="语法树"><a href="#语法树" class="headerlink" title="语法树"></a>语法树</h4><p>为了仅关注<strong>句型</strong>，并且<strong>忽略推导</strong>过程，产生了语法树：</p>
<blockquote>
<p>对CFG G的句型，表达式的<strong>语法树</strong>被定义为具有下述性质的一棵树:<br>（1） <strong>根</strong>与<strong>内部节点</strong>由表达式中的<strong>操作符</strong>标记；<br>（2） <strong>叶子</strong>由表达式中的<strong>操作数</strong>标记；<br>（3）用于改变运算优先级和结合性的<strong>括弧</strong>，被<strong>隐含</strong>在语法树的结构中</p>
</blockquote>
<p>分析树和语法树又被称为<strong>具体语法树</strong>和<strong>抽象语法树</strong>AST</p>
<h4 id="二义性与二义性的消除"><a href="#二义性与二义性的消除" class="headerlink" title="二义性与二义性的消除"></a>二义性与二义性的消除</h4><blockquote>
<p>若文法G对同一句子产生<strong>不止一棵分析树</strong>，则称G是<strong>二义的</strong></p>
</blockquote>
<p>产生原因：在产生句子的过程中某些直接推导有<strong>多于一种选择</strong>；文法中<strong>缺少</strong>对文法符号<strong>优先级和结合性</strong>的规定；一个句子有多于一颗分析树，<strong>仅与文法和句子有关，与采用的推导方法无关</strong>（对于某些文法和句型，无论采用最左推导还是最右推导都会有歧义的）</p>
<p>文法二义性不能说明程序设计语言是二义的；程序设计语言不能二义；只有当产生一个语言的所有文法都是二义的时，这个语言才被认为是二义的</p>
<p><strong>二义文法不是CFG</strong></p>
<p>消除文法二义的两种方法：</p>
<ol>
<li>改写二义文法为非二义文法</li>
<li>规定二义文法中符号的优先级和结合性，使仅产生一颗分析树</li>
</ol>
<p>现给出一个二义文法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">E→E+E </div><div class="line"> | E*E</div><div class="line"> |（E） </div><div class="line"> | -E</div><div class="line"> | id</div></pre></td></tr></table></figure>
<h5 id="改写二义文法为非二义文法"><a href="#改写二义文法为非二义文法" class="headerlink" title="改写二义文法为非二义文法"></a>改写二义文法为非二义文法</h5><p>对于上述二义文法进行改写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">E → E + T  | T			</div><div class="line">T → T * F  | F </div><div class="line">F →（E）    | -F | id</div></pre></td></tr></table></figure>
<p><strong>改写二义文法的方法：</strong></p>
<p>通过<strong>引入非终结符</strong>，使原来分辨不清的结构受到约束，从而使得对任何一个句子，仅能构造一颗分析树</p>
<p>一些结论：</p>
<ol>
<li><strong>新引入的非终结符</strong>，限制了每一步直接推导均有<strong>唯一</strong>选择</li>
<li>最终分析树的形状，<strong>仅与文法有关</strong>，而与推导方法无关</li>
<li>非终结符的引入，<strong>增加了推导步骤</strong>（分析树增高），从而分析树效率降低</li>
<li><strong>越接近S的文法符号的优先级越低</strong>（如E→E+T）</li>
<li>对于A→αAβ，若$a\in\beta$（A在a的左边），则a具有<strong>左结合</strong>性质；若$a\in\alpha$（A在a的右边），则a具有右结合性质<strong><em>【如E-&gt;E+T，则+具有左结合性，E-&gt;T+E，则+具有右结合性】</em></strong></li>
</ol>
<p>关键步骤：</p>
<ol>
<li>引入一个<strong>新的非终结符</strong>，<strong>增加</strong>一个<strong>子结构</strong>并<strong>提高</strong>一级<strong>优先级</strong></li>
<li>递归<strong>非终结符</strong>在<strong>终结符左边</strong>，运算具有<strong>左结合性</strong>，否则具有<strong>右结合性</strong></li>
</ol>
<p><em>我的想法是先列出优先级，比如这里我可以说从低到高是[+] [\</em>] [(), -, id]；然后列出结合性：左结合+,*；右结合-；无结合id；因为有三个层次，所以需要再引入两个新变量，首先是优先级最低的，然后是次之，最后是最高的；在每一个产生式中，又要根据结合性，如果是左结合的则右边应该含有终结符的标号，否则相反，就可以写出来了；当然要注意可以不含有+的问题，所以有个|T的存在*</p>
<p>对于“悬空”问题（即else和最近还是最远if匹配）</p>
<p><em>我们来讨论一下，首先这里没有优先级区分，但是结合性应该是右结合，即else与其左边最靠近的then结合，那么只需改写如下：</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">原来的：</div><div class="line">S → if C then S</div><div class="line">   | if C then S else S</div><div class="line">   | id := E     </div><div class="line">C → E=E | E&lt;E | E&gt;E</div><div class="line">E → E+E | -E | id | n</div><div class="line"></div><div class="line">改写之后的（MS是完全匹配的意思，即含有if then else；UMS不完全匹配，即含有if then，至于then中是否嵌套，则看如下表示）：</div><div class="line">S  → MS 			   </div><div class="line">    | UMS			   </div><div class="line">MS → if C then MS else MS  </div><div class="line">    | id := E		   </div><div class="line">UMS→ if C then S		    </div><div class="line">    | if C then MS else UMS  </div><div class="line">C → E=E | E&lt;E | E&gt;E</div><div class="line">E → E + T  | T			</div><div class="line">T →（E）    | -T | id | n</div></pre></td></tr></table></figure>
<p>然后根据一一比对，比如对于<code>if x&lt;3 then if x&gt;0 then x:=5 else x:=-5</code></p>
<p>比如对于和最远的if匹配的话，我们首先将S展开，如果是MS，则展开为第一种，但是MS展不开了（这里应该是<code>if x&gt;0 then x:=5</code>这句话）；如果是UMS，则展开为第二种，但是MS也展不开了，所以这种匹配不可行；而和最近的if匹配的话，是可行的，且唯一确定，首先展开成UMS，S再展开成MS的第一种</p>
<h5 id="规定二义文法中符号的优先级和结合性"><a href="#规定二义文法中符号的优先级和结合性" class="headerlink" title="规定二义文法中符号的优先级和结合性"></a>规定二义文法中符号的优先级和结合性</h5><p>但是二义文法具有如下优点：</p>
<ol>
<li>比非二义文法容易理解</li>
<li>分析效率高，分析树低，直接推导步骤少</li>
</ol>
<p>通过为二义文法规定优先级和结合性（YACC的方法）</p>
<h5 id="修改语言的语法（表现形式被改变）"><a href="#修改语言的语法（表现形式被改变）" class="headerlink" title="修改语言的语法（表现形式被改变）"></a>修改语言的语法（表现形式被改变）</h5><ol>
<li>明确给出结束标志，如<code>end if</code></li>
<li>给表达式加括号</li>
</ol>
<h3 id="正规式与CFG"><a href="#正规式与CFG" class="headerlink" title="正规式与CFG"></a>正规式与CFG</h3><h4 id="正规式到CFG的转换"><a href="#正规式到CFG的转换" class="headerlink" title="正规式到CFG的转换"></a>正规式到CFG的转换</h4><blockquote>
<p>正规式所描述的语言结构均可用CFG描述，反之不一定</p>
</blockquote>
<p><em>识别正规语言的自动机是有限自动机，它们的特征是没有记忆功能</em></p>
<p><em>识别CFL的自动机是下推自动机，在有限自动机的基础上增加了一个下推栈，具有简单的记忆功能</em></p>
<p>从正规式到CFG的对应关系： </p>
<ol>
<li>构造正规式的NFA</li>
<li><strong>若0为初态</strong>，则$A_0$为开始符号</li>
<li>对于move(i,a)=j，引入产生式$A_i$→$aA_j$</li>
<li>对于move(i,ε)=j，引入产生式 $A_i→A_j$</li>
<li><strong>若i是终态</strong>，则引入产生式$A_i →ε$</li>
</ol>
<p>为什么用正规式而不用CFG描述<strong>词法</strong>：</p>
<ol>
<li>词法规则简单，用正规式描述已足够</li>
<li>正规式的表示比CFG更直观、简洁、易于理解</li>
<li>有限自动机的构造比下推自动机简单，且分析效率高</li>
<li>区分词法和语法，为编译器前端的模块划分提供方便</li>
</ol>
<ul>
<li>正规式适合描述<strong>线性结构</strong>，如标识符、关键字、注释等</li>
<li>CFG适合描述<strong>具有嵌套（层次）性质的非线性结构</strong>，如不同结构的句子if-then-else、while-do等</li>
</ul>
<h2 id="上下文有关语言CSL"><a href="#上下文有关语言CSL" class="headerlink" title="上下文有关语言CSL"></a>上下文有关语言CSL</h2><p>变量的声明与引用、过程调用时形参与实参的一致性检查等无法用CFG描述，所以产生了CSL（Context Sensitive Language)</p>
<p>CFG到CSL的文法所表示的意思都变了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">CFG无法表示:</div><div class="line">L1=&#123;ωcω|ω∈(a|b)*&#125;	(标识符声明与引用一致性的抽象)</div><div class="line">L2=&#123;a^n b^m c^n d^m|n≥1和m≥1&#125;	(形参ab与实参cd一致性的抽象)</div><div class="line">L3=&#123;a^nb^nc^n|n≥1&#125; 		(输入n个字符，回退n个字符，加n个底线，计数问题的抽象)</div><div class="line"></div><div class="line">对文法稍加修改，得到相近的CFL：</div><div class="line">【ω^r是ω的逆序】</div><div class="line">L1&apos;=&#123;ωcω^r|ω∈(a|b)*&#125;			（S→aSa|bSb|c）</div><div class="line">L2&apos;=&#123;a^n b^m c^m d^n|n≥1, m≥1&#125;	  （S→aSd|aAd    A→bAc|bc）</div><div class="line">L2&apos;&apos;=&#123;a^n b^n c^m d^m|n≥1, m≥1&#125;   （S→AB  A→aAb|ab  B→cBd|cd）</div><div class="line">L3&apos;=&#123;a^m b^m c^n|m, n≥1&#125;		  （S→AC  A→aAb|ab   C→cC|c）</div><div class="line"></div><div class="line">正规式：</div><div class="line">L3&apos;&apos;=&#123;a^k b^m c^n|k,m,n&gt;=1&#125; 		a^+ b^+ c^+</div></pre></td></tr></table></figure>
<p>命题：L3’不是正规集，因为构造不出可以识别L3’的DFA<br>证明：（反证）<br>假设L3’是正规集，则可构造n个状态的DFA D，它接受L3’；<br>考察D读完$ε，a，aa，…，a^n$，分别到达$S0，S1，…，Sn$，共有$n+1$个状态。<br>根据鸽巢原理，序列中至少有两个状态相同，设$S_i=S_j（j&gt;i）$，因为$a^ib^ic^k∈L3’$，所以存在路径​$a^ib^ic^k$，但是D中也有路径$a^jb^ic^k$，矛盾；故L3’不是正规集</p>
<h2 id="形式语言与自动机"><a href="#形式语言与自动机" class="headerlink" title="形式语言与自动机"></a>形式语言与自动机</h2><blockquote>
<p>若文法$G=(N，T，P，S)$的每个产生式$α→β$中，均有$α∈(N∪T)^<em>$，且至少含有一个非终结符，$β∈(N∪T)^</em>$，则称G为0型文法【任何0型语言都是递归可枚举的；反之，递归可枚举集必定是一个0型语言】</p>
<p>对0型文法施加以下第i条限制，即得到i型文法。</p>
<ol>
<li>G的任何产生式α→β（S→ε除外）满足|α|≤|β|</li>
<li>G的任何产生式形如A→β，其中A∈N，$β∈(N∪T)^*$【对于$\alpha A\beta\to\alpha \gamma\beta$，则A只有在左边是$\alpha$，右边是$\beta$这样的上下文才可能替换成$\gamma$</li>
<li>G的任何产生式形如A→a或者A→aB(或者A→Ba)，其中A和B∈N，a∈T </li>
</ol>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">文法</th>
<th style="text-align:center">语言</th>
<th style="text-align:center">自动机</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">短语文法（0型）</td>
<td style="text-align:center">短语结构语言</td>
<td style="text-align:center">图灵机</td>
</tr>
<tr>
<td style="text-align:center">CSG        （1型）</td>
<td style="text-align:center">CSL</td>
<td style="text-align:center">线性界线自动机</td>
</tr>
<tr>
<td style="text-align:center">CFG       （2型）</td>
<td style="text-align:center">CFL</td>
<td style="text-align:center">下推自动机</td>
</tr>
<tr>
<td style="text-align:center">正规文法（3型）</td>
<td style="text-align:center">正规集</td>
<td style="text-align:center">有限自动机</td>
</tr>
</tbody>
</table>
</div>
<p>CSG、CFG、正规式能力递减，但是能力越强的文法，其文法的设计和自动机的构造越苦难</p>
<h2 id="自上而下分析"><a href="#自上而下分析" class="headerlink" title="自上而下分析"></a>自上而下分析</h2><p>自上而下分析是一种<strong>试探</strong>的过程，是反复使用不同产生式谋求与输入序列匹配的过程</p>
<p>当既有左递归又有左因子的时候，<strong>先消除左递归</strong></p>
<h3 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h3><p>避免陷入<strong>死循环</strong></p>
<h4 id="消除直接左递归"><a href="#消除直接左递归" class="headerlink" title="消除直接左递归"></a>消除直接左递归</h4><blockquote>
<p>若文法G中的非终结符A，对某个文法符号序列α存在推导$A=^+&gt;Aα$，则称G是<strong>左递归</strong>的。若G中有形如A→Aα的产生式，则称该产生式对A<strong>直接左递归</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">首先，整理A产生式为如下形式:</div><div class="line">	A→ Aα1|Aα2|...|Aαm|β1|β2|...|βn</div><div class="line">其中αi非空[若αi为空，则形成一个有环的A产生式]，βj均不以A开始。然后用下述产生式代替A产生式：</div><div class="line">	A → β1 A&apos; |β2 A&apos; | ...|βn A&apos;   </div><div class="line">	A&apos;→ α1 A&apos; | α2 A&apos; | ... | αm A&apos; |ε</div></pre></td></tr></table></figure>
<h4 id="消除文法左递归"><a href="#消除文法左递归" class="headerlink" title="消除文法左递归"></a>消除文法左递归</h4><p>核心思想：将不是直接左递归的非终结符右部展开到其他产生式中</p>
<p>但是若G产生句子的过程中出现$A=^+&gt;A$的推导，则无法消除左递归</p>
<p>合理排序非终结符：A1，A2，…，An;【通过两层for循环检验】<br>然后用用$Aj→δ1|δ2|…|δk$右部替换$Ai→Ajγ$中的Aj得到$Ai→δ1γ|δ2γ|…|δkγ$;再消除Ai产生式中的直接左递归;</p>
<p>如<code>S→Aa|b  A→Ac|Sd|ε</code></p>
<p>将S的右部展开在A中，得到：<code>A→Ac|Aad|bd|ε</code></p>
<p>消除新产生式中的直接左递归，得到：</p>
<p><code>S→ Aa | b</code> <code>A→ bdA&#39; | A&#39;</code> <code>A&#39;→ cA&#39; | adA&#39; | ε</code></p>
<h3 id="提取左因子"><a href="#提取左因子" class="headerlink" title="提取左因子"></a>提取左因子</h3><p>避免<strong>回溯</strong></p>
<p>将：<code>A → αβ1|αβ2</code>，替换为：<code>A →αA&#39; A&#39;→β1|β2</code></p>
<h3 id="递归下降分析"><a href="#递归下降分析" class="headerlink" title="递归下降分析"></a>递归下降分析</h3><ol>
<li>直接以程序的方式<strong>模拟</strong>产生式产生语言的过程</li>
<li>每个<strong>产生式</strong>对应一个<strong>子程序</strong>，产生式右边的<strong>非终结符</strong>对应<strong>子程序调用</strong>，<strong>终结符</strong>则<strong>与输入序列匹配</strong></li>
<li>它对<strong>文法的限制</strong>是<strong>不能有公共左因子和左递归</strong>；</li>
<li>它是一种<strong>非形式化的方法，</strong>只要能写出子程序，用什么样的方法和步骤均可</li>
</ol>
<p>优点：简单灵活、容易构造</p>
<p>缺点：程序与文法直接相关，对文法的任何改变均需对程序进行相应的修改</p>
<p>适合规模比较小的语言</p>
<p>稳妥的笨方法：</p>
<ol>
<li><p>构造文法的<strong>状态转换图</strong>并且<strong>化简</strong></p>
<ul>
<li>标记为A的边可等价为<strong>标记ε的边转向A转换图</strong>的初态</li>
<li><strong>$ε$边连接的两个状态</strong>可以合并</li>
<li><strong>标记相同</strong>的路径可以合并</li>
<li><strong>不可区分</strong>的状态可以合并</li>
</ul>
</li>
<li><p>将转换图转化为<strong>EBNF</strong>表示</p>
<p>EBNF：扩展BNF（和正规式一样，为了表示方便加入的+、？、[]等等）</p>
<p>①${ }​$：<strong>重复0或若干次</strong>（while）<br>② [ ]：可选择（if或while）<br>③ |：括弧( )之内的或关系（case）<br>④ ( )：改变运算的优先级和结合性</p>
</li>
<li><p>从EBNF构造子程序</p>
</li>
</ol>
<p><strong>构造递归下降字程序：</strong></p>
<p>首先设计两个变量lookahead（当前的下一输入的终结符）和eof（输入结束标志）</p>
<p>另外设计一个函数match(t)，进行终结符匹配</p>
<h3 id="预测分析器"><a href="#预测分析器" class="headerlink" title="预测分析器"></a>预测分析器</h3><p>预测分析器是下推自动机的一个具体实现</p>
<p>栈中的内容是符号；而在移进-归约分析器的栈中内容是状态</p>
<p><img src="/2019/01/09/编译原理-笔记/%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E5%99%A8%E6%A8%A1%E5%9E%8B.png" alt=""></p>
<h4 id="预测分析表"><a href="#预测分析表" class="headerlink" title="预测分析表"></a>预测分析表</h4><p>M[A, a]的内容：若当前栈顶是非终结符A，下一输入终结符是a，则M[A, a]指示下一步动作；其中A为行下标，a为列下标</p>
<p>格局：格局是一个三元组<br>     （栈内容，当前剩余输入，改变格局的动作）<br>           $^top$       $^ip$</p>
<p>改变格局的动作：<br>①  <strong>匹配终结符</strong>：若\^top=^ip(但≠#)，则pop且next(ip)<br>② <strong>展开非终结符</strong>：<br>            若^top= X且M[X,^ip]=α(X→α)，则pop且push(α)<br>③ <strong>报告分析成功</strong>：若^top=^ip=#，则分析成功并结束<br>④ <strong>报告出错</strong>：其它情况，调用错误恢复例程</p>
<h5 id="构造预测分析表"><a href="#构造预测分析表" class="headerlink" title="构造预测分析表"></a>构造预测分析表</h5><ol>
<li>首先构造FIRST集合与FOLLOW集合</li>
<li>然后根据两个集合构造预测分析表</li>
</ol>
<blockquote>
<p><strong>文法符号序列</strong>α的FIRST集合为:<br>  $FIRST(α)=\{a|α=^<em>&gt;a…，a∈T\}$，<br>若$α=^</em>&gt;ε$，则$ε∈FIRST(α)$    </p>
<p><strong>非终结符</strong>A的FOLLOW集合如下:<br>    $FOLLOW（A） = \{ a |S=^*&gt;…Aa…，a∈T\}$，<br>若A是某句型的最右符号，则$#∈FOLLOW（A）$</p>
</blockquote>
<p><em>通俗地讲，α的FIRST集合就是<strong>从α开始</strong>可以导出的所有以终结符开头的序列中的<strong>开头终结符</strong>；而A的FOLLOW集合，就是<strong>从开始符号</strong>可以导出的<strong>所有含A的</strong>文法符号序列中<strong>紧跟A之后的终结符</strong></em></p>
<h6 id="FIRST集合计算"><a href="#FIRST集合计算" class="headerlink" title="FIRST集合计算"></a>FIRST集合计算</h6><p><strong>自下而上计算FIRST</strong></p>
<ol>
<li>若X∈T，则$FIRST(X)={X}$；</li>
<li>若X是非终结符且有X→ε，则加入ε到FIRST(X)；</li>
<li>若X是非终结符且有X→Y1Y2…Yk，并设Y0=ε，Yk+1=ε。那么对所有从0开始的j(0≤j≤k)，若a∈FIRST(Yj+1)且ε∈FIRST(Y1~Yj)【这里表示1到j都有ε】，则加入a到FIRST(X)。</li>
</ol>
<p>FIRST(X1X2…Xn)是所有FIRST(Xi)(i=1,2,..,k)的并集，其中k为第一个具有性质<strong>ε不属于FIRST（Xk）</strong>或<strong>k&gt;n</strong>的文法符号</p>
<p>First集合里的符号一定是终结符，ε不是终结符，也不是非终结符，只是一个表示空的标志而已</p>
<p><code>T-&gt;array[num] of int</code>中<code>array</code>, <code>[</code>, <code>num</code>,  <code>]</code>,  <code>of</code>, <code>int</code>都是终结符 </p>
<h6 id="FOLLOW集合计算"><a href="#FOLLOW集合计算" class="headerlink" title="FOLLOW集合计算"></a>FOLLOW集合计算</h6><p><strong>自上而下计算FOLLOW</strong></p>
<ol>
<li><p>加入#到FOLLOW(S)，其中S是开始符号，#是输入结束标记</p>
</li>
<li><p>若有产生式A→αBβ，则除ε外，FIRST(β)的全体加入到FOLLOW(B)</p>
</li>
<li><p>若有产生式A→αB或A→αBβ且ε∈FIRST(β)，则FOLLOW(A)的全体加入到FOLLOW(B)</p>
<p>若     $S =^*&gt;δAa$     a紧跟A之后<br>则     $=&gt;δαBa$     a也紧跟B之后（A→αB）</p>
<p>或者      $=&gt;δαBβa =^*&gt;δαBa$     （A→αBβ）<br>因为 ε∈FIRST(β) 使得B成为A产生式右部最右的文法符号<br>即    对任何a∈FOLLOW(A)，均有a∈FOLLOW(B)</p>
</li>
</ol>
<p><strong>构造预测分析表：</strong></p>
<p>预测分析表的列都是<strong>终结符</strong></p>
<ol>
<li><p>对文法的每个产生式A→α，执行2和3</p>
</li>
<li><p>对FIRST(α)的每个终结符a，加入α到M[A，a]</p>
<p>若当前栈顶为A，当前输入为a，则规则2表示下一步动作是展开A→α，因为a∈FIRST(α)，所以展开后下一次正好匹配a【这里α是aB…这样的表示，因为FIRST(α)里有a】</p>
</li>
<li><p>若$ε∈FIRST(α)$，则对FOLLOW(A)的每个终结符b(包括#)加入α到M[A，b]</p>
<p>若当前栈顶为A，当前输入为b且b∈FOLLOW(A)，则规则3表示下一步动作是展开A→ε，即栈顶弹出A，继续分析A之后的部分，因为b∈FOLLOW(A)，所以弹出A后下一次正好匹配A的后继b</p>
</li>
<li><p>M中其它没有定义的条目均是error</p>
</li>
</ol>
<h4 id="驱动器"><a href="#驱动器" class="headerlink" title="驱动器"></a>驱动器</h4><figure class="highlight pascal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">初始格局为: （#S，ω#，分析器的第一个动作）[其中ω是输入序列]</div><div class="line">令ip指向ω#中的第一个终结符，top指向S;</div><div class="line">  loop x:=top^; a:=ip^;</div><div class="line">	<span class="keyword">if</span> x ∈ T</div><div class="line">	<span class="keyword">then</span>  	<span class="keyword">if</span> x=a </div><div class="line">			<span class="keyword">then</span> pop(x); next(ip); -- 匹配终结符</div><div class="line">      		<span class="keyword">else</span> error(<span class="number">1</span>);     -- 出错：栈顶终结符不是a</div><div class="line">      		<span class="keyword">end</span> <span class="keyword">if</span>;</div><div class="line">	<span class="keyword">else</span>  	<span class="keyword">if</span>   M[x, a] = X→Y1Y2...Yk</div><div class="line">			<span class="keyword">then</span> pop(X); push(YkYk-<span class="number">1</span>...Y2Y1);--展开产生式</div><div class="line">      		<span class="keyword">else</span> error(<span class="number">2</span>);     -- 出错：产生式不匹配</div><div class="line">      		<span class="keyword">end</span> <span class="keyword">if</span>;</div><div class="line">	<span class="keyword">end</span> <span class="keyword">if</span>;</div><div class="line">	<span class="keyword">exit</span> when x=# <span class="keyword">and</span> a=#;           -- 分析成功</div><div class="line">  <span class="keyword">end</span> loop;</div></pre></td></tr></table></figure>
<h4 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h4><blockquote>
<p>文法G被称为是LL(1)文法，当且仅当为它构造的预测分析表中<strong>不含多重定义的条目</strong>；由此分析表所组成的分析器被称为LL(1)分析器，它所分析的语言被称为LL(1)语言；第一个L代表<strong>从左到右扫描输入序列，</strong>第二个L表示<strong>产生最左推导</strong>，1表示<strong>在确定分析器的每一步动作时向前看一个终结符</strong></p>
</blockquote>
<p><strong><em>任何二义文法都不是LL(1)文法</em></strong></p>
<h5 id="证明是LL-1-文法"><a href="#证明是LL-1-文法" class="headerlink" title="证明是LL(1)文法"></a>证明是LL(1)文法</h5><blockquote>
<p>G是LL(1)的，当且仅当G的任何两个产生式A→α|β满足:</p>
<ol>
<li>对任何<strong>终结符a</strong>，α和β<strong>不能同时推导出以a开始的串</strong></li>
</ol>
<p>向前看一个就不够了，M[A，a]中有多重定义A→α和A→β</p>
<ol>
<li>α和β<strong>最</strong>多有一个可以<strong>推导出ε</strong></li>
</ol>
<p>向前看一个就不够了，任何属于FOLLOW（A）的终结符b(包括#)，M[A，b]中有多重定义A→α和A→β </p>
<ol>
<li>若<strong>β=*&gt;ε</strong>,则<strong>α不能导出以FOLLOW(A)中终结符开始的任何串</strong></li>
</ol>
<p>若条件3不满足，即存在终结符b，它既在FOLLOW(A)中，又在FIRST(α)中，则步骤2把条目A→α加入到M[A，b]中，而步骤3又把条目A→β加入到M[A，b]中，即M[A，b] 中有多重定义A→α和A→β</p>
</blockquote>
<p>所以<strong><em>LL(1)文法既无左递归也无左因子</em></strong></p>
<p>缺点：</p>
<ol>
<li>文法难写，难懂</li>
<li>适应范围有限，往往写不出有些语言的LL(1)文法</li>
</ol>
<p>实际编译器中使用更多的是一类LL(1)文法的真超集——LR(1)文法</p>
<h2 id="自下而上分析"><a href="#自下而上分析" class="headerlink" title="自下而上分析"></a>自下而上分析</h2><p>从句子ω开始，<strong>从左到右扫描ω</strong>，<strong>反复用产生式的左部替换产生式的右部（句型中的句柄）</strong>、谋求对ω的匹配，<strong>最终</strong>得到文法的<strong>开始符号</strong>，<strong>或者发现</strong>一个<strong>错误</strong>：规范归约—剪句柄—移进/归约分析—SLR(1)分析器</p>
<h3 id="规范规约"><a href="#规范规约" class="headerlink" title="规范规约"></a>规范规约</h3><blockquote>
<p>设αβδ是文法G的一个<strong>句型，</strong><br>若 存在S =<em>&gt;αAδ，A =+&gt;β，<br>则 称β是句型αβδ相对于A的<strong>短语</strong>，<br>特别的，若 有A→β，则 称β是句型αβδ相对于产生式A→β的<strong>直接短语</strong><br>一个句型的<strong>最左直接短语</strong>被称为<em>*句柄</em></em></p>
</blockquote>
<p>如：句型：id1+id2*id3，短语：id1+id2*id3、id2*id3、id1、id2、id3，直接短语：id1、id2、id3，句柄：id1</p>
<p><strong>句型</strong>：存在的一个<strong>子树</strong>；<strong>短语</strong>：以非终结符为根子树中<strong>所有</strong>从左到右的<strong>叶子</strong>；<strong>直接短语</strong>：<strong>只有父子关系的树中所有</strong>从左到右排列的<strong>叶子（树高为2）</strong>；<strong>句柄</strong>：<strong>最左边</strong>父子关系树中所有从左到右排列的叶子（<strong>句柄是唯一的</strong>）</p>
<p><img src="/2019/01/09/编译原理-笔记/%E7%9F%AD%E8%AF%AD.png" alt=""></p>
<h4 id="最左规约"><a href="#最左规约" class="headerlink" title="最左规约"></a>最左规约</h4><blockquote>
<p>若 α是文法G的句子且满足下述条件，则 称序列αn，αn-1，…，α0是α的一个最左归约。</p>
<pre><code>1. $α_n=α$
2. $α_0=S$（S是G 的开始符号）
3. 对任何i(0&lt;i&lt;=n)，$α_{i-1}$是将$α_i$中**句柄**替换为相应产生式左部非终结符得到的
</code></pre></blockquote>
<p><strong>最左归约</strong>的<strong>逆过程</strong>是一个<strong>最右推导</strong>，分别称最右推导和最左归约为<strong>规范推导</strong>和<strong>规范归约</strong></p>
<p>推导<code>=&gt;</code>；归约<code>&lt;=</code>（剪句柄的过程）</p>
<h3 id="移进-归约分析器"><a href="#移进-归约分析器" class="headerlink" title="移进-归约分析器"></a>移进-归约分析器</h3><p>也有驱动器指向输入记号流的向上的箭头的！！！</p>
<p><img src="/2019/01/09/编译原理-笔记/%E7%A7%BB%E8%BF%9B%E5%BD%92%E7%BA%A6%E5%88%86%E6%9E%90%E5%99%A8.png" alt=""></p>
<p>格局：（#栈中内容，当前剩余输入#，改变格局的动作）<br>改变格局的动作：<br><strong>移进(shift)：</strong>输入序列中的终结符进栈。(匹配终结符)<br><strong>归约(reduce)：</strong>将栈顶句柄替换为对应非终结符(最左归约)<br><strong>接受(accept)：</strong>宣告分析成功<br><strong>报错(error)：</strong>发现语法错误，调用错误恢复例程</p>
<ol>
<li><strong>句柄</strong>总是在<strong>栈顶</strong>形成(最左归约)</li>
<li><strong>栈中保留</strong>的总是一个<strong>右句型</strong>的前缀(加上若干终结符形成句型)，称为<strong>活前缀</strong></li>
<li><strong>最左归约</strong>是逻辑上从下到上构造一棵分析树，或从下到上为分析树剪句柄</li>
</ol>
<h3 id="LR分析"><a href="#LR分析" class="headerlink" title="LR分析"></a>LR分析</h3><p>特点：</p>
<ol>
<li>采用最一般的<strong>无回溯</strong>移进-归约方法</li>
<li><strong>可分析的文法</strong>是<strong>LL文法的真超集</strong></li>
<li>能够<strong>及时发现错误</strong>，快到从左到右扫描输入序列的最大可能；</li>
<li><strong>分析表较复杂</strong>，难以手工构造</li>
</ol>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">初始格局为：（<span class="string">#0</span>，ω#， 移进），其中<span class="number">0</span>是初态</div><div class="line">ip指向ω#中的第一个终结符，top指向栈顶初始状态；</div><div class="line">loop  s:=top^; a:=ip^;</div><div class="line">   <span class="keyword">case</span> action[s，a] <span class="keyword">is</span></div><div class="line">	 shift s<span class="string">': push(a); push(s'</span>); next(ip); -- 移进</div><div class="line">	 reduce by A→β:</div><div class="line">		pop(2*|β|);	 -- 弹出句柄和相应状态</div><div class="line">		s<span class="string">' := top^;  	 -- 暴露出当前栈顶状态s'</span></div><div class="line">		push(A);     	 -- 产生式左部符号进栈</div><div class="line">		push(<span class="keyword">goto</span>(s<span class="string">'，A)); -- 新栈顶状态进栈</span></div><div class="line"><span class="string">		write(A→β);      -- 完成归约，跟踪分析轨迹</span></div><div class="line"><span class="string">	 accept:  return; 		-- 成功返回</span></div><div class="line"><span class="string">	 others:  error;  		-- 出错处理</span></div><div class="line"><span class="string">   end case;</span></div><div class="line"><span class="string">end loop;</span></div></pre></td></tr></table></figure>
<h4 id="LR分析表"><a href="#LR分析表" class="headerlink" title="LR分析表"></a>LR分析表</h4><p>与预测分析表不同的是LR分析表的列既有终结符也有非终结符的部分</p>
<p><strong>动作表</strong></p>
<p>action[s, <strong>a</strong>]确定改变格局的动作</p>
<p><strong>转移表</strong></p>
<p>goto[s, <strong>A</strong>]指示非终结符的<strong>状态转移</strong></p>
<blockquote>
<p>若为文法G构造的移进-归约分析表中<strong>不含多重定义</strong>的条目，则称G为LR(k)文法，分析器被称为是LR(k)分析器，它所识别的语言被称为LR(k)语言。L表示<strong>从左到右扫描</strong>输入序列，R表示<strong>逆序的最右推导</strong></p>
<p>k表示为确定下一动作<strong>向前看的终结符个数</strong>，一般情况下k&lt;=1。当k=1时，简称LR</p>
</blockquote>
<p>有LR(0)、SLR(1)、LALR(1)和LR(1)分析器，它们功能的强弱和构造的难度依次递增；当k&gt;1后，分析器的构造趋于复杂，一般情况下并不构造k&gt;1的LR(k)分析器</p>
<h4 id="SLR-1-分析器"><a href="#SLR-1-分析器" class="headerlink" title="SLR(1)分析器"></a>SLR(1)分析器</h4><p>SLR(1)，即简单LR(1)</p>
<p>首先构造一个可以识别文法G中<strong>所有活前缀的DFA</strong>，然后根据<strong>DFA</strong>和简单的<strong>向前看</strong>信息<strong>构造SLR分析表</strong></p>
<blockquote>
<p>出现在移进-归约分析器<strong>栈中</strong>的<strong>右句型的前缀</strong>，被称为文法G的<strong>活前缀</strong>（viable prefix）</p>
</blockquote>
<p><code>活前缀＋若干剩余输入（不在栈中）＝&gt;右句型</code></p>
<p>在移进-归约分析中，只要保证已扫描过的输入序列<strong>可以归约为一个活前缀</strong>，则<strong>分析到目前为止没有错误</strong></p>
<blockquote>
<p>一个<strong>LR(0)项目</strong>(简称项目)是这样一个产生式，在它右部的某个位置<strong>有一个点“.”</strong>。对于A→ε，它<strong>仅有</strong>一个项目A→.</p>
</blockquote>
<p>一个产生式右部若有n个文法符号，则该产生式有n+1个LR(0)项目</p>
<p>每个产生式是一个识别活前缀的NFA；每个<strong>项目</strong>是NFA的一个<strong>状态</strong></p>
<p>项目A→α.β显示了分析过程中看到(移进)了产生式的多少；β<strong>不为空</strong>的项目称为<strong>可移进项目</strong>，β<strong>为空</strong>的项目称为<strong>可归约项目</strong></p>
<h5 id="拓广文法"><a href="#拓广文法" class="headerlink" title="拓广文法"></a>拓广文法</h5><p>拓广文法$G’ = G∪{S’→S}$</p>
<p>写拓广文法的时候，每一个一行，然后要写<code>(i)</code>，对于同一个非终结符展开成多个用<code>|</code>连接的时候，每一种选择也必须分行写</p>
<p>其中：<code>S&#39;→.S</code>是识别S的初态，<br>            <code>S&#39;→S.</code>是识别S的终态。<br>目的是使最终构造的DFA状态集中具有<strong>唯一的初态和终态</strong></p>
<h5 id="从NFA到DFA-1"><a href="#从NFA到DFA-1" class="headerlink" title="从NFA到DFA"></a>从NFA到DFA</h5><p>NFA（项目）→DFA（项目集）</p>
<p>词法分析器－“子集法” ：<br>    ① ε_闭包(I)：从<strong>状态集I</strong>不经任何<strong>字符</strong>能到达的<strong>状态</strong>全体<br>    ② smove（I，a）：所有从I经<strong>字符a</strong>能<strong>直接</strong>到达的<strong>状态</strong>全体</p>
<p>类似的两个过程：<br>    ① closure(I)：从项目集I不经任何<strong>文法符号</strong>到达的<strong>项目</strong>全体<br>    ② goto(I，x)：所有从I经<strong>文法符号x</strong>能<strong>直接</strong>到达的<strong>项目</strong>全体</p>
<blockquote>
<p>项目集I的闭包closure(I)是这样一个项目集</p>
<pre><code>1. I中的所有项目属于closure(I)；
2. 若A→α.Bβ属于closure(I)，则所有**形如B→.γ的项目**属于closure(I)；
3. 其它任何项目不属于closure(I)
</code></pre></blockquote>
<p>即若<code>.</code>后面是一个非终结符B，则需要将B展开成<code>B→.γ</code>的形式</p>
<p>closure(I)的计算</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">closure</span>（<span class="title">I</span>） <span class="title">is</span></span></div><div class="line"><span class="function"><span class="title">begin</span>   <span class="title">J</span> :</span>= I；</div><div class="line">    <span class="keyword">for</span> J中每个项目[A→α.Bβ]和G中每个产生式B→γ</div><div class="line">    loop </div><div class="line">        <span class="keyword">if</span>   B→.γ不在J中  </div><div class="line">        <span class="keyword">then</span> 加入[B→.γ]到J;</div><div class="line">        <span class="keyword">end</span>  <span class="keyword">if</span>；</div><div class="line">        <span class="keyword">exit</span> when 再没有项目可以被加入到J中；</div><div class="line">    <span class="keyword">end</span> loop；    </div><div class="line">    return（J）；</div><div class="line"><span class="keyword">end</span> closure；</div></pre></td></tr></table></figure>
<blockquote>
<p>对所有属于项目集I、且形如[A→α.Xβ]的项目（X∈N∪T），goto(I，X)是所有<strong>形如[A→αX.β]的项目</strong></p>
</blockquote>
<p>设J=goto(I，X)，K=closure(J)，K中项目A→α.β分为两类：</p>
<pre><code>1. J：   α非空，因为至少有一个X；**均是核心项目**
2. K-J：  α=ε，即 &quot;.&quot;在产生式右部最左边（想到新增加的都是`B→.γ`这类）；可由某个J计算而来（K-J=closure(J)-J）；**均是非核心项目**
</code></pre><blockquote>
<p><strong>项目[S’→.S]</strong>和所有“.”<strong>不在</strong>产生式右部<strong>最左边</strong>的项目称为<strong>核心项目</strong>(kernel items)，其它“.”在产生式右部<strong>最左边</strong>的项目(不包括[S’→.S])称为<strong>非核心项目</strong>(nonkernel items)</p>
</blockquote>
<p>比较：项目A→α.β显示了分析过程中看到(移进)了产生式的多少；β<strong>不为空</strong>的项目称为<strong>可移进项目</strong>，β<strong>为空</strong>的项目称为<strong>可归约项目</strong></p>
<p><strong>识别活前缀的DFA：</strong></p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">构造文法G的、基于LR(<span class="number">0</span>)项目的、识别活前缀的DFA</div><div class="line">加入closure(S’→.S)到C中，作为唯一未标记状态; -- 初态</div><div class="line"><span class="keyword">while</span> C中还有未标记状态I   -- 考察所有未标记状态</div><div class="line">loop 标记I;</div><div class="line">	<span class="keyword">for</span> I状态下的每个文法符号x   -- 考察所有x</div><div class="line">	loop <span class="keyword">if</span> J:=closure(<span class="keyword">goto</span>(I,x))非空  --有下一状态</div><div class="line">		 <span class="keyword">then</span> 	Dtran[I,x]:= J;  -- 记录下一状态转移</div><div class="line">			<span class="keyword">if</span> J不在C中	           -- 新状态待考察</div><div class="line">			<span class="keyword">then</span> 不标记加入J到C；</div><div class="line">			<span class="keyword">end</span> <span class="keyword">if</span>;</div><div class="line">		  <span class="keyword">end</span> <span class="keyword">if</span>;</div><div class="line">	<span class="keyword">end</span> loop;</div><div class="line"><span class="keyword">end</span> loop;</div></pre></td></tr></table></figure>
<p>例子如下：<em>大概就是每次加入一个新的文法符号X的时候，如果到达新的状态，则转移过去，并且如果.之后的是非终结符的时候，需要继续找到从项目集I不经任何文法符号到达的项目全体（即计算closure(I)）</em></p>
<p><img src="/2019/01/09/编译原理-笔记/%E6%9E%84%E9%80%A0SLR(1" alt="">%E5%88%86%E6%9E%90%E5%99%A8.png)</p>
<h5 id="活前缀与项目"><a href="#活前缀与项目" class="headerlink" title="活前缀与项目"></a>活前缀与项目</h5><blockquote>
<p>若存在最右推导S’=*&gt;αAω=&gt;αβ1β2ω，则称项目[A→β1.β2] 对活前缀αβ1有效</p>
</blockquote>
<p>项目A→β1.β2对活前缀αβ1有效，具有两层含意：</p>
<ol>
<li>从文法开始符号，<strong>经αβ1</strong>可到达<strong>该项目</strong>(项目所在<strong>状态</strong>)</li>
<li>在当前活前缀的情况下，该项目<strong>可指导下一步分析动作</strong>(αAω=&gt;αβ1β2ω)</li>
</ol>
<p><strong>活前缀与项目的关系</strong></p>
<p>① 一个<strong>项目</strong>可能对<strong>若干个活前缀</strong>有效，项目A→β1.β2对所有从初态出发可以到达此项目的路径上的标记均有效（一个路径标记是一个活前缀）<br>② <strong>若干个项目</strong>可能对<strong>同一个活前缀</strong>有效，项目集中的所有项目对同一活前缀均有效</p>
<p>​    综合①②可知：<br>​    <strong>同一项目集</strong>中的<strong>所有项目</strong>，对此项目集的<strong>所有活前缀</strong>均有效，即项目集中的每个项目均有同等权利指导下一步动作（<em>即一个对某活前缀有效，则整个项目集对他都有效</em>）</p>
<p><em>这里的<strong>活前缀的DFA</strong>也要每一种可能分行写，而且不可以用<code>|</code>连接，对于<code>.</code>后面的非终结符，展开要完全，比如项目集中已经存在部分，也要补全，然后每个还要标序号，为了清晰可见，可以不连接到，而只是箭头和标号，同时注意如果给出的不是拓广文法，要先变成拓广文法，然后给出识别活前缀的DFA</em></p>
<p><img src="/2019/01/09/编译原理-笔记/%E6%B4%BB%E5%89%8D%E7%BC%80.png" alt=""></p>
<p>③ 有效项目的意义</p>
<p>​    1.到目前为止分析是正确的；<br>​    2.指导下一步的分析：<br>​    A→β1.β2（可移进项）：移进β2中第一个终结符<br>​    B→β.（可归约项）：按产生式B→β归约</p>
<p>④  项目集中的冲突和解决冲突的简单方法：SLR(1)<br>当一个项目集中同时存在：<br>A→β1.β2和B→β1.：<strong>既可移进又可归约</strong>，<strong>移进/归约冲突</strong><br>A→α.和B→α.：<strong>均可指导下一步分析</strong>，<strong>归约/归约冲突</strong><br>解决方法：<strong>简单向前看一个终结符：</strong><br>移进/归约冲突：若<strong>FIRST(β2)∩FOLLOW(B)=Φ</strong>，冲突可解决<br>归约/归约冲突：若<strong>FOLLOW(A)∩FOLLOW(B)=Φ</strong>，冲突可解决</p>
<h6 id="证明是SLR-1-文法"><a href="#证明是SLR-1-文法" class="headerlink" title="证明是SLR(1)文法"></a>证明是SLR(1)文法</h6><p>若<strong>冲突可以解决</strong>，则称文法为<strong>SLR(1)文法</strong>，构造的分析表为SLR(1)分析表</p>
<p><em>在写原因的时候，需要给出每一个FIRST和FOLLOW，算计算FIRST和FOLLOW的过程，因为是自下而上和自上而下的</em></p>
<h6 id="证明是LR-0-文法"><a href="#证明是LR-0-文法" class="headerlink" title="证明是LR(0)文法"></a>证明是LR(0)文法</h6><p>若上述构造的<strong>DFA中没有冲突</strong>，则<strong>文法是LR(0)的</strong>（可以说某某项目集既有可移进项目又有可归约项目，产生了移进/归约冲突，所以该文法不是LR(0)文法）</p>
<p>例如上图中，I1、I2、I9均有移进/归约冲突</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">FIRST(F) = &#123;-, id&#125;</div><div class="line">FIRST(T) = &#123;-, id&#125;</div><div class="line">FIRST(E) = &#123;-, id&#125;</div><div class="line">FIRST(E&apos;)= &#123;-, id&#125;</div><div class="line"></div><div class="line">FOLLOW(E&apos;)= &#123;#&#125;</div><div class="line">FOLLOW(E) = &#123;-, #&#125;</div><div class="line">FOLLOW(T) = &#123;*, -, #&#125;</div><div class="line">FOLLOW(F) = &#123;*, -, #&#125;</div></pre></td></tr></table></figure>
<p>但是<code>FIRST(-T)∩FOLLOW(E&#39;)=Φ</code> <code>FIRST(*F)∩FOLLOW(E)=Φ</code>，所以此文法是SLR(1)文法</p>
<h5 id="构造SLR分析表"><a href="#构造SLR分析表" class="headerlink" title="构造SLR分析表"></a>构造SLR分析表</h5><p>输入: 基于G的LR(0)项目集的、识别活前缀的DFA=(C, Dtran)</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>   DFA中有不能解决的移进/归约和归约/归约冲突</div><div class="line"><span class="keyword">then</span> error;</div><div class="line"><span class="keyword">else</span> <span class="keyword">for</span> 每个状态转移Dtran[i,x]=j</div><div class="line">	   loop <span class="keyword">if</span> x∈T </div><div class="line">            <span class="keyword">then</span> action[i,x]:=Sj; </div><div class="line">            <span class="keyword">else</span> <span class="keyword">goto</span>[i,x]:=j; </div><div class="line">            <span class="keyword">end</span> <span class="keyword">if</span>;</div><div class="line">       <span class="keyword">end</span> loop;</div><div class="line">       <span class="keyword">for</span>  状态i的每个可归约项A→α.</div><div class="line">       loop  <span class="keyword">if</span>   S<span class="string">'→ S. </span></div><div class="line"><span class="string">             then action[i, #]:=acc;</span></div><div class="line"><span class="string">             else for 每个a∈FOLLOW(A) </span></div><div class="line"><span class="string">                  loop action[i,a]:=Rk; end loop; --k代表当时给表达式的标号</span></div><div class="line"><span class="string">             end if;</span></div><div class="line"><span class="string">       end loop;</span></div><div class="line"><span class="string">   end if;</span></div><div class="line"><span class="string">2. DFA的初态（S'</span>→.S所在的状态），是分析表的开始状态</div></pre></td></tr></table></figure>
<p>例如，上述例子可构造分析表如下：</p>
<p><img src="/2019/01/09/编译原理-笔记/SLR%E5%88%86%E6%9E%90%E8%A1%A8.png" alt=""></p>
<h4 id="非SLR-1-文法"><a href="#非SLR-1-文法" class="headerlink" title="非SLR(1)文法"></a>非SLR(1)文法</h4><p><strong>二义文法不是SLR(1)文法</strong></p>
<p>所以非SLR(1)文法分为两类</p>
<ul>
<li>非二义文法：可以增加向前看终结符个数解决冲突</li>
<li>二义文法：无论向前看多少个终结符，也无法解决二义性</li>
</ul>
<h2 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h2><ol>
<li><p>根据给出的文法，首先消除二义性，接着消除左递归</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">E→E+E </div><div class="line"> | E*E</div><div class="line"> |（E） </div><div class="line"> | -E</div><div class="line"> | id</div></pre></td></tr></table></figure>
</li>
</ol>
<p>   首先消除二义性：</p>
<p>   先看优先级：[+] [<em>] [(), -, id]，再结合性，左结合：+ </em> ()；右结合：-；无结合id</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">E-&gt;E+T|T</div><div class="line">T-&gt;T*F|F</div><div class="line">F-&gt;(E)|-F|id</div></pre></td></tr></table></figure>
<p>   再消除左递归：</p>
<p>   根据算法<code>A-&gt;Aα|β</code>变成<code>A-&gt;βA&#39; A&#39;-&gt;αA&#39;|ε</code></p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">E-&gt;TE&apos;</div><div class="line">E&apos;-&gt;+TE&apos;|ε</div><div class="line">T-&gt;FT&apos;</div><div class="line">T&apos;-&gt;*FT&apos;|ε</div><div class="line">F-&gt;(E)|-F|id</div></pre></td></tr></table></figure>
<ol>
<li><p>根据给出的文法，消除左递归，编写状态转换图，并化简，写出递归下降子程序；编写预测表，并通过驱动器算法来预测分析句子<code>id+id*id;#</code>是否被接受</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">L→E;L|ε</div><div class="line">     E→E+T|E-T|T</div><div class="line">     T→T*F|T/F|T mod F|F</div><div class="line">     F→(E)|id|num</div></pre></td></tr></table></figure>
</li>
</ol>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">消除左递归后的等价文法:</div><div class="line">  L →E;L|ε</div><div class="line">  E →TE&apos;</div><div class="line">  E&apos;→+TE&apos;|-TE&apos;|ε</div><div class="line">  T →FT&apos;</div><div class="line">  T&apos;→*FT&apos;|/FT&apos;| mod FT&apos;|ε</div><div class="line">  F →(E)|id|num</div></pre></td></tr></table></figure>
<p>   转换图及其化简：</p>
<p>   <img src="/2019/01/09/编译原理-笔记/%E6%96%87%E6%B3%95%E8%BD%AC%E6%8D%A2%E5%9B%BE.png" alt=""></p>
<p>   递归下降子程序</p>
   <figure class="highlight pascal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">L</span> <span class="title">is</span></span></div><div class="line"><span class="function"><span class="title">begin</span></span></div><div class="line"><span class="function">   <span class="title">lookahead</span> :</span>= lexan； --调用词法分析器，返回一个终结符</div><div class="line">   <span class="keyword">while</span> (lookahead/=eof)loop E; match(<span class="string">';'</span>); <span class="keyword">end</span> loop;</div><div class="line"><span class="keyword">end</span> L;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">E</span> <span class="title">is</span></span></div><div class="line"><span class="function"><span class="title">begin</span></span></div><div class="line"><span class="function">  <span class="title">T</span>;</span></div><div class="line">  while lookahead∈(+|-)</div><div class="line">  loop </div><div class="line">  	   match(lookahead);</div><div class="line">       T;</div><div class="line">  <span class="keyword">end</span> loop;</div><div class="line"><span class="keyword">end</span> E;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">T</span> <span class="title">is</span></span></div><div class="line"><span class="function"><span class="title">begin</span></span></div><div class="line"><span class="function">  <span class="title">F</span>;</span></div><div class="line">  <span class="keyword">while</span> lookahead∈<span class="comment">(*|/|mod)</span></div><div class="line"><span class="comment">  loop </span></div><div class="line"><span class="comment">  		match(lookahead);</span></div><div class="line"><span class="comment">       	F;</span></div><div class="line"><span class="comment">  end loop;</span></div><div class="line"><span class="comment">end T;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">procedure F is</span></div><div class="line"><span class="comment">begin</span></div><div class="line"><span class="comment">   case lookahead is</span></div><div class="line"><span class="comment">    '(' : match('('); E; match(')');</span></div><div class="line"><span class="comment">    id  : match(id);</span></div><div class="line"><span class="comment">    num : match(num);</span></div><div class="line"><span class="comment">    others : error("syntax error2");</span></div><div class="line"><span class="comment">   end case;</span></div><div class="line"><span class="comment">end F;</span></div></pre></td></tr></table></figure>
<p>   自下而上计算FIRST</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">FIRST(F)=&#123;(, id, num&#125;</div><div class="line"></div><div class="line">FIRST(T&apos;)=&#123;ε, *, /, mod&#125;</div><div class="line"></div><div class="line">FIRST(T)=FIRST(F)=&#123;(, id, num&#125;</div><div class="line"></div><div class="line">FIRST(E&apos;)=&#123;+, -, ε&#125;</div><div class="line"></div><div class="line">FIRST(E)=FIRST(T)=&#123;(, id, num&#125;</div><div class="line"></div><div class="line">FIRST(L)=FIRST(E)+ε=&#123;(, id, num, ε&#125;</div></pre></td></tr></table></figure>
<p>   自上而下计算FOLLOW</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">FOLLOW(L)=&#123;#&#125;</div><div class="line"></div><div class="line">FOLLOW(E)=&#123;), ;&#125;</div><div class="line"></div><div class="line">FOLLOW(E&apos;)=FOLLOW(E)=&#123;), ;&#125;</div><div class="line"></div><div class="line">FOLLOW(T)=FIRST(E&apos;)+FOLLOW(E)=&#123;+, -, ), ;&#125;</div><div class="line"></div><div class="line">FOLLOW(T&apos;)=FOLLOW(T)=&#123;+, -, ), ;&#125;</div><div class="line"></div><div class="line">FOLLOW(F)=FOLLOW(T)+FOLLOW(T&apos;)+[FIRST(T&apos;)-ε]=&#123;+, -, ), ;, *, /, mod&#125;</div></pre></td></tr></table></figure>
<p>   对文法的每个产生式A→α：</p>
<p>   对FIRST(α)的每个终结符a，加入α到M[A，a]</p>
<p>   若ε∈FIRST(α)，则对FOLLOW(A)的每个终结符b(包括#)加入α到M[A，b]</p>
<p>   <img src="/2019/01/09/编译原理-笔记/%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E8%A1%A8.png" alt=""></p>
<p>   <img src="/2019/01/09/编译原理-笔记/%E9%A9%B1%E5%8A%A8%E5%99%A8.png" alt=""></p>
<ol>
<li><p>已知文法：(1) S→aABe  (2) A→b  (3) A→Abc    (4) B→d，求对句子：abbcde的最左归约；并用移进-归约方法分析abbcde</p>
<p><code>abbcde &lt;= aAbcde &lt;= aAde &lt;= aABe &lt;= S</code></p>
<p><code>a4          a3       a2          a1    a0</code></p>
<p>移进-归约方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">栈	剩余输入  改变格局的动作</div><div class="line">#	abbcde#  移进</div><div class="line">#a	 bbcde#  移进</div><div class="line">#ab	  bcde#  归约，(2)A→b</div><div class="line">#aA	  bcde#  移进</div><div class="line">#aAb   cde#  移进</div><div class="line">#aAbc   de#  归约，(3)A→Abc</div><div class="line">#aA     de#  移进</div><div class="line">#aAd     e#  归约，(4)B→d</div><div class="line">#aAB     e#  移进</div><div class="line">#aABe 	  # 归约，(1)S→aABe </div><div class="line">#S		  # 接受</div></pre></td></tr></table></figure>
</li>
<li><p>已知文法如下，求<code>id--id*id#</code>是否被接受</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">E → E-T	（1） </div><div class="line">   | T	（2）</div><div class="line">T → T*F	（3）</div><div class="line">   | F	（4）</div><div class="line">F → -F	（5）</div><div class="line">   | id （6）</div></pre></td></tr></table></figure>
<p><img src="/2019/01/09/编译原理-笔记/%E7%A7%BB%E8%BF%9B-%E5%BD%92%E7%BA%A6%E8%A1%A8.png" alt=""></p>
</li>
</ol>
<pre><code> 首先我们再来回顾一下规则
</code></pre>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">shift s&apos;: </div><div class="line">  push(a); push(s&apos;); next(ip); </div><div class="line"></div><div class="line">reduce by A→β:</div><div class="line">  pop(2*|β|);</div><div class="line">  s&apos;:=top^;</div><div class="line">  push(A);  push(goto(s&apos;，A));</div><div class="line">  write(A→β);</div></pre></td></tr></table></figure>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">栈	      剩余输入	  	动作</div><div class="line">#0	    id--id*id# 		s4</div><div class="line">#0id4	  --id*id# 		r6(F→id)</div><div class="line"></div><div class="line">这里来说明一下归约的步骤，首先弹出两个id的大小，现在的栈是#0，然后修改栈指针，压入F，同时压入goto(0, F)，即3</div><div class="line"></div><div class="line">#0F3	  --id*id# 		r4(T→F)</div><div class="line">#0T2	  --id*id# 		r2(E→T)</div><div class="line">#0E1	  --id*id#  	s6</div><div class="line">#0E1-6     -id*id#  	s5</div><div class="line">#0E1-6-5    id*id#  	s4</div><div class="line">#0E1-6-5id4   *id#  	r6(F→id)</div><div class="line">#0E1-6-5F8    *id#  	r5(F→-F)</div><div class="line"></div><div class="line">这里来说明一下归约的步骤，首先弹出两个-F的大小，即4个，现在的栈是#0E1-6，然后修改栈指针，压入F，同时压入goto(6, F)，即3</div><div class="line"></div><div class="line">#0E1-6F3      *id# 		r4(T→F)</div><div class="line">#0E1-6T9      *id#  	s7</div><div class="line">#0E1-6T9*7     id#  	s4</div><div class="line">#0E1-6T9*7id4    #  	r6(F→id)</div><div class="line">#0E1-6T9*7F10    #  	r3(T→T*F)</div><div class="line">#0E1-6T9         #		r1(E→E-T)</div><div class="line">#0E1             #		acc</div></pre></td></tr></table></figure>
<h1 id="静态语义分析"><a href="#静态语义分析" class="headerlink" title="静态语义分析"></a>静态语义分析</h1><p><strong>语法制导翻译</strong>是<strong>处理语义</strong>的基本方法，它<strong>以语法分析为基础</strong>，在语法分析得到语言结构的结果时，处理附着于此结构上的语义，如计算表达式的值、生成中间代码等</p>
<h2 id="语法与语义"><a href="#语法与语义" class="headerlink" title="语法与语义"></a>语法与语义</h2><p>语法是指<strong><em>语言结构</em></strong>，即语言的“样子”；语义是<em>附着于语言结构上的<strong>实际含义</strong></em>，即语言的“意义”</p>
<p><strong>语义分析的作用：</strong></p>
<ul>
<li><strong>检查</strong>是否结构正确的句子所表示的意思也<strong>合法</strong></li>
<li><strong>执行规定的语义动作</strong>，如：<ul>
<li>表达式求值</li>
<li>符号表填写</li>
<li>中间代码生成等</li>
</ul>
</li>
</ul>
<p>方法：<strong>语法制导翻译</strong></p>
<h3 id="语法制导翻译"><a href="#语法制导翻译" class="headerlink" title="语法制导翻译"></a>语法制导翻译</h3><p>基本思想：将语言结构的语义以<strong>属性</strong>的形式赋予代表此结构的文法符号，而<strong>属性的计算</strong>以<strong>语义规则</strong>的形式赋予由文法符号组成的产生式。在语法分析推导或规约的每一步骤中，通过语义规则实现对属性的计算，以达到对语义的处理</p>
<p><strong>具体方法：</strong></p>
<ul>
<li>将文法符号所代表的语言结构的意思，用附着于该文法符号的<strong>属性</strong>表示</li>
<li>用<strong>语义规则</strong>规定产生式所代表的语言结构之间的关系（即属性之间的关系），即用语义规则实现属性计算</li>
</ul>
<h3 id="语义规则"><a href="#语义规则" class="headerlink" title="语义规则"></a>语义规则</h3><p><strong>两种形式：</strong></p>
<ul>
<li>语法制导定义<em>（算法）</em><br>用<strong>抽象的属性</strong>和<strong>运算</strong>表示的语义规则 (公式，做什么)</li>
<li>翻译方案<em>（程序实现，方法不唯一）</em><br>用<strong>具体的属性</strong>和<strong>运算</strong>表示的语义规则 (程序段，如何做)<br><strong>语义规则</strong>也被习惯上称为<strong>语义动作</strong><br>忽略实现细节，二者作用等价（设计与实现）</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><blockquote>
<p>对于产生式A→α，其中α是由文法符号X1X2…Xn组成的序列，它的<strong>语义规则</strong>可以表示为(4.1)所示关于属性的函数：<br>       b := f(c1, c2, …, ck)                  (4.1)<br>语义规则中的属性存在下述性质与关系。<br>     (1) 若b是A的属性，c1, c2, …, ck是α中文法符号的属性，或者A的其它属性，则称b是A的综合属性。<br>     (2) 若b是α中某文法符号Xi的属性，c1, c2, …, ck是A的属性，或者是α中其它文法符号的属性，则称b是Xi的继承属性。<br>     (3) 称(4.1)中属性b依赖于属性c1, c2, …, ck。<br>     (4) 若语义规则的形式如下，则可将其想像为产生式左部文法符号A的一个虚拟属性。属性之间的依赖关系，在虚拟属性上依然存在。<br>       f(c1, c2, …, ck) </p>
</blockquote>
<p><strong>属性</strong>之间的<strong>计算</strong>构成了<strong>语义规则</strong>，<strong>计算的先后次序</strong>被称为<strong>属性的依赖关系</strong></p>
<p>例如：<code>E→E1+E2  E.val:=E1.val+E2.val</code>，则表明：E的属性.val由E1和E2的相应属性计算而来，E的属性依赖于E1和E2的属性</p>
<h5 id="注释分析树"><a href="#注释分析树" class="headerlink" title="注释分析树"></a>注释分析树</h5><p>将<strong>属性</strong>附着在<strong>分析树</strong>对应<strong>文法符号</strong>上，形成<strong>注释分析树</strong>；类似的，将<strong>属性</strong>附着在<strong>语法树</strong>对应<strong>文法符号</strong>上，形成<strong>语法分析树</strong></p>
<p><em>注释分析树直观地反映属性的性质和属性之间的关系，所以画树还要标属性，对于S标nc，对于M标stat，对于E标tc和fc</em></p>
<p><strong>继承属性：</strong>自上而下计算的，从前辈和<strong>兄弟</strong>的属性计算得到，即“自上而下，包括兄弟”</p>
<p><strong>综合属性：</strong>自下而上计算的，从子孙和<strong>自身</strong>的其他属性计算得到，即“自下而上，包括自身”</p>
<h3 id="LR分析翻译方案的设计"><a href="#LR分析翻译方案的设计" class="headerlink" title="LR分析翻译方案的设计"></a>LR分析翻译方案的设计</h3><p>LR分析中的语法制导翻译实质上是对LR语法分析的扩充：</p>
<ol>
<li><strong>扩充LR分析器的功能：</strong>当执行归约产生式的动作时，也执行产生式对应的语义动作。由于是<strong>归约</strong>时执行语义动作，因此<em>限制语义动作仅能放在产生式右部的<strong>最右边</strong></em></li>
<li><strong>扩充分析栈：</strong>增加一个<strong>与分析栈并列的语义栈，</strong>用于存放分析栈中文法符号所对应的<strong>属性值</strong> </li>
</ol>
<h3 id="递归下降分析翻译方案的设计"><a href="#递归下降分析翻译方案的设计" class="headerlink" title="递归下降分析翻译方案的设计"></a>递归下降分析翻译方案的设计</h3><p>在产生式右部<strong>任何位置</strong>都可以嵌入语义动作；（与LR分析只能在最右边进行比较）</p>
<p>在函数返回值、参数、变量等设计存储空间</p>
<h2 id="中间代码"><a href="#中间代码" class="headerlink" title="中间代码"></a>中间代码</h2><ul>
<li>要求中间代码具有如下特性，以便于编译器的<strong>开发移植</strong>和<strong>代码的优化</strong>（优点）<ul>
<li><em>便于语法制导翻译</em></li>
<li><em>既与机器指令的结构相近，又与具体机器无关。</em></li>
</ul>
</li>
<li>中间代码的主要形式：树、后缀式、三地址码等</li>
</ul>
<h3 id="后缀式"><a href="#后缀式" class="headerlink" title="后缀式"></a>后缀式</h3><p>也被称为逆波兰表示，<em>操作数在前，操作符紧随其后，无需用括号限制运算的优先级和结合性</em></p>
<p>表示并不惟一</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">x := first_token;</div><div class="line"><span class="keyword">while</span>  <span class="keyword">not</span> end_of_exp </div><div class="line">loop    <span class="keyword">if</span>   x <span class="keyword">in</span> operands</div><div class="line">        <span class="keyword">then</span> push x;          -- 操作数进栈</div><div class="line">        <span class="keyword">else</span> pop(operands);  -- 算符，弹出操作数</div><div class="line">             push(evaluate);  -- 计算，并将结果进栈</div><div class="line">        <span class="keyword">end</span>  <span class="keyword">if</span>;</div><div class="line">     	next(x);</div><div class="line"><span class="keyword">end</span> loop;</div></pre></td></tr></table></figure>
<p>后缀式并不局限于二元运算的表达式，可以推广到<strong>任何语句</strong>，<em>只要遵守操作数在前，操作符紧跟其后的原则即可</em></p>
<h3 id="三地址码"><a href="#三地址码" class="headerlink" title="三地址码"></a>三地址码</h3><p>形式接近机器指令，且具有便于优化的特征</p>
<p>顾名思义，是由<strong>不超过三个地址</strong>组成的一个运算</p>
<p>题目中的三地址码序列需要像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(1) if a &lt; b goto (3)</div><div class="line">(2) goto (8)</div><div class="line">(3) if c &lt; d goto(5)</div><div class="line">(4) goto (8)</div><div class="line">(5) t1:= a + c</div><div class="line">(6) x:=t1</div><div class="line">(7) goto -</div></pre></td></tr></table></figure>
<p>语法：</p>
<p><code>result := arg1 op arg2</code>结果存放在result中的二元运算<code>arg1 op arg2</code></p>
<p>或<code>result := op arg1</code>结果存放在result中一元运算op arg1</p>
<p>或 <code>op arg1</code>一元运算op arg1</p>
<p>或<code>result := arg1</code>直接拷贝</p>
<h4 id="三元式"><a href="#三元式" class="headerlink" title="三元式"></a>三元式</h4><p><code>(i)(op,  arg1,  arg2)</code></p>
<p>序号(i)是它们在三元式表中的位置 </p>
<p>序号的双重含义：既代表<strong>此三元式</strong>，又代表<strong>三元式存放的结果</strong><br>存放方式：<strong>数组结构</strong>，三元式在数组中的位置由下标决定<br>弱点：给代码的<strong>优化</strong>带来困难<br>       因为代码优化常使用的方法是删除某些代码或移动某些代码位置，而一旦进行了代码的删除或移动，则表示某三元式的序号会发生变化，从而使得其他三元式中对原序号的引用无效</p>
<h5 id="语法制导翻译-1"><a href="#语法制导翻译-1" class="headerlink" title="语法制导翻译"></a>语法制导翻译</h5><ol>
<li>属性 .code：三元式代码，指示标识符的<strong>存储单元</strong>或三元式表中的<strong>序号</strong></li>
<li>属性 .name：<strong>标识符的名字</strong></li>
<li>函数trip( op，arg1，arg2 )：<strong>生成一个三元式</strong>，<strong>返回</strong>三元式的<strong>序号</strong></li>
<li>函数 entry(id.name)：<strong>返回</strong>标识符在<strong>符号表中的位置</strong>或<strong>存储位置</strong> </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">产生式：					语义规则：</div><div class="line">(1) A→id:=E	&#123;A.code:=trip(:=,entry(id.name),E.code)&#125;</div><div class="line">(2) E→E1+E2	&#123;E.code:=trip(+,E1.code，E2.code)&#125;</div><div class="line">(3) E→E1*E2 &#123;E.code:=trip(*,E1.code，E2.code)&#125;</div><div class="line">(4) E→(E1)  &#123;E.code:=E1.code&#125;</div><div class="line">(5) E→-E1	&#123;E.code:=trip(@，E1.code, )&#125;</div><div class="line">(6) E→id	&#123;E.code:=entry(id.name)&#125;</div></pre></td></tr></table></figure>
<h4 id="四元式"><a href="#四元式" class="headerlink" title="四元式"></a>四元式</h4><ol>
<li><p>四元式与三元式的唯一区别是将<strong>由序号所表示的运算结果</strong>改为了由<strong>临时变量</strong>来表示</p>
</li>
<li><p>此改变使得<strong>四元式具有了运算结果</strong>与<strong>四元式在四元式序列中的位置无关的特点</strong>，它为代码的优化提供了极大方便，因为这样可以<strong>删除或移动四元式而不会影响运算结果</strong>【避免了三元式的值与三元式在三元式组中的位置相关的弱点】</p>
</li>
<li><p>三地址码与四元式形式的一致性</p>
<p>​    <em>四元式</em>                             <em>三地址码</em><br>(op，arg1，arg2，result)       result := arg1 op arg2</p>
<p>result的表示方法通常是给出一个临时名字，用它来存放运算的结果，被称为<strong>临时变量</strong>（语法制导翻译时可以随意引入临时变量，若干临时变量可以共用同一个存储空间）</p>
</li>
</ol>
<h5 id="语法制导翻译-2"><a href="#语法制导翻译-2" class="headerlink" title="语法制导翻译"></a>语法制导翻译</h5><ol>
<li>属性.code：    表示存放<strong>运算结果的变量</strong></li>
<li>函数newtemp：返回一个<strong>新的临时变量</strong>，如T1，T2，…等</li>
<li>过程emit( op，arg1，arg2, result)：<strong>生成一个四元式</strong>，若为一元运算，则<strong>arg2可空</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">产生式：					语义规则：</div><div class="line">1)A→id:=E	&#123;A.code:=newtemp; emit(:=, entry(id.name), E.code, A.code)&#125;</div><div class="line">(2)E→E1+E2	&#123;E.code:=newtemp; emit(+，E1.code,E2.code,E.code)&#125;</div><div class="line">(3)E→E1*E2	&#123;E.code:=newtemp; emit(*，E1.code,E2.code,E.code)&#125;</div><div class="line">(4)E→(E1)	&#123;E.code:=E1.code&#125;</div><div class="line">(5)E→-E1	&#123;E.code:=newtemp; emit(@,E1.code, , E.code)&#125;</div><div class="line">(6)E→id		&#123;E.code:=entry(id.name)&#125;</div></pre></td></tr></table></figure>
<h4 id="图形表示"><a href="#图形表示" class="headerlink" title="图形表示"></a>图形表示</h4><p>树作为中间代码，语法树真实反映句子结构，对语法树稍加修改（加入语义信息），即可以作为中间代码的一种形式(注释语法树)</p>
<h5 id="树语法制导翻译"><a href="#树语法制导翻译" class="headerlink" title="树语法制导翻译"></a>树语法制导翻译</h5><ol>
<li>属性.nptr：指向树节点的指针</li>
<li>函数mknode(op，nptr1，nptr2)： 生成一个根或内部节点，节点数据是op， nptr1和nptr2分别指向的左右孩子的子树。若仅有一个孩子，则nptr2为空</li>
<li>函数mkleaf(node)： 生成一个叶子节点</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">产生式：					语义规则：</div><div class="line">(1) A → id := E &#123;A.nptr:= mknode(:=,mkleaf(entry(id.name)),E.nptr)&#125;</div><div class="line">(2) E → E1 + E2	&#123;E.nptr:=mknode(+,E1.nptr,E2.nptr)&#125;</div><div class="line">(3) E → E1 * E2 &#123;E.nptr:=mknode(*,E1.nptr,E2.nptr)&#125;</div><div class="line">(4) E → ( E1 )  &#123;E.nptr:=E1.nptr&#125;</div><div class="line">(5) E → - E1	&#123;E.nptr:=mknode(@,E1.nptr, )&#125;</div><div class="line">(6) E → id		&#123;E.nptr:=mkleaf(entry((id.name))&#125;</div></pre></td></tr></table></figure>
<h5 id="树的优化表示DAG"><a href="#树的优化表示DAG" class="headerlink" title="树的优化表示DAG"></a>树的优化表示DAG</h5><p>​    如果树上若干个节点有完全相同的孩子，则这些节点可以指向同一个孩子，形成一个<strong>有向无环图(Directed Acyclic Graph, DAG)</strong><br>​    DAG与树的唯一区别是<strong>多个父亲可以共享同一个孩子</strong>，从而达到<strong>资源（运算、代码等）共享</strong>的目的</p>
<p>​    仅需要在mknode和mkleaf中增加相应的<strong>查询功能</strong><br>​        首先查看所要构造的节点是否已经存在，若存在则无需构造新的节点，直接返回指向已存在节点的指针即可</p>
<h4 id="树与其他中间代码的关系"><a href="#树与其他中间代码的关系" class="headerlink" title="树与其他中间代码的关系"></a>树与其他中间代码的关系</h4><ol>
<li>树表示的中间代码与后缀式和三地址码之间有内在联系</li>
<li>对树进行<strong>深度优先后序遍历</strong>，得到的<strong>线性序列</strong>就是<strong>后缀式</strong>，或者说后缀式是树的一个线性化序列</li>
<li>树的<strong>每个内部节点和它的孩子</strong>对应一个<strong>三元式或四元式</strong></li>
</ol>
<h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><p><strong>符号表的作用：</strong>连接<strong>声明</strong>与<strong>引用</strong>的桥梁，记住每个符号的相关信息，如作用域和绑定等，帮助编译的各个阶段正确有效地工作</p>
<p>符号表的空间存储应该是可以动态扩充的</p>
<p>符号表设计的<strong>基本要求</strong>：目标是<strong>合理存放信息</strong>和<strong>快速准确查找</strong></p>
<ul>
<li><strong>正确存储</strong>各类信息</li>
<li><strong>适应不同阶段的需求</strong></li>
<li>便于<strong>有效</strong>地进行<strong>查找、插入、删除和修改</strong>等操作； </li>
<li><strong>空间</strong>可以<strong>动态扩充</strong></li>
</ul>
<p>逻辑上讲：每个声明的名字在符号表中占据一栏，称为一个<strong>条目</strong>，用于存放名字的相关信息<br>符号表中的内容：<strong>保留字、标识符、特殊符号（包括算符、分隔符等）</strong>等等<br><strong>多个子表</strong>：不同类别的符号可以存放在不同的子表中，如变量名表、过程名表、保留字表等<br>存放方式：<strong>关键字＋属性</strong></p>
<p><em>组合关键字至少应该包括三项：名字＋作用域＋类型</em></p>
<p><strong>构成名字的字符串的存储：</strong></p>
<ul>
<li>定长数据/直接存放<ul>
<li>名字：直接存储名字</li>
</ul>
</li>
<li>变长数据（名字长度变化范围很大）/间接存放<ul>
<li>名字，起始地址；名字间可以用特殊符号隔开，也可以在名字中添加长度</li>
</ul>
</li>
</ul>
<h3 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h3><p><1>  <strong>静态作用域规则</strong>（static-scope rule）：</1></p>
<p>​    <strong>编译时</strong>就可以确定名字的作用域，也可以说，仅从静态读程序就可确定名字的作用域。</p>
<p><2>  <strong>最近嵌套规则</strong>（most closely nested）：<br>        以程序块为例，也适用于过程</2></p>
<ol>
<li>程序块B中声明的作用域包括B；</li>
<li>如果名字x不在B中声明，那么B中x的出现是在外围程序块B’的x声明的作用域中，使得<ul>
<li>B’有x的声明，并且</li>
<li>B’比其它任何含x声明的程序块更接近被嵌套的B </li>
</ul>
</li>
</ol>
<h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><p>线性表应是一个<strong>栈</strong>（后进先出），以正确反映名字的作用域，即<strong>符号的加入和删除，</strong>均在线性表的<strong>一端</strong>进行</p>
<p><strong>查找：</strong>从表头(栈顶)开始，遇到的第一个名字；<br><strong>插入：</strong>先查找，再插入在表头；</p>
<p><strong>删除：</strong><br>(a) 暂时：将在同一作用域的名字同时摘走，适当保存<br>(b) 永久：将在同一作用域的名字同时摘走，不再保存<br><strong>修改：</strong>与查找类似，修改第一个遇到的名字的信息；修改可以用删除＋插入代替</p>
<p><strong>效率（n个条目）：</strong></p>
<ul>
<li>一个名字的<strong>查找</strong><ul>
<li>成功查找(平均)：(n+1)/2</li>
<li>不成功查找：n+1</li>
</ul>
</li>
<li><strong>建立</strong>n个条目的符号表(最坏)：$\displaystyle\sum^n_{i=1}i$ = (n+1)(n+2)/2</li>
</ul>
<h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><p>将线性表分成m个小表，构造<strong>hash函数</strong>，使名字<strong>均匀散布</strong>在m个子表中；若散列均匀，则时间复杂度会降到原线性表的1/m</p>
<p>名字挂在两个链上(便于删除操作)：<br><strong>散列链(hash link)：</strong> 链接所有具有<strong>相同hash值</strong>的元素，表头在表头数组中<br><strong>作用域链(scope link)：</strong>链接所有在<strong>同一作用域</strong>中的元素，表头在作用域链中</p>
<p><strong>操作：</strong></p>
<ul>
<li>查找<ul>
<li>首先计算<strong>散列函数</strong>，然后从散列函数所指示的入口进入某个线性表，在线性表中<strong>沿hash link</strong>，像查找单链表中的名字一样查找</li>
</ul>
</li>
<li>插入<ul>
<li>首先<strong>查找</strong>，以确定要插入的名字是否已在表中，若不在，则要<strong>分别沿hash link和scope link</strong>插入到两个链中，<strong>方法均是插在表头</strong>，即两个表均可看作是<strong>栈</strong></li>
</ul>
</li>
<li>删除<ul>
<li>把<strong>以作用域链连在一起的所有元素</strong>从当前符号表中删除，保<strong>留作用域链所链的子表</strong>，为后继工作使用（如果是临时删除，则下次使用时直接沿作用域链加入到散列链中即可）</li>
</ul>
</li>
</ul>
<p><strong>散列函数的设计：</strong></p>
<ol>
<li>减少冲突，分布均匀</li>
<li>充分考虑程序设计语言的特点<br>如：若有变量V001,V002,…,V300，且首字母的值作为hash值</li>
</ol>
<h2 id="声明语句的翻译"><a href="#声明语句的翻译" class="headerlink" title="声明语句的翻译"></a>声明语句的翻译</h2><p>声明语句的作用是<strong>为可执行语句提供信息</strong>，以便于其执行；对声明语句的处理，主要是将所需要的信息<strong>正确地填写</strong>进合理组织的<strong>符号表</strong>中</p>
<h3 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h3><p><strong>类型定义：</strong>为编译器提供<strong>存储空间大小</strong>的<strong>信息</strong>（预定义&amp;自定义）<br><strong>变量声明：</strong>为变量<strong>分配存储空间</strong><br>组合数据的类型定义和变量声明：<br>        定义与声明在一起，定义与声明分离</p>
<p>决定变量<strong>存储空间</strong>的是变量的<strong>数据类型</strong></p>
<ol>
<li>定义<strong>确定</strong>存储空间，声明<strong>分配</strong>存储空间</li>
<li><em>简单数据类型的存储空间是已经确定的</em>，如integer可以占4个字节，real可以占8个字节，char可以占1个字节等</li>
<li><strong>组合数据</strong>类型变量的存储空间，需要<strong>编译器</strong>根据程序员提供的信息<strong>计算而定</strong></li>
</ol>
<p>定义就好像<code>typedef struct node{};</code>，声明就好像<code>struct node Node;</code>，使用就好像<code>Node.val=1;</code></p>
<h4 id="语法制导翻译-3"><a href="#语法制导翻译-3" class="headerlink" title="语法制导翻译"></a>语法制导翻译</h4><ol>
<li>全程量offset：记录<strong>当前符号存储的偏移量</strong>，初值设为0</li>
<li>属性.type和.width：变量的<strong>类型</strong>和所<strong>占据的存储空间</strong></li>
<li>过程enter(name, type, offset)：为type类型的变量name<strong>建立符号表条目</strong>，并为其<strong>分配存储空间(位置)offset</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">产生式：					语义规则：</div><div class="line">(1)D→D;D	</div><div class="line">(2)D→id:T 	&#123;enter(id.name, T.type, offset); offset:=offset+T.width;&#125;</div><div class="line">(3)T→int	&#123;T.type:=integer; T.width:=4;&#125;</div><div class="line">(4)T→real	&#123;T.type:=real; T.width:=8;&#125;</div><div class="line">(5)T→array [num] of T1 &#123;T.type:=array(num.val, T1.type); T.width:=num.val*T1.width;&#125;</div><div class="line">(6)T→^T1	&#123;T.type:=pointer(T1.type); T.width:=4;&#125;</div></pre></td></tr></table></figure>
<h4 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h4><p>形式上，出现在赋值号左边和右边的变量分别称为左值和右值；<br>实质上，<strong>左值必须具有存储空间</strong>，<strong>右值可以</strong>仅是一个<strong>值</strong>，<strong>而没有存储空间</strong>；（变量【简单变量、组合变量】是左值，左值是地址，右值是值，）形象地讲，<strong>左值是容器，右值是内容</strong></p>
<h3 id="过程的定义与声明"><a href="#过程的定义与声明" class="headerlink" title="过程的定义与声明"></a>过程的定义与声明</h3><p><strong>过程（procedure）</strong>：<strong>过程头/规格说明</strong>(做什么)＋<strong>过程体</strong>(怎么做)；(有返回值的也称为<strong>函数</strong>，被操作系统调用的过程称为<strong>主程序</strong>)<br><strong>过程的三种形式：</strong>过程定义、过程声明和过程调用。<br>过程定义：过程头+过程体；<br>过程声明：过程头</p>
<p><strong>先声明后引用的原则</strong>，若在引用前已定义，则声明可省略，因为定义已包括了声明</p>
<h4 id="参数的传递"><a href="#参数的传递" class="headerlink" title="参数的传递"></a>参数的传递</h4><ol>
<li><p>形参与实参</p>
<ul>
<li><strong>定义时</strong>的参数称为<strong>形参(parameter或formal parameter)</strong>，形式参数</li>
<li><strong>引用时</strong>的参数称为<strong>实参(argument或actual parameter)</strong>，实在参数</li>
</ul>
</li>
<li><p>常见的<strong>参数传递形式</strong>：（不同的语言提供不同的形式）</p>
<ul>
<li><p>值<strong>调用</strong>（call by value）</p>
<ul>
<li>过程内部对参数的修改，不影响作为实参的变量原来的值</li>
<li>任何可以作为<strong>右值</strong>的对象均可作为<strong>实参</strong></li>
<li><strong>过程定义</strong>时<strong>形参被当作局部名</strong>看待，并在过程内部为形参分配存储单元</li>
<li>调用过程前，首先<strong>计算</strong>实参并将值（实参的<strong>右值</strong>）放入形参的存储单元</li>
<li><strong>过程内部</strong>对<strong>形参单元中</strong>的数据<strong>直接访问</strong></li>
</ul>
</li>
<li><p>引用<strong>调用</strong>（call by reference）</p>
<ul>
<li><p>过程内部对形参的修改，等价于直接对实参的修改</p>
</li>
<li><p>实参必须是<strong>左值</strong></p>
</li>
<li><p>定义时形参被当作<strong>局部名</strong>看待，并在过程内部为形参分配存储单元</p>
</li>
<li><p>调用过程前，将作为实参的变量的<strong>地址</strong>（左值）放进形参的存储单元</p>
</li>
<li><p>过程内把形参单元中的数据当作地址，<strong>间接访问</strong></p>
</li>
<li><p>存在副作用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a=<span class="number">2</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_one</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123; a=x+<span class="number">1</span>;  x=x+<span class="number">1</span>; &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span> <span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;   <span class="built_in">cout</span>&lt;&lt;<span class="string">"before:  a="</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//2</span></div><div class="line">    add_one(a);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"after:   a="</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//4</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>复写－恢复（copy-in/copy-out）</strong></p>
<ul>
<li>实参与非本地量共用一个存储空间，使得在过程内改变参数值的同时，也改变了非本地量的值</li>
<li>值调用和引用调用的结合</li>
<li><strong>过程内</strong>对参数的修改<strong>不直接影响实参</strong>，<strong>避免了副作用</strong></li>
<li><strong>返回时</strong>将<strong>形参内容</strong>恢复给<strong>实参</strong>，实现了参数的返回</li>
<li>实参必须是<strong>左值</strong></li>
<li>过程定义时形参被当作<strong>局部名</strong>看待，并在过程内部为形参分配单元(复写)</li>
<li>调用过程前，首先<strong>计算</strong>实参并将值(实参的右值)放入形参的存储单元</li>
<li>过程内部对形参单元中的数据<strong>直接访问</strong></li>
<li><strong>过程返回前</strong>将形参的右值<strong>放回实参的存储单元(恢复)</strong></li>
</ul>
</li>
<li><p>换名<strong>调用</strong>（call by name）</p>
<ul>
<li><strong>过程被认为</strong>宏，每次对过程的调用，实质上是用<strong>过程体替换过程调用</strong>，替换中<strong>用实参的文字替换体中的形参</strong>;这样的替换方式被称为<strong>宏替换或宏展开</strong></li>
<li>当需要保持实参的完整性时， <strong>可以为实参加括弧</strong></li>
<li>在c++中的形式是宏定义<code>#define</code>【一种折中的方法，c++的内敛函数inline，避免了函数调用的同时，也消除了宏替换的副作用】</li>
<li>运行速度快</li>
</ul>
</li>
</ul>
</li>
<li><p>参数传递方法的实质：<br>实参是代表左值、右值、还是实参本身的正文 </p>
</li>
</ol>
<h4 id="过程的作用域"><a href="#过程的作用域" class="headerlink" title="过程的作用域"></a>过程的作用域</h4><p>同样遵守的是<strong>静态作用域</strong>和<strong>最近嵌套原则</strong></p>
<blockquote>
<p>设主程序（最外层过程）的嵌套深度dmain=1，<br> <1> 若过程A直接嵌套定义过程B，则dB=dA+1；<br> <2> <strong>变量声明时</strong>所在过程的嵌套深度，被认为是该变量的嵌套深度</2></1></p>
</blockquote>
<p>​    嵌套过程中名字作用域信息的保存，可以用具有嵌套结构的符号表来实现，<strong>每个过程</strong>可以被认为是<strong>一个子符号表</strong>，或者是<strong>符号表中的一个节点</strong><br>​        <strong>嵌套的节点之间</strong>可以用<strong>双向的链表连接</strong>，<strong>正向的链</strong>指示过程的<strong>嵌套关系</strong>，而<strong>逆向的链</strong>可以用来实现<strong>按作用域对名字的访问</strong></p>
<h4 id="语法制导翻译-4"><a href="#语法制导翻译-4" class="headerlink" title="语法制导翻译"></a>语法制导翻译</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">P → D				(1)</div><div class="line">D → D ; D  			(2)</div><div class="line">   | id : T			(3)</div><div class="line">   | proc id ; D; S	(4) </div><div class="line">修改文法，使得在定义D之前生成符号表，LR分析</div><div class="line">P → M D					(1)</div><div class="line">D → D ; D  				(2)</div><div class="line">   | id : T				(3)</div><div class="line">   | proc id ; N D; S	(4)</div><div class="line">M →ε					(5)</div><div class="line">N →ε					(6)</div></pre></td></tr></table></figure>
<p>全程量：有序对栈（tblptr, offset）</p>
<p>其中，    tblptr保存指向符号表节点的指针，<br>        offset保存当前节点所需宽度。<br><strong>栈上的操作：</strong>push(t, o)、pop、top(stack)</p>
<ol>
<li><strong>函数mktable(previous)：建立</strong>一个<strong>新的节点</strong>，并返回指向新节点的指针;参数<strong>previous是逆向链</strong>，指向该节点的前驱，或者说是外层</li>
<li><strong>过程enter(table, name, type, offset)：</strong>在table指向的节点中<strong>为名字name建立新的条目</strong>，包括名字的类型和存储位置等</li>
<li><strong>过程addwidth(table, width)：</strong>计算table节点中<strong>所有条目</strong>的<strong>累加宽度</strong>，并<strong>记录</strong>在<strong>table的头部信息</strong>中</li>
<li><strong>过程enterproc(table, name, newtable)：</strong>为过程name在table<strong>指向的节点中建立一个新的条目</strong>；参数<strong>newtable是正向链</strong>，指向name过程自身的符号表节点</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">产生式：					语义规则：</div><div class="line">(1) P → M D		&#123;addwidth(top(tblptr),top(offset)); pop;&#125; </div><div class="line">(2) M → ε 		&#123;t:=mktable(null);  push(t, 0,);&#125; </div><div class="line">(3) D → D ; D</div><div class="line">(4) D → id : T	&#123;enter(top(tblptr),id.name,T.type,top(offset));</div><div class="line"> top(offset):=top(offset)+T.width;&#125; </div><div class="line">(5) D → proc id ; N D1; S	&#123; t:=top(tblptr); </div><div class="line">  							  addwidth(t, top(offset));</div><div class="line">  							  pop;</div><div class="line">  							  enterproc(top(tblptr), id.name, t);</div><div class="line">							&#125; </div><div class="line">(6) N → ε 		&#123;t:=mktable(top(tblptr));  push(t,0);&#125;</div></pre></td></tr></table></figure>
<p><img src="/2019/01/09/编译原理-笔记/%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91%E8%BF%87%E7%A8%8B%E5%A3%B0%E6%98%8E.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">序号 产 生 式	   						语 义 处 理 结 果</div><div class="line">(1)  M1→ε   						t1 := mktable(null); push(t1, 0); </div><div class="line">(2)  N1→ε	  						t2 := mktable(top(tblptr));  push(t2, 0);</div><div class="line">(3)  T1→int  						T1.type=integer,  T1.width=4</div><div class="line">(4)  T2→array [10]of T2 			T2.type=array(10,in…≥t),  T2.width=40</div><div class="line">(5)  D1→a:T2 						(a,arr,0)填进t2所指节点，top(offset):=40</div><div class="line">(6)  T3→int  						T3.type=integer,  T3.width=4</div><div class="line">(7)  D2→x:T3						(x,int,40)填进t2所指节点 top(offset):=44</div><div class="line">(8)  N2→ε	  						t3:=mktable(top(tblptr));  push(t3,0);</div><div class="line">(9)  T4→int  						T4.type=integer,  T4.width=4</div><div class="line">(10) D3→i:T4 						(i,int,0)填进t3所指节点，top(offset):=4</div><div class="line">(11) D4→proc readarray N2 D3 ; S	t:=top(tblptr); addwidth(t,top(offset)); pop; 											enterproc(top(tblptr),readarray,t);</div><div class="line">(12) D7→proc sort N1 D6 ; S			t:=top(tblptr); addwidth(t,top(offset)); pop;</div><div class="line">			   						enterproc(top(tblptr),sort,t);</div><div class="line">(13) P→M1 D7 						addwidth(top(tblptr),top(offset)); pop;</div></pre></td></tr></table></figure>
<h2 id="简单算术表达式与赋值句"><a href="#简单算术表达式与赋值句" class="headerlink" title="简单算术表达式与赋值句"></a>简单算术表达式与赋值句</h2><p>简单算术表达式和赋值句，是指<strong>表达式和赋值句中变量</strong>是不可再分的<strong>简单变量</strong></p>
<h3 id="语法制导翻译-5"><a href="#语法制导翻译-5" class="headerlink" title="语法制导翻译"></a>语法制导翻译</h3><ol>
<li>属性.place：存放E的<strong>变量地址</strong>(符号表中地址或临时变量的编码)</li>
<li>过程emit(result ‘:=’ arg1 ‘op’ arg2)：<strong>生成</strong>“result:= arg1 op arg2”的<strong>三地址码</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">产生式：					语义规则：</div><div class="line">(1) A→id:=E		&#123;emit(entry(id.name) &apos;:=&apos; E.place)&#125; </div><div class="line">(2) E→E1+E2		&#123;E.place:=newtemp； </div><div class="line"> emit(E.place &apos;:=&apos; E1.place &apos;+&apos; E2.place)&#125; </div><div class="line">(3) E→E1*E2		&#123;E.place:=newtemp； </div><div class="line"> emit(E.place &apos;:=&apos; E1.place &apos;*&apos; E2.place)&#125; </div><div class="line">(4) E→-E1		&#123;E.place:=newtemp； </div><div class="line"> emit(E.place &apos;:=&apos; &apos;-&apos; E1.place)&#125; </div><div class="line">(5) E→(E1)		&#123;E.place:= E1.place&#125; </div><div class="line">(6) E→id 		&#123;E.place:=entry(id.name)&#125;</div></pre></td></tr></table></figure>
<h3 id="内部类型转换"><a href="#内部类型转换" class="headerlink" title="内部类型转换"></a>内部类型转换</h3><p><strong>强制（coercion）：</strong>按照一定的原则，将不同类型的变量在内部转换为相同的类型，然后进行同类型变量的计算</p>
<p>三地址码：    </p>
<p>T := itr E：将E从整型变为实型，结果存放T中<br>T := rti E：将E从实型变为整型，结果存放T中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">1. A-&gt;id:=E</div><div class="line">&#123; tmode:=entry(id.name).mode;</div><div class="line">  if   tmode=E.mode</div><div class="line">  then emit(entry(id.name) &apos;:=&apos; E.place);</div><div class="line">  else T := newtemp;</div><div class="line">        if   tmode=int </div><div class="line">        then emit(T  &apos;:=&apos; rti E.place); </div><div class="line">        else emit(T  &apos;:=&apos; itr E.place);</div><div class="line">        end if;</div><div class="line">        emit(entry(id.name) &apos;:=&apos; T);</div><div class="line">  end if;</div><div class="line">&#125; </div><div class="line"></div><div class="line">2. E→E1 op E2</div><div class="line">&#123; T:=newtemp；E.mode:=real;</div><div class="line">  if   E1.mode=int</div><div class="line">  then  if   E2.mode=int</div><div class="line">        then emit(T &apos;:=&apos; E1.place OPi E2.place);</div><div class="line">             E.mode := int;</div><div class="line">        else U:=newtemp; </div><div class="line">             emit(U &apos;:=&apos; itr E1.place);</div><div class="line">             emit(T &apos;:=&apos; U OPr E2.place);</div><div class="line">        end if;</div><div class="line">  else 	if   E2.mode=int</div><div class="line">        then U:=newtemp;</div><div class="line">             emit(U &apos;:=&apos; itr E2.place);</div><div class="line">             emit(T &apos;:=&apos; E1.place OPr U);</div><div class="line">        else emit(T &apos;:=&apos; E1.place OPr E2.place);</div><div class="line">        end if;</div><div class="line">  end if;</div><div class="line">  E.place:=T;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="数组元素的引用"><a href="#数组元素的引用" class="headerlink" title="数组元素的引用"></a>数组元素的引用</h2><p>确定数组元素地址的两个要素：<strong>首地址</strong>和<strong>相对首地址的偏移量</strong></p>
<p>不同的映射方式（行or列），使得同一个数组元素相对首地址的<strong>偏移量不同</strong> </p>
<p>确定映射方式的两种方法：</p>
<ul>
<li>由声明时的语法确定映射方式</li>
<li>由编译器确定映射方式</li>
</ul>
<p>三个假设条件：</p>
<ul>
<li>数组元素以<strong>行</strong>为主存放，推广到n维，就是数组的第i维是di个n-i维的数组(每个成员是一个n-i维的数组) ，其中di是第i维成员的个数</li>
<li>数组每维的<strong>下界均为1</strong></li>
<li>每个<strong>元素</strong>仅占<strong>一个标准存贮单元</strong>（可以认为是一个字或者一个字节）。 </li>
</ul>
<p>约定：</p>
<ul>
<li>数组的声明：    <code>A[d1, d2, .., dn]</code></li>
<li>数组元素的引用：<code>A[i1, i2, .., in]</code></li>
</ul>
<p>n维数组元素的地址计算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">addr(A[i1，i2，...，in])</div><div class="line">=a+((i1-1)*d2*d3*...*dn+(i2-1)*d3*d4*...*dn+...+ (in-1))*w</div><div class="line">=a-(d2*d3*...*dn+d3*d4*...*dn+...+dn+1)*w</div><div class="line">   +(i1*d2*d3*...*dn+i2*d3*d4*...*dn+...+in-1*dn+in)*w</div><div class="line">=a–c*w+v*w</div><div class="line">根据假设条件③w=1:  addr(A[i1，i2，...，in])=a–c+v</div><div class="line">其中：</div><div class="line">c = d2*d3*d4...*dn+d3*d4*d5...*dn+*d4*d5*d6...*dn...+dn+1</div><div class="line">  = (d2+1)*d3*...*dn+d4*d5...*dn+...+dn+1</div><div class="line">  =((d2+1)*d3+1)*d4*d5...*dn+...+dn+1</div><div class="line">    ......</div><div class="line">  = (...((d2+1)*d3+1)*d4...+1)*dn+1</div><div class="line">同理：</div><div class="line">v = (...((i1*d2+i2)*d3+i3)*d4...+in-1)*dn+in </div><div class="line"></div><div class="line">令： v1 = i1</div><div class="line">则： v2 = i1*d2+i2 = v1*d2+i2</div><div class="line">     v3 = (v1*d2+i2)*d3+i3 = v2*d3+i3</div><div class="line">	......</div><div class="line">于是有：  v1 = i1	</div><div class="line">          vj = v&#123;j-1&#125;*dj+ij (j=2，3，..., n)		(4.4)</div><div class="line">同理可得：c1 = 1	</div><div class="line">          cj = c&#123;j-1&#125;*dj+1 (j=2，3，..., n)	</div><div class="line">最终得到数组元素引用的地址计算公式：</div><div class="line">addr(A[i1，i2，...，in])=a-c+v=CONSPART+VARPART </div><div class="line">注意：如果w≠1,则c和v分别需要乘一个w，即：</div><div class="line">addr(A[i1，i2，...，in])=a-cw+vw=CONSPART+VARPART</div></pre></td></tr></table></figure>
<p>注意这里计算的时候，最后$i_n$也要减一；同时如果所求的不是起始地址，而是存储地址的时候，则要求写范围，即<code>起始地址-起始地址+w-1</code></p>
<h3 id="语法制导翻译-6"><a href="#语法制导翻译-6" class="headerlink" title="语法制导翻译"></a>语法制导翻译</h3><p>数组元素的寻址：CONSPART[VARPART]，或者T1[T]<br>取值的三地址码：X:=T1[T]    赋值的三地址码：T1[T]:=X</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">A → V := E</div><div class="line">     V → id | id[EL] 	  </div><div class="line">     EL→ E | EL ，E </div><div class="line">     E → E + E  | ( E ) | V</div><div class="line">修改文法以适应递推公式的同步计算，知道名字的时候知道这是一个数组名而不是变量名：</div><div class="line">A → V := E		(1)</div><div class="line">V → id		(2)</div><div class="line">   | EL ]		(3)</div><div class="line">EL→ id [ E		(4)</div><div class="line">   | EL , E		(5)</div><div class="line">E → E + E		(6)</div><div class="line">   | ( E )		(7)</div><div class="line">   |  V		(8)</div></pre></td></tr></table></figure>
<ol>
<li>属性.array：数组名在符号表中的入口和数组<strong>首地址a</strong></li>
<li>属性.dim：数组<strong>维数计数器</strong>，记录当前分析到的维数</li>
<li>属性.place： <ul>
<li><strong>下标列表EL：</strong>存放vj=vj-1*dj+ij (j=2，3，…, n)的临时变量，</li>
<li><strong>简单变量id：</strong>仍然表示简单变量的地址，</li>
<li><strong>数组元素id[EL]：</strong>存放不变部分，一般可以是一个临时变量</li>
</ul>
</li>
<li>属性.offset：保存数组元素的<strong>可变部分</strong>，<pre><code> 简单变量的offset为空，可记为null
</code></pre></li>
<li>函数limit(array, k)：计算并返回数组array中<strong>第k维成员个数dk</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">(1) A→V:=E </div><div class="line">	&#123;if  V.offset=null</div><div class="line">	 then emit(V.place &apos;:=&apos; E.place);</div><div class="line">	 else emit(V.place&apos;[&apos;V.offset&apos;]&apos; &apos;:=&apos; E.place);</div><div class="line">	 end if;&#125; </div><div class="line">(2) V→id &#123; V.place:=entry(id.name); V.offset:=null;&#125; </div><div class="line">(3) V→EL]</div><div class="line">    &#123;V.place:=newtemp; emit(V.place &apos;:=&apos; EL.array &apos;-&apos; c);</div><div class="line">     V.offset:=newtemp;emit(V.offset &apos;:=&apos; EL.place &apos;*&apos; w);&#125;</div><div class="line"> (4) EL→id[E  &#123; EL.place:=E.place;  EL.dim :=1; </div><div class="line">                EL.array:=entry(id.name);&#125;</div><div class="line">(5) EL→EL1,E </div><div class="line">	&#123; T:=newtemp; k:=EL1.dim+1;</div><div class="line">	  dk:=limit(EL1.array, k);</div><div class="line">	  emit(T &apos;:=&apos;EL1.place &apos;*&apos; dk);	-- Vk-1*dk</div><div class="line">	  emit(T &apos;:=&apos; T &apos;+&apos; E.place);  	-- T:=Vk-1*dk+ik</div><div class="line">	  EL.array:=EL1.array; EL.place:=T; EL.dim:=k;&#125; </div><div class="line">(6) E→E1+E2</div><div class="line">	&#123; T:=newtemp;</div><div class="line">	  emit(T &apos;:=&apos; E1.place &apos;+&apos; E2.place);</div><div class="line">	  E.place:=T;&#125; </div><div class="line">(7) E→(E1)&#123; E.place:=E1.place;&#125;</div><div class="line">(8) E→V  &#123; if   V.offset=null;</div><div class="line">            then E.place:=V.place;</div><div class="line">		else T:=newtemp;</div><div class="line">  		     emit(T &apos;:=&apos; V.place &apos;[&apos;V.offset&apos;]&apos;)；</div><div class="line">		     E.place:=T;</div><div class="line">		end if;&#125;</div></pre></td></tr></table></figure>
<h2 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h2><p>从高到低：<code>not  and  or</code></p>
<p><strong>短路计算</strong>可以回避指针为空时对ptr^.data=x的判断，从而</p>
<h3 id="直接计算的语法制导翻译"><a href="#直接计算的语法制导翻译" class="headerlink" title="直接计算的语法制导翻译"></a>直接计算的语法制导翻译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(1)E→E1 or E2  &#123; E.place := newtemp; </div><div class="line">		    emit(E.place &apos;:=&apos; E1.place &apos;or&apos; E2.place);&#125;</div><div class="line">(2)  |E1 and E2 &#123; E.place := newtemp; </div><div class="line">		    emit(E.place &apos;:=&apos; E1.place &apos;and&apos; E2.place);&#125;</div><div class="line">(3)  |not E1&#123; E.place := newtemp; </div><div class="line">		    emit(E.place &apos;:=&apos; &apos;not&apos; E1.place);&#125;</div><div class="line">(4)  |(E1)  &#123; E.place := E1.place;&#125;</div><div class="line">(5)  |id1 relop id2</div><div class="line">(6)  |id    &#123; E.place:=entry(id.name);&#125;</div><div class="line">(7)  |true &#123; E.place:=newtemp; emit(E.place &apos;:=&apos; &apos;1&apos;);&#125;</div><div class="line">(8)  |false &#123; E.place:=newtemp; emit(E.place &apos;:=&apos;&apos;0&apos;);&#125;</div></pre></td></tr></table></figure>
<h3 id="语法制导翻译-7"><a href="#语法制导翻译-7" class="headerlink" title="语法制导翻译"></a>语法制导翻译</h3><ol>
<li>属性 .true：表达式的真出口，它指向表达式为真时的转向</li>
<li>属性 .false：表达式的假出口，它指向表达式为假时的转向；</li>
<li>函数 newlable：与newtemp相似，但它产生的是一个<strong>标号</strong>而<strong>不是一个临时变量</strong></li>
</ol>
<p>这里<code>.code</code>是综合属性，<code>.true</code>和<code>.false</code>是继承属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">(1)E→E1 or E2  </div><div class="line">	&#123; E1.true:= E.true; E1.false:=newlabel;</div><div class="line">	  E2.true:= E.true; E2.false:=E.false; </div><div class="line">	  E.code := E1.code||emit(E1.false &apos;:&apos;)||E2.code;&#125;</div><div class="line">(2)  |E1 and E2</div><div class="line">	 &#123; E1.false:= E.false; E1.true:=newlabel;</div><div class="line">         E2.false:= E.false; E2.true:=E.true; </div><div class="line">         E.code  := E1.code||emit(E1.true&apos;:&apos;)||E2.code;&#125; </div><div class="line">(3)  |not E1 &#123; E1.false:=E.true;   E1.true:=E.false;&#125;</div><div class="line">(4)  |(E1)   &#123; E1.false:=E.false;  E1.true:=E.true;&#125; </div><div class="line">(5)  |id1 relop id2 </div><div class="line">       &#123; E.code := emit</div><div class="line">	      (&apos;if&apos;id1.place relop.op id2.place&apos;goto&apos;E.true)</div><div class="line">           || emit(&apos;goto&apos; E.false);</div><div class="line">       &#125;</div><div class="line">(6)  |id    &#123; E.code := emit(&apos;if&apos; id.place &apos;goto&apos; E.true)</div><div class="line">                  || emit(&apos;goto&apos; E.false);&#125;</div><div class="line">(7)  |true  &#123; E.code := emit(&apos;goto&apos; E.true);&#125;</div><div class="line">(8)  |false &#123; E.code := emit(&apos;goto&apos; E.false);&#125;</div></pre></td></tr></table></figure>
<h3 id="拉链与回填"><a href="#拉链与回填" class="headerlink" title="拉链与回填"></a>拉链与回填</h3><p>拉链与回填的基本思想：</p>
<ul>
<li>当三地址码中的<strong>转向不确定时</strong>，将所有转向<strong>同一地址</strong>的三地址码<strong>拉成一个链</strong></li>
<li><p>一旦所<strong>转向的地址被确定</strong>，则<strong>沿此链将所有的三地址码中回填</strong>入此地址</p>
<p>新增函数与属性：</p>
</li>
</ul>
<ol>
<li>属性.tc：真出口链，链接所有转向<strong>真出口</strong>的三地址码</li>
<li>属性.fc：假出口链，链接所有转向<strong>假出口</strong>的三地址码</li>
<li>属性.stat：记录当前<strong>第一个可用三地址码的序号</strong></li>
<li>函数mkchain(i)：为序号是i的三地址码<strong>构造一个新链</strong>，且返回指向该链的指针</li>
<li>函数merg(P1，P2)：<strong>合并链P1和P2</strong>，且P2成为合并后的链头，并返回链头指针</li>
<li>过程backpatch(P，i)：将<strong>P链中相应域中的所有链域</strong>均回填为i值</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">由于需要增加拉链回填这个语义规则，所以我们在产生式右部引入一个非终结符来实现；同时，为其增加一个新的属性.stat，记录当前第一个可用三地址码的序号</div><div class="line">(1)M→ε					&#123;M.stat:=nextstat;&#125; </div><div class="line">(2)E→E1 or M E2 </div><div class="line">&#123;backpatch(E1.fc, M.stat);</div><div class="line">E.tc:=merge(E1.tc, E2.tc); </div><div class="line"> E.fc:=E2.fc;&#125; </div><div class="line"> </div><div class="line">(3)  |E1 and M E2		</div><div class="line">&#123;backpatch(E1.tc, M.stat);</div><div class="line">E.tc:=merge(E1.fc, E2.fc); </div><div class="line"> E.tc:=E2.tc;&#125; </div><div class="line"> </div><div class="line">(4)  |not E1			&#123;E.tc:=E1.fc; E.fc:=E1.tc;&#125;</div><div class="line">(5)  |(E1) 				&#123;E.tc:=E1.tc; E.fc:=E1.fc;&#125;</div><div class="line"></div><div class="line">(6) E→id1 relop id2				--这里直接写如a&lt;b，而不用写id1 relop id2，然后再画线了</div><div class="line"> &#123; E.tc:=mkchain(nextstat); </div><div class="line"> E.fc:=mkchain(nextstat+1);</div><div class="line"> emit(&apos;if&apos; id1.place relop.op id2.place &apos;goto -&apos;);</div><div class="line"> emit(&apos;goto -&apos;);</div><div class="line"> &#125; </div><div class="line">(7)   |id &#123; E.tc:=mkchain(nextstat);</div><div class="line">	 	E.fc:=mkchain(nextstat+1);</div><div class="line">      	emit(&apos;if&apos; id.place &apos;goto -&apos;);</div><div class="line">      	emit(&apos;goto -&apos;); &#125;</div><div class="line">(8)   |true &#123;E.tc:=mkchain(nextstat); emit(&apos;goto -&apos;);&#125;</div><div class="line">(9)   |false&#123;E.fc:=mkchain(nextstat); emit(&apos;goto -&apos;);&#125;</div></pre></td></tr></table></figure>
<h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><p>四类控制语句：</p>
<ul>
<li>无条件转移：goto （转向某标号所在位置）<pre><code>   exit、break（退出某个范围）
</code></pre><ul>
<li>两个要素<ul>
<li>标号所标记的位置和goto所转向的标号</li>
<li>起<strong>标记位置作用</strong>的标号被称为标号的<strong>定义出现</strong></li>
<li>用于<strong>goto转向的标号</strong>被称为标号的<strong>引用出现</strong></li>
<li>在一定的作用域内，<strong>标号仅可以定义一次，而可以引用多次</strong></li>
<li>当标号定义出现时，将有关信息填写进符号表中</li>
<li>而当标号引用出现时，根据符号表中的信息生成正确转移的三地址码</li>
<li>但在有些情况下标号的引用先于标号的定义。解决的方法是借助于符号表的拉链与回填</li>
</ul>
</li>
</ul>
</li>
<li>条件转移：   if_then_else，while_do：判断布尔表达式</li>
<li>循环：           for_loop：设定下限、上限与循环步长</li>
<li>分支：           case、switch：根据不同的取值执行不同的分支 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">S→ id:S			(1) // 带标号的语句</div><div class="line">  | goto id			(2) // goto语句</div><div class="line">  | if E then S		(3)</div><div class="line">  | if E then S else S	(4)</div><div class="line">  | while E do S		(5)</div><div class="line">  | A				(6) // 赋值语句</div><div class="line">  | begin L end		(7) // 组合语句</div><div class="line">L→ L;S			(8) // 语句序列</div><div class="line">  | S				(9)</div></pre></td></tr></table></figure>
<h3 id="无条件转移"><a href="#无条件转移" class="headerlink" title="无条件转移"></a>无条件转移</h3><p>在符号表中为标号设置以下信息域：</p>
<ol>
<li>type：记录标识符的类型，如‘标号’或‘未知’</li>
<li>def： 若是标号，记录是否已定义，如‘未定义’或‘已定义’</li>
<li>addr：标号定义前作为链头，标号定义后作为此标号对应三地址码的序号</li>
</ol>
<p><strong>定义过程：fill(entry(id.name), a, b, c)</strong>，将a, b, c分别填写到符号表中标识符id的.type、.def、.addr域中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">(1)S→goto id</div><div class="line">   &#123; if   entry(id.name).type=&apos;未知&apos;       -- 标识符第一次出现</div><div class="line">     then fill(entry(id.name),&apos;标号&apos;, &apos;未定义&apos;, nextstat);</div><div class="line">          emit(&apos;goto -&apos;);</div><div class="line">     else if   entry(id.name).type =&apos;标号&apos;   -- 已出现且是标号</div><div class="line">          then emit(&apos;goto&apos;, entry(id).addr)；</div><div class="line">               if    entry(id.name).def=‘未定义’ -- 尚未定义，拉链</div><div class="line">               then  fill(entry(id.name),&apos;标号&apos;,&apos;未定义&apos;,nextstat-1);</div><div class="line">               end if;</div><div class="line">          else  error；  -- 标识符已出现且类型不是标号，出错</div><div class="line">          end if;</div><div class="line">     end if;</div><div class="line">   &#125;</div><div class="line">(2)S  →LAB S &#123; -- 略（根据S是何种语句，进行相应的翻译）&#125;</div><div class="line">(3) LAB→id &apos;：&apos;</div><div class="line">    &#123; if   entry(id.name).type=&apos;未知&apos;   -- 标识符第一次出现</div><div class="line">      then fill(entry(id.name), &apos;标号&apos;, &apos;已定义&apos;, nextstat);</div><div class="line">      else if    entry(id.name).type=&apos;标号&apos;  </div><div class="line">                 and entry(id.name).def=&apos;未定义&apos; -- 还未定义出现</div><div class="line">           then q:=entry(id.name).addr;  </div><div class="line">                fill(entry(id.name), &apos;标号&apos;, &apos;已定义&apos;, nextstat);</div><div class="line">                backpatch(q, nextstat);</div><div class="line">           else error;         -- 其它情况均出错</div><div class="line">           end if;</div><div class="line">      end if;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="条件转移"><a href="#条件转移" class="headerlink" title="条件转移"></a>条件转移</h3><ol>
<li>属性.begin：语句S开始的三地址码序号</li>
<li>属性.next： 语句S结束后的三地址码 序号</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">(1) S→if E then S1</div><div class="line">&#123;	E.true:=newlabel; E.false:=S.next; S1.next:=S.next;</div><div class="line">S.code:=E.code||emit(E.true&apos;:&apos;)||S1.code;</div><div class="line">&#125; </div><div class="line">(2) S→if E then S1 else S2</div><div class="line">&#123; E.true :=newlabel;   E.false:=newlabel;</div><div class="line"> S1.next:=S.next; 	S2.next:=S.next;</div><div class="line"> S.code := E.code </div><div class="line">	|| emit(E.true &apos;:&apos;) || S1.code</div><div class="line">      || emit(&apos;goto&apos; S.next)</div><div class="line">	|| emit(E.false &apos;:&apos;) || S2.code; </div><div class="line"></div><div class="line">&#125;</div><div class="line">(3) S→while E do S1</div><div class="line">&#123; S.begin := newlabel; E.true := newlabel;</div><div class="line">E.false := S.next;   S1.next := S.begin;</div><div class="line">S.code :=   emit(S.begin &apos;:&apos;) || E.code</div><div class="line">	   || emit(E.true &apos;:&apos;)  || S1.code </div><div class="line">	   || emit(&apos;goto&apos; S.begin)</div><div class="line">	   || emit(E.false &apos;:&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当有嵌套等控制流的问题的时候：通过拉链回填的方法</p>
<ol>
<li>属性.nc：语句结束后的转向；未确定时拉链，确定后回填</li>
<li>属性.begin：语句(如while)的三地址码序列首地址 </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(1)M→ε 		&#123;M.stat:=nextstat;&#125;</div><div class="line">(2)S→if E then M S1		&#123;backpatch(E.tc,M.stat);S.nc:= merge(E.fc,S1.nc);&#125;</div><div class="line">(3)N→ε		&#123;N.nc:= mkchain(nextstat); emit(&apos;goto -&apos;);&#125;</div><div class="line">(4)S→if E then M1 S1 N else M2 S2</div><div class="line">&#123;backpatch(E.tc,M1.stat); backpatch(E.fc,M2.stat);</div><div class="line"> S.nc:=merge(S1.nc,merge(N.nc,S2.nc));&#125; </div><div class="line">(5)S→while M1 E do M2 S1</div><div class="line">&#123;backpatch(S1.nc,M1.stat); backpatch(E.tc,M2.stat);</div><div class="line"> S.nc:=E.fc; emit(&apos;goto&apos; M1.stat);&#125; </div><div class="line">(6)S→A		&#123;S.nc := mkchain();&#125;</div></pre></td></tr></table></figure>
<h2 id="练习题-2"><a href="#练习题-2" class="headerlink" title="练习题"></a>练习题</h2><ol>
<li><p>将下述语句翻译成后缀式</p>
<p><code>a*-(b+c)</code>            abc+-*</p>
<p><code>-(a+b)*(c+d)+(a+b-c)</code>        ab+-cd+*ab+c-+</p>
<p><code>if i&lt;10 then i:=10 else i:=0</code>        i10&lt;i10:=i0:=if-then-else</p>
</li>
</ol>
<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul>
<li>老师上课说，给定的优先级顺序不一定和平常相同，即有可能出现+的优先级比*的高的情况，所以需要具体问题具体分析</li>
</ul>
<p>其他：<a href="https://max.book118.com/html/2018/0506/165036532.shtm" target="_blank" rel="external">课后习题答案</a></p>
<p>转载请注明出处，谢谢。<br><blockquote class="blockquote-center"><p>愿 我是你的小太阳</p>
</blockquote></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=2931596&auto=1&height=66"></iframe>

<!-- UY BEGIN -->
<p><div id="uyan_frame"></div></p>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2142537"></script>

<!-- UY END -->

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>买糖果去喽</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechat.jpg" alt="Mrs_empress WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Notes/" rel="tag"><i class="fa fa-tag"></i> Notes</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/08/软件体系结构-笔记/" rel="next" title="软件体系结构-笔记">
                <i class="fa fa-chevron-left"></i> 软件体系结构-笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/27/设计模式/" rel="prev" title="设计模式">
                设计模式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="/images/avatar.jpg"
              alt="Mrs_empress" />
          
            <p class="site-author-name" itemprop="name">Mrs_empress</p>
            <p class="site-description motion-element" itemprop="description">Hope be better and better, wish be happy and happy!</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives">
            
                <span class="site-state-item-count">101</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">40</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">71</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/mrsempress" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.facebook.com/chenxi.huang.56211" target="_blank" title="FB Page">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      FB Page
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/3309079767?refer_flag=1001030001_&nick=Mrs_empress_阡沫昕&is_hot=1" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      微博
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://tobiaslee.top" title="TobiasLee" target="_blank">TobiasLee</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://abcml.xin/" title="ZeZe" target="_blank">ZeZe</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://notes-hongbo.top" title="Bob" target="_blank">Bob</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://undefinedf.github.io/" title="Fjh" target="_blank">Fjh</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#引言"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#语言"><span class="nav-number">1.1.</span> <span class="nav-text">语言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分类"><span class="nav-number">1.1.1.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语言之间的翻译"><span class="nav-number">1.1.2.</span> <span class="nav-text">语言之间的翻译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编译器与解释器"><span class="nav-number">1.1.3.</span> <span class="nav-text">编译器与解释器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#特点"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工作过程"><span class="nav-number">1.1.4.</span> <span class="nav-text">工作过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#词法分析"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">词法分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#语法分析"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">语法分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#语义分析"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">语义分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中间代码生成（可选）"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">中间代码生成（可选）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中间代码优化（可选）"><span class="nav-number">1.1.4.5.</span> <span class="nav-text">中间代码优化（可选）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#目标代码生成"><span class="nav-number">1.1.4.6.</span> <span class="nav-text">目标代码生成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#符号表管理"><span class="nav-number">1.1.4.7.</span> <span class="nav-text">符号表管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#出错处理"><span class="nav-number">1.1.4.8.</span> <span class="nav-text">出错处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工作模式"><span class="nav-number">1.1.5.</span> <span class="nav-text">工作模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扫描"><span class="nav-number">1.1.6.</span> <span class="nav-text">扫描</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#词法分析-1"><span class="nav-number">2.</span> <span class="nav-text">词法分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#词法"><span class="nav-number">2.0.1.</span> <span class="nav-text">词法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本分类"><span class="nav-number">2.0.1.1.</span> <span class="nav-text">基本分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模式的形式化描述"><span class="nav-number">2.0.2.</span> <span class="nav-text">模式的形式化描述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串"><span class="nav-number">2.0.2.1.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#正规式"><span class="nav-number">2.0.2.2.</span> <span class="nav-text">正规式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有限自动机"><span class="nav-number">2.0.3.</span> <span class="nav-text">有限自动机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#NFA"><span class="nav-number">2.0.3.1.</span> <span class="nav-text">NFA</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#表示方式"><span class="nav-number">2.0.3.1.1.</span> <span class="nav-text">表示方式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#状态转换图"><span class="nav-number">2.0.3.1.1.1.</span> <span class="nav-text">状态转换图</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#状态转换矩阵"><span class="nav-number">2.0.3.1.1.2.</span> <span class="nav-text">状态转换矩阵</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#识别记号的特点"><span class="nav-number">2.0.3.1.2.</span> <span class="nav-text">识别记号的特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方法与问题"><span class="nav-number">2.0.3.1.3.</span> <span class="nav-text">方法与问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DFA"><span class="nav-number">2.0.3.2.</span> <span class="nav-text">DFA</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#识别记号的特点-1"><span class="nav-number">2.0.3.2.1.</span> <span class="nav-text">识别记号的特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#有限自动机的等价"><span class="nav-number">2.0.3.2.2.</span> <span class="nav-text">有限自动机的等价</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NFA与DFA"><span class="nav-number">2.0.3.3.</span> <span class="nav-text">NFA与DFA</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#词法分析器的构造"><span class="nav-number">2.0.3.4.</span> <span class="nav-text">*词法分析器的构造</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#方法和步骤"><span class="nav-number">2.0.3.4.1.</span> <span class="nav-text">方法和步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#从正规式到NFA"><span class="nav-number">2.0.3.4.2.</span> <span class="nav-text">从正规式到NFA</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Thompson算法"><span class="nav-number">2.0.3.4.2.1.</span> <span class="nav-text">Thompson算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#从NFA到DFA"><span class="nav-number">2.0.3.4.3.</span> <span class="nav-text">从NFA到DFA</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#“并行”模拟NFA"><span class="nav-number">2.0.3.4.3.1.</span> <span class="nav-text">“并行”模拟NFA</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#“子集法”构造DFA"><span class="nav-number">2.0.3.4.3.2.</span> <span class="nav-text">“子集法”构造DFA</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#最小化DFA"><span class="nav-number">2.0.3.4.3.3.</span> <span class="nav-text">最小化DFA</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#由DFA构造词法分析器"><span class="nav-number">2.0.3.4.4.</span> <span class="nav-text">由DFA构造词法分析器</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#表驱动型的词法分析器"><span class="nav-number">2.0.3.4.4.1.</span> <span class="nav-text">表驱动型的词法分析器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#直接编码的词法分析器"><span class="nav-number">2.0.3.4.4.2.</span> <span class="nav-text">直接编码的词法分析器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#两者的比较"><span class="nav-number">2.0.3.4.4.3.</span> <span class="nav-text">两者的比较</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习题"><span class="nav-number">2.1.</span> <span class="nav-text">练习题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#语法分析-1"><span class="nav-number">3.</span> <span class="nav-text">语法分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#语法分析器"><span class="nav-number">3.1.</span> <span class="nav-text">语法分析器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#语法错误的处理原则"><span class="nav-number">3.1.1.</span> <span class="nav-text">语法错误的处理原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#上下文无关文法CFG"><span class="nav-number">3.2.</span> <span class="nav-text">上下文无关文法CFG</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CFG产生语言的基本方法——推导"><span class="nav-number">3.2.1.</span> <span class="nav-text">CFG产生语言的基本方法——推导</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CFL上下文无关语言"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">CFL上下文无关语言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分析树"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">分析树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#语法树"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">语法树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二义性与二义性的消除"><span class="nav-number">3.2.1.4.</span> <span class="nav-text">二义性与二义性的消除</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#改写二义文法为非二义文法"><span class="nav-number">3.2.1.4.1.</span> <span class="nav-text">改写二义文法为非二义文法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#规定二义文法中符号的优先级和结合性"><span class="nav-number">3.2.1.4.2.</span> <span class="nav-text">规定二义文法中符号的优先级和结合性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#修改语言的语法（表现形式被改变）"><span class="nav-number">3.2.1.4.3.</span> <span class="nav-text">修改语言的语法（表现形式被改变）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正规式与CFG"><span class="nav-number">3.2.2.</span> <span class="nav-text">正规式与CFG</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#正规式到CFG的转换"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">正规式到CFG的转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#上下文有关语言CSL"><span class="nav-number">3.3.</span> <span class="nav-text">上下文有关语言CSL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#形式语言与自动机"><span class="nav-number">3.4.</span> <span class="nav-text">形式语言与自动机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自上而下分析"><span class="nav-number">3.5.</span> <span class="nav-text">自上而下分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#消除左递归"><span class="nav-number">3.5.1.</span> <span class="nav-text">消除左递归</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#消除直接左递归"><span class="nav-number">3.5.1.1.</span> <span class="nav-text">消除直接左递归</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#消除文法左递归"><span class="nav-number">3.5.1.2.</span> <span class="nav-text">消除文法左递归</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#提取左因子"><span class="nav-number">3.5.2.</span> <span class="nav-text">提取左因子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归下降分析"><span class="nav-number">3.5.3.</span> <span class="nav-text">递归下降分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#预测分析器"><span class="nav-number">3.5.4.</span> <span class="nav-text">预测分析器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#预测分析表"><span class="nav-number">3.5.4.1.</span> <span class="nav-text">预测分析表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#构造预测分析表"><span class="nav-number">3.5.4.1.1.</span> <span class="nav-text">构造预测分析表</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#FIRST集合计算"><span class="nav-number">3.5.4.1.1.1.</span> <span class="nav-text">FIRST集合计算</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#FOLLOW集合计算"><span class="nav-number">3.5.4.1.1.2.</span> <span class="nav-text">FOLLOW集合计算</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#驱动器"><span class="nav-number">3.5.4.2.</span> <span class="nav-text">驱动器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LL-1-文法"><span class="nav-number">3.5.4.3.</span> <span class="nav-text">LL(1)文法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#证明是LL-1-文法"><span class="nav-number">3.5.4.3.1.</span> <span class="nav-text">证明是LL(1)文法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自下而上分析"><span class="nav-number">3.6.</span> <span class="nav-text">自下而上分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#规范规约"><span class="nav-number">3.6.1.</span> <span class="nav-text">规范规约</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最左规约"><span class="nav-number">3.6.1.1.</span> <span class="nav-text">最左规约</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#移进-归约分析器"><span class="nav-number">3.6.2.</span> <span class="nav-text">移进-归约分析器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LR分析"><span class="nav-number">3.6.3.</span> <span class="nav-text">LR分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LR分析表"><span class="nav-number">3.6.3.1.</span> <span class="nav-text">LR分析表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SLR-1-分析器"><span class="nav-number">3.6.3.2.</span> <span class="nav-text">SLR(1)分析器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#拓广文法"><span class="nav-number">3.6.3.2.1.</span> <span class="nav-text">拓广文法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#从NFA到DFA-1"><span class="nav-number">3.6.3.2.2.</span> <span class="nav-text">从NFA到DFA</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#活前缀与项目"><span class="nav-number">3.6.3.2.3.</span> <span class="nav-text">活前缀与项目</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#证明是SLR-1-文法"><span class="nav-number">3.6.3.2.3.1.</span> <span class="nav-text">证明是SLR(1)文法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#证明是LR-0-文法"><span class="nav-number">3.6.3.2.3.2.</span> <span class="nav-text">证明是LR(0)文法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#构造SLR分析表"><span class="nav-number">3.6.3.2.4.</span> <span class="nav-text">构造SLR分析表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非SLR-1-文法"><span class="nav-number">3.6.3.3.</span> <span class="nav-text">非SLR(1)文法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习题-1"><span class="nav-number">3.7.</span> <span class="nav-text">练习题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#静态语义分析"><span class="nav-number">4.</span> <span class="nav-text">静态语义分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#语法与语义"><span class="nav-number">4.1.</span> <span class="nav-text">语法与语义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#语法制导翻译"><span class="nav-number">4.1.1.</span> <span class="nav-text">语法制导翻译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语义规则"><span class="nav-number">4.1.2.</span> <span class="nav-text">语义规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性"><span class="nav-number">4.1.3.</span> <span class="nav-text">属性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#注释分析树"><span class="nav-number">4.1.3.0.1.</span> <span class="nav-text">注释分析树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LR分析翻译方案的设计"><span class="nav-number">4.1.4.</span> <span class="nav-text">LR分析翻译方案的设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归下降分析翻译方案的设计"><span class="nav-number">4.1.5.</span> <span class="nav-text">递归下降分析翻译方案的设计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#中间代码"><span class="nav-number">4.2.</span> <span class="nav-text">中间代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#后缀式"><span class="nav-number">4.2.1.</span> <span class="nav-text">后缀式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三地址码"><span class="nav-number">4.2.2.</span> <span class="nav-text">三地址码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#三元式"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">三元式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#语法制导翻译-1"><span class="nav-number">4.2.2.1.1.</span> <span class="nav-text">语法制导翻译</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四元式"><span class="nav-number">4.2.2.2.</span> <span class="nav-text">四元式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#语法制导翻译-2"><span class="nav-number">4.2.2.2.1.</span> <span class="nav-text">语法制导翻译</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#图形表示"><span class="nav-number">4.2.2.3.</span> <span class="nav-text">图形表示</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#树语法制导翻译"><span class="nav-number">4.2.2.3.1.</span> <span class="nav-text">树语法制导翻译</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#树的优化表示DAG"><span class="nav-number">4.2.2.3.2.</span> <span class="nav-text">树的优化表示DAG</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#树与其他中间代码的关系"><span class="nav-number">4.2.2.4.</span> <span class="nav-text">树与其他中间代码的关系</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#符号表"><span class="nav-number">4.3.</span> <span class="nav-text">符号表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#名字的作用域"><span class="nav-number">4.3.1.</span> <span class="nav-text">名字的作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线性表"><span class="nav-number">4.3.2.</span> <span class="nav-text">线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#散列表"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">散列表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#声明语句的翻译"><span class="nav-number">4.4.</span> <span class="nav-text">声明语句的翻译</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#变量的声明"><span class="nav-number">4.4.1.</span> <span class="nav-text">变量的声明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#语法制导翻译-3"><span class="nav-number">4.4.1.1.</span> <span class="nav-text">语法制导翻译</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#左值与右值"><span class="nav-number">4.4.1.2.</span> <span class="nav-text">左值与右值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#过程的定义与声明"><span class="nav-number">4.4.2.</span> <span class="nav-text">过程的定义与声明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#参数的传递"><span class="nav-number">4.4.2.1.</span> <span class="nav-text">参数的传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#过程的作用域"><span class="nav-number">4.4.2.2.</span> <span class="nav-text">过程的作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#语法制导翻译-4"><span class="nav-number">4.4.2.3.</span> <span class="nav-text">语法制导翻译</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单算术表达式与赋值句"><span class="nav-number">4.5.</span> <span class="nav-text">简单算术表达式与赋值句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#语法制导翻译-5"><span class="nav-number">4.5.1.</span> <span class="nav-text">语法制导翻译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部类型转换"><span class="nav-number">4.5.2.</span> <span class="nav-text">内部类型转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组元素的引用"><span class="nav-number">4.6.</span> <span class="nav-text">数组元素的引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#语法制导翻译-6"><span class="nav-number">4.6.1.</span> <span class="nav-text">语法制导翻译</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#布尔表达式"><span class="nav-number">4.7.</span> <span class="nav-text">布尔表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#直接计算的语法制导翻译"><span class="nav-number">4.7.1.</span> <span class="nav-text">直接计算的语法制导翻译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语法制导翻译-7"><span class="nav-number">4.7.2.</span> <span class="nav-text">语法制导翻译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拉链与回填"><span class="nav-number">4.7.3.</span> <span class="nav-text">拉链与回填</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控制语句"><span class="nav-number">4.8.</span> <span class="nav-text">控制语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#无条件转移"><span class="nav-number">4.8.1.</span> <span class="nav-text">无条件转移</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件转移"><span class="nav-number">4.8.2.</span> <span class="nav-text">条件转移</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习题-2"><span class="nav-number">4.9.</span> <span class="nav-text">练习题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#注意点"><span class="nav-number">5.</span> <span class="nav-text">注意点</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2017 &mdash; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mrs_empress</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" href="https://hexo.io">Hexo</a></div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">Theme &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("73XX9zwrQOBeD6S0LGJO26Ac-gzGzoHsz", "92PFBxqwUfTSuVqrflFGaf5G");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
